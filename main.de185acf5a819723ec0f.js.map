{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./.fable/fable-library.2.10.1/Util.js","webpack:///./.fable/fable-library.2.10.1/Types.js","webpack:///./.fable/fable-library.2.10.1/Reflection.js","webpack:///./.fable/fable-library.2.10.1/Int32.js","webpack:///./.fable/fable-library.2.10.1/lib/long.js","webpack:///./.fable/fable-library.2.10.1/Long.js","webpack:///./.fable/fable-library.2.10.1/Date.js","webpack:///./.fable/fable-library.2.10.1/lib/big.js","webpack:///./.fable/fable-library.2.10.1/Decimal.js","webpack:///./.fable/fable-library.2.10.1/RegExp.js","webpack:///./.fable/fable-library.2.10.1/String.js","webpack:///./.fable/fable-library.2.10.1/Option.js","webpack:///.fable/Thoth.Json.4.1.0/Types.fs","webpack:///./.fable/fable-library.2.10.1/Seq.js","webpack:///./.fable/fable-library.2.10.1/MutableMap.js","webpack:///./.fable/fable-library.2.10.1/Map.js","webpack:///./.fable/fable-library.2.10.1/MutableSet.js","webpack:///./.fable/fable-library.2.10.1/Set.js","webpack:///./.fable/fable-library.2.10.1/Array.js","webpack:///./.fable/fable-library.2.10.1/BigInt/n.js","webpack:///./.fable/fable-library.2.10.1/BigInt/z.js","webpack:///./.fable/fable-library.2.10.1/List.js","webpack:///./.fable/fable-library.2.10.1/BigInt.js","webpack:///./.fable/fable-library.2.10.1/DateOffset.js","webpack:///./.fable/fable-library.2.10.1/TimeSpan.js","webpack:///.fable/Thoth.Json.4.1.0/Decode.fs","webpack:///src/DecoderExtra.fs","webpack:///src/BattleResult.fs","webpack:///.fable/Fable.Promise.2.0.0/Promise.fs","webpack:///.fable/Thoth.Json.4.1.0/Encode.fs","webpack:///.fable/Fable.Promise.2.0.0/PromiseImpl.fs","webpack:///.fable/Thoth.Fetch.2.0.0/Fetch.fs","webpack:///src/ExpectedValues.fs","webpack:///src/Protocol.fs","webpack:///./.fable/fable-library.2.10.1/AsyncBuilder.js","webpack:///./.fable/fable-library.2.10.1/Async.js","webpack:///.fable/Fable.Elmish.3.0.6/prelude.fs","webpack:///.fable/Fable.Elmish.3.0.6/cmd.fs","webpack:///src/Util.fs","webpack:///src/Rating.fs","webpack:///.fable/Fable.Elmish.3.0.6/ring.fs","webpack:///.fable/Fable.Elmish.3.0.6/program.fs","webpack:///.fable/Fable.Elmish.React.3.0.1/common.fs","webpack:///.fable/Fable.Elmish.React.3.0.1/react.fs","webpack:///src/App.fs"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","isArrayLike","x","Array","isArray","ArrayBuffer","isView","isDisposable","Dispose","tryGetValue","map","defaultValue","has","Lazy","factory","this","isValueCreated","createdValue","padWithZeros","str","toString","dateOffset","date","date1","offset","kind","getTimezoneOffset","int32ToString","radix","ObjectRef","idMap","set","count","stringHash","h","len","charCodeAt","numberHash","combineHashCodes","hashes","reduce","h1","h2","structuralHash","GetHashCode","isHashable","String","equalArraysWith","y","eq","equalArrays","equals","Equals","isEquatable","Date","compareDates","xtime","ytime","getTime","comparePrimitives","compareArraysWith","comp","compareArrays","compare","CompareTo","isComparable","min","comparer","max","WeakMap","CaseRules","dashify","separator","replace","toLowerCase","charAt","changeCase","caseRule","toUpperCase","createObj","fields","fail","kvPair","Error","definedCaseRule","toJSON","uncurry","arity","f","uncurriedFn","a1","a2","a3","a4","a5","a6","a7","a8","curry","partialApply","args","undefined","concat","mapCurriedArgs","fn","mappings","arg","mapArg","idx","mapping","expectedArity","actualArity","res","addToDict","dict","k","v","getItemFromDict","sameType","getPrototypeOf","constructor","declare","cons","superClass","subClass","writable","configurable","inherits","entries","join","id","identityHash","other","compareList","self","tail","head","from","iterator","cur","next","done","tag","super","recordToJson","record","getFieldNames","keys","recordEquals","thisNames","recordCompare","values","FSharpRef","contents","message","stack","CaseInfo","declaringType","TypeInfo","fullname","generics","construct","cases","enumCases","fullName","getGenerics","t1","t2","getRecordElements","k1","v1","k2","v2","class_type","record_type","union_type","list_type","generic","obj_type","int32_type","float64_type","info","lastIndexOf","substr","gen","endsWith","getElementType","_a","isGenericType","isEnum","getGenericTypeDefinition","getEnumUnderlyingType","getEnumValues","kv","getEnumCase","parseEnum","parseInt","isNaN","getUnionCases","getTupleElements","isTuple","isUnion","isRecord","startsWith","getUnionCaseFields","uci","makeUnion","expectedLength","makeRecord","obj","_t","assign","NumberStyles","getRange","unsigned","bitsize","isValid","style","exec","prefix","digits","getInvalidDigits","AllowHexSpecifier","getRadix","test","regexMatch","sign","validResponse","tryParse","Number","umin","umax","parse","op_UnaryNegation_Int32","wasm","WebAssembly","Instance","Module","Uint8Array","e","Long","low","high","isLong","__isLong__","INT_CACHE","UINT_CACHE","fromInt","cachedObj","cache","fromBits","fromNumber","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL","lowBits","highBits","pow_dbl","Math","pow","fromString","RangeError","indexOf","substring","radixToPower","size","add","multiply","fromValue","val","TWO_PWR_16_DBL","TWO_PWR_24","ONE","UONE","NEG_ONE","toInt","$this","toNumber","isZero","radixLong","div","divide","rem1","subtract","rem","remDiv","isOdd","lessThan","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","addend","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","subtrahend","multiplier","mul","get_high","b00","divisor","approx","div_u","div_s","toUnsigned","shiftRightUnsigned","shiftLeft","shiftRight","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","numBits","op_Addition","op_Multiply","op_Division","op_Modulus","rem_u","rem_s","op_UnaryNegation","op_BitwiseAnd","bytes","le","fromBytesLE","fromBytesBE","hi","lo","toBytesLE","toBytesBE","fromInteger","xh","_bitsize","lessOrEqual","padStart","isNegative","maxValue","getMaxValue","offsetRegex","dateOffsetToString","isMinus","minutes","abs","dateToHalfUTCString","half","toISOString","dateToStringWithCustomFormat","format","utc","match","rep","NaN","getUTCFullYear","getFullYear","getUTCMonth","getMonth","getUTCDate","getDate","getUTCHours","getHours","getUTCMinutes","getMinutes","getUTCSeconds","getSeconds","getUTCMilliseconds","getMilliseconds","dateToStringWithOffset","_b","_c","dateWithOffset","dateToISOStringWithOffset","dateToStringWithKind","toUTCString","toLocaleString","toLocaleDateString","toLocaleTimeString","printOffset","dateToISOString","_provider","DateTime","minValue","parseRaw","baseDate","timeInSeconds","timeParts","split","parseFloat","offsetParts","offsetInMinutes","detectUTC","P","cmp","NAME","INVALID","INVALID_DP","NUMERIC","nl","search","Big","DP","RM","dp","rm","more","xc","unshift","pop","stringify","z","NE","PE","isneg","yc","a","b","bl","bt","ri","bz","ai","al","rl","q","qc","qi","gt","gte","lt","lte","minus","sub","xlty","plus","xe","ye","reverse","mod","ygtx","times","one","round","sqrt","toExponential","toFixed","toPrecision","sd","valueOf","_Big_","findIndex","normalize","version","Decimal","pattern","options","flags","RegExp","matches","reg","lastIndex","global","fsFormatRegExp","formatRegExp","guidRegex","isNumeric","isLessThan","toHex","printf","input","cont","createPrinter","strCopy","formatOnce","toText","toFail","str2","_","padLength","precision","zeroFlag","minusFlag","ch","padLeft","intPart","decimalPart","delimiter","xs","validateGuid","doNotThrow","trimmedAndLowered","chars","trim","isRight","some","defaultArg","opt","mapOk","mapError","__","matchValue","( .ctor )","caseStrategy","fieldName","replacement","limit","tmp","arguments","index","_s","sub1","_matches","sub2","lowerFirst","Enumerator","iter","current","getEnumerator","toIterator","en","MoveNext","Current","makeSeq","seq","append","ys","delay","firstDone","iters","unfold","output","innerIter","hasFinished","singleton","exists","contains","fold","acc","iterate","iterateIndexed","mapIndexed","rangeNumber","first","step","last","skip","sumBy","adder","Add","GetZero","take","truncate","fst","MutableMap$00602","pairs","this$","hashMap","Map","pair","MutableMap$00602$$Add$$5BDDA1","MutableMap$00602$$TryFindIndex$$2B595","this$$$1","pair$$1","MutableMap$00602$$TryFind$$2B595","this$$$2","k$$1","matchValue$$1","MutableMap$00602$$Clear","this$$$4","clear","MutableMap$00602$$get_Count","this$$$5","pairs$$2","$x$$2","$y$$3","this$$$8","k$$4","v$$1","matchValue$$4","msg","MutableMap$00602$$Remove$$2B595","this$$$10","k$$6","matchValue$$6","this$$$11","pairs$$3","pair$$3","item","Clear","Contains","item$$1","matchValue$$7","CopyTo","array","arrayIndex","i$$10","Remove","item$$2","this$$$18","matchValue$$8","delete","k$$7","k$$8","this$$$6","k$$2","matchValue$$2","MutableMap$00602$$get_Item$$2B595","k$$9","this$$$9","k$$5","matchValue$$5","MutableMap$00602$$ContainsKey$$2B595","pair$$5","k$$10","v$$2","this$$$7","k$$3","matchValue$$3","MutableMap$00602$$set_Item$$5BDDA1","pair$$6","MapTree$00602","MapTreeModule$$$size","MapTreeModule$$$sizeAux","$acc$$5","$m$$6","MapTreeModule$$$empty","MapTreeModule$$$height","_arg1","MapTreeModule$$$mk","l$$1","r$$1","hl","hr","MapTreeModule$$$rebalance","t1h","t2h","MapTreeModule$$$add","m$$3","Compare","c$$1","MapTreeModule$$$tryFind","$comparer$$2$$26","$k$$4$$27","$m$$5$$28","comparer$$2","m$$5","c$$5","MapTreeModule$$$ofSeq","comparer$$16","c$$9","ie","$comparer$$14$$97","$acc$$10$$98","$e$$99","comparer$$14","acc$$10","patternInput$$2","MapTreeModule$$$mkFromEnumerator","MapTreeModule$002EMapIterator$00602","started","MapTreeModule$$$collapseLHS","$stack$$111","MapTreeModule$$$mkIterator","s$$5","MapTreeModule$$$current","i$$2","MapTreeModule$$$alreadyFinished","MapTreeModule$$$notStarted","MapTreeModule$002EmkIEnumerator$0027$00602","s$$6","MapTreeModule$$$mkIEnumerator","s$$7","MapTreeModule$002EmkIEnumerator$0027$00602$$$$002Ector$$Z26BC498C","MapTreeModule$$$toSeq","s$$8","en$$1","i$$3","MapTreeModule$$$moveNext","Reset","FSharpMap","comparer$$17","tree","FSharpMap$$$$002Ector$$58ADD115","FSharpMap$$get_Tree","__$$5","FSharpMap$$get_Item$$2B595","__$$8","k$$29","$comparer$$1$$23","$k$$3$$24","$m$$4$$25","MapTreeModule$$$find","comparer$$1","m$$4","c$$3","FSharpMap$$Map$$Z6F6B671C","__$$18","f$$25","MapTreeModule$$$mapi","f$$11","m$$14","l2$$1","v2$$17","r2$$1","FSharpMap$$get_Count","__$$20","FSharpMap$$ContainsKey$$2B595","__$$21","k$$31","$comparer$$10$$59","$k$$12$$60","$m$$8$$61","MapTreeModule$$$mem","comparer$$10","k$$12","m$$8","c$$8","k$$37","v$$27","m$$24","k$$28","v$$24","__$$6","k$$39","m$$26","k$$33","__$$23","f$$35","m$$37","ofList","l$$22","comparer$$18","comparer$$13","l$$20","acc$$9","tupledArg","comparer$$21","strings","combineHash","x$$16","y$$3","res$$3","e$$1","activePatternResult3678","that","m$$22","res$$4","finished","e1","e2","kvp1","kvp2","c$$10","_arg1$$1","k$$34","k$$35","kv$$1","k$$36","v$$26","kv$$2","MutableSet$00601","items","MutableSet$00601$$Add$$2B595","MutableSet$00601$$TryFindIndex$$2B595","MutableSet$00601$$Clear","MutableSet$00601$$get_Count","MutableSet$00601$$Contains$$2B595","MutableSet$00601$$Remove$$2B595","values$$1","value$$2","i$$8","item$$3","add_","x$$1","SetTree$00601","SetTreeModule$$$SetOne","SetTreeModule$$$SetNode","SetTreeModule$$$height","SetTreeModule$$$mk","l$$2","r$$2","SetTreeModule$$$rebalance","SetTreeModule$$$add","t$$1","SetTreeModule$002ESetIterator$00601","SetTreeModule$$$collapseLHS","$stack$$104","SetTreeModule$$$mkIterator","s$$13","SetTreeModule$$$current","SetTreeModule$$$alreadyFinished","SetTreeModule$$$notStarted","SetTreeModule$002EmkIEnumerator$00601","s$$14","SetTreeModule$$$mkIEnumerator","s$$15","SetTreeModule$002EmkIEnumerator$00601$$$$002Ector$$Z5B395D56","SetTreeModule$$$compare","s1","s2","$comparer$$17$$112","$l1$$113","$l2$$114","SetTreeModule$$$compareStacks","l1","l2","$target$$115","t1$$6","t2$$6","n1k","n2k","t1$$7","t2$$7","n1k$$1","n2k$$1","n2r","t1$$8","t2$$8","emp","n1k$$2","n1r","n2k$$2","t1$$9","t2$$9","n1k$$3","n1r$$1","n2k$$3","n2r$$1","t1$$10","t2$$10","n1k$$4","t1$$11","n1k$$5","n1l","n1r$$2","t1$$12","n2k$$4","t2$$11","n2k$$5","n2l","n2r$$2","t2$$12","c$$7","SetTreeModule$$$ofSeq","comparer$$20","c$$11","$comparer$$19$$126","$acc$$11$$127","$e$$128","comparer$$19","acc$$11","SetTreeModule$$$mkFromEnumerator","i$$1","SetTreeModule$$$moveNext","FSharpSet","comparer$$22","FSharpSet$$$$002Ector$$2528C5CB","FSharpSet$$get_Comparer","__$$4","FSharpSet$$get_Tree","elements","comparer$$30","x$$21","that$$1","fill","target","targetIndex","f$$1","source$$1","cons$$2","len$$1","target$$2","i$$4","count$$8","initializer","cons$$15","result$$7","i$$13","folder$$4","state$$6","array$$78","delegateArg0$$2","delegateArg1$$2","f$$9","array1$$11","array2$$11","state$$17","folder$$12","array1$$10","array2$$10","state$$16","acc$$8","size$$1","i$$43","foldBackIndexed2","x$$22","y$$8","source$$7","cons$$32","BigNat","bound","BigNatModule$002EFFT$$$pow32","$x$$1","$n$$2","BigNatModule$002EFFT$$$maxTwoPower","Int32Array","BigNatModule$$$bound","n$$10","BigNatModule$$$coeff","n$$12","i$$5","BigNatModule$$$coeff64","n$$13","i$$6","BigNatModule$$$setCoeff","n$$14","i$$7","v$$4","BigNatModule$$$pow64","$x$$23$$48","$n$$15$$49","x$$23","n$$15","BigNatModule$$$pow32","$x$$24$$50","$n$$16$$51","x$$24","n$$16","BigNatModule$$$baseNi64","BigNatModule$$$baseMaski64","BigNatModule$$$createN","b$$4","BigNatModule$$$normN","n$$18","bound$$1","$na$$62","$i$$9$$63","na","i$$9","findLeastBound","BigNatModule$$$embed","x$$28","x$$29","r$$3","BigNatModule$$$boundInt","BigNatModule$$$one","BigNatModule$$$zero","BigNatModule$$$degree","n$$24","BigNatModule$$$isZero","p$$4","BigNatModule$$$equal","p$$7","q$$4","$pa$$96","$qa$$97","$i$$22$$98","pa","qa","i$$22","check","BigNatModule$$$compare","p$$9","q$$6","$pa$$2$$108","$qa$$2$$109","$i$$24$$110","pa$$2","qa$$2","i$$24","check$$2","BigNatModule$$$lt","p$$10","q$$7","BigNatModule$$$mulSchoolBookCarry","$r$$12$$130","$c$$8$$131","$k$$4$$132","r$$12","rak$$1","BigNatModule$$$mulSchoolBookOneSmall","p$$16","q$$12","value$$3","bp","r$$13","q$$13","i$$28","rak$$2","BigNatModule$$$mulSchoolBook","p$$18","q$$15","pSmall","qSmall","p$$15","q$$11","value$$1","r$$11","rak","BigNatModule$$$mulSchoolBookBothSmall","p$$17","q$$14","value$$4","r$$14","i$$29","pai$$1","j$$1","qaj","rak$$3","BigNatModule$$$mulSchoolBookNeitherSmall","BigNatModule$002Eencoding","bigL","twoToBigL","bigK","bigN","splits","BigNatModule$$$mkEncoding","bigK$$2","i$$30","BigNatModule$$$table","i$$32","i$$33","i$$34","BigNatModule$$$mul","p$$20","q$$17","BigNatModule$$$scaleSubInPlace","x$$57","a$$5","n$$30","patternInput$$3","j$$4","z$$7","zLo","value$$6","value$$5","zHi","BigNatModule$$$scaleAddInPlace","x$$62","f$$3","a$$8","n$$32","patternInput$$4","patternInput$$5","f$$4","j$$5","z$$8","zLo$$1","value$$8","value$$7","zHi$$1","BigNatModule$$$removeFactor","x$$67","a$$11","n$$34","patternInput$$6","f$$6","f64","f64$$1","pn","q$$5","qn","p$$8","$pa$$1$$103","$qa$$1$$104","$i$$23$$105","check$$1","pa$$1","qa$$1","i$$23","pai","qai","BigNatModule$$$divmod","b$$7","a$$12","x$$68","x$$27","array$$31","d$$6","p$$21","m$$2","n$$35","Invariant","f$$7","BigNatModule$$$ofInt32","n$$41","BigNatModule$$$ofInt64","n$$42","x$$30","x$$31","r$$4","i$$11","BigNatModule$$$boundInt64","BigNatModule$$$embed64","BigNatModule$$$toString","n$$45","degn","kten2ks","$prior$$227","$k$$11$$228","$ten2k$$229","prior","k$$11","ten2k","route","digits$$4","collect","isLeading","n$$46","patternInput$$13","digits$$2","n$$47","n$$19","i$$12","BigNatModule$$$eval32","arg00","BigNatModule$$$isSmall","n$$48","BigNatModule$$$getSmall","n$$49","BigInteger","signInt","BigInteger$$$$002Ector$$Z2BE94A1","BigInteger$$$nat$$Z67CCE57D","n$$1","smallLim","smallPosTab","BigInteger$$get_SignInt","BigInteger$$get_V","x$$2","BigInteger$$$op_Equality$$56F059C0","x$$3","BigInteger$$$op_LessThan$$56F059C0","x$$5","y$$2","BigInteger$$$$002Ector$$Z524259A4","n$$6","BigInteger$$$get_One","BigInteger$$$get_Two","two","BigInteger$$$get_Zero","zero","$_arg1$$4$$6","_arg1$$4","$f$$2$$19","$state$$1$$20","$xs$$8$$21","f$$2","state$$1","xs$$8","xs$$9","acc$$1","x$$6","xs$$12","acc$$3","x$$9","xs$$27","_arg1$$7","xs$$28","ys$$10","x$$15","f$$16","xs$$31","f$$24","xs$$46","unitVar0","xs$$50","res$$1","col","f$$42","xs$$71","acc$$17","x$$37","x$$7","n$$17","res$$2","obj$$1","n$$5","nn","DateTimeOffset","offsetMatch","signedRound","ms","ticks","ts","days","seconds","milliseconds","lengthLeft","lengthRight","padLeftAndRightWithZeros","firstDot","firstColon","genericMsg","newLine","errorToString","path","error","reason","decoder","clo1","string","arg0","sbyte","int16","uint16","uint32","datetime","_refValue","_err","datetimeOffset","timespan","decodeMaybeNull","badPathError","fieldNames","currentPath","option","field","fieldValue","isUndefined","at","firstPath","firstValue","curValue","requestedIndex","vArray","tokens","arr","succeed","_arg2","andThen","cb","ctor","d1","unwrapWith","errors","optional","optionalAt","toMap","mixedArray","decoders","arg10","arg30","clo2","clo3","state","extra","predicate$$13","find","fi","autoDecoder","autoDecodeRecordsAndUnions","isOptional","decoderRef","decoderInfos","folder$$8","state$$12","reduceRight","delegateArg0$$4","delegateArg1$$4","autoObject","enumType","source","byte","int","arg20","list","keyDecoder","valueDecoder","autoObject2","decoder1","decoder2","( arg10@ )","( arg20@ )","runner","ar","bool","unit","float","float32","guid","makeExtra","DecoderBuilder","expected","Bind","ReturnFrom","f$$44","xs$$74","acc$$18","x$$39","y$$10","errorMsg","_arg3","atVehicle","_arg4","_arg5","_arg6","_arg7","VehicleId","decodeRandomBattle","outcome","decodeBonusType","battle","generator","f1","f2","er","success","forLoopVar","space","encoder","defThunk","nil","autoEncodeRecordsAndUnions","skipNullField","encoderRef","setters","targetKey","encode","autoEncoder","patternInput","case_","fieldTypes","encoders","Value","keyType","valueEncoder","activePatternResult2739","keyEncoder","clo4","arg40","activePatternResult2743","PromiseBuilder","dataResolver","resolver","response","responseResolver","eitherUnitOr","ResolveType","text","url","httpMethod","properties","headers","pr","body","withBody","custom","list2","withProperties","init","resolve","exn","tryFetchAs","fetchExpectedValuesMap","decodeExpectedValuesMap","fetchAs","method","payload","payloadDecoder","request","encodeRequest","CancellationToken","cancelled","_id","_cancelled","_listeners","listener","$","addListener","removeListener","OperationCanceledError","setPrototypeOf","protectedCont","ctx","cancelToken","isCancelled","onCancel","trampoline","incrementAndCheck","hijack","err","onError","protectedBind","computation","binder","onSuccess","ex","protectedReturn","computation1","computation2","sequence","While","Delay","compensation","catchHandler","ex2","resource","TryFinally","guard","Return","console","dispatch","cmd","cmds","lists","state$$3","xs$$14","acc$$4","x$$10","ClassNames","classes","OptionBuilder","threshold","winRateColorClasses","winRate","( |Below|_| )","formatWinRate","wn8ColorClasses","formatWn8","wn8","rix'","wix'","ix","source$$6","wix","setState","program","rb","reentered","syncDispatch","nextMsg","props","equal","view","lazyView2With","placeholderId","lastRequest","model","document","getElementById","nextProps","_nextState","connectToServer","battleResultsOffset","ws","onProtocolError","close","responseDecoder","BattleResults","ExpectedValues","task","ofSuccess","ofError","viewStatusBar","children","viewButton","label","action","viewWinRateWidget","randomBattles","battles","calculateWinRate","winRateText","viewWn8Widget","expectedValuesMap","totalDmg","totalSpot","totalFrag","totalDef","totalWin","expDmg","expSpot","expFrag","expDef","expWin","expectedValues","rDAMAGE","rSPOT","rFRAG","rDEF","normalizeValue","rSTAT","constant","rWINc","rDAMAGEc","rFRAGc","calculateWn8","wn8Text","update","withReactBatchedUsing","runWith"],"mappings":"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","file":"main.de185acf5a819723ec0f.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/wot-session-dashboard/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([1,1]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","// tslint:disable:ban-types\nexport function bindThis(this$, source) {\n    for (const key of Object.keys(source)) {\n        if (typeof source[key] === \"function\") {\n            source[key] = source[key].bind(this$);\n        }\n    }\n    return source;\n}\n// Object.assign flattens getters and setters\n// See https://stackoverflow.com/questions/37054596/js-es5-how-to-assign-objects-with-setters-and-getters\nexport function extend(target, ...sources) {\n    for (const source of sources) {\n        for (const key of Object.keys(source)) {\n            const descr = Object.getOwnPropertyDescriptor(source, key);\n            if (descr) {\n                Object.defineProperty(target, key, descr);\n            }\n        }\n    }\n    return target;\n}\nexport function isIterable(x) {\n    return x != null && typeof x === \"object\" && Symbol.iterator in x;\n}\nexport function isArrayLike(x) {\n    return x != null && (Array.isArray(x) || ArrayBuffer.isView(x));\n}\nexport function isComparer(x) {\n    return x != null && typeof x.Compare === \"function\";\n}\nexport function isComparable(x) {\n    return x != null && typeof x.CompareTo === \"function\";\n}\nexport function isEquatable(x) {\n    return x != null && typeof x.Equals === \"function\";\n}\nexport function isHashable(x) {\n    return x != null && typeof x.GetHashCode === \"function\";\n}\nexport function isDisposable(x) {\n    return x != null && typeof x.Dispose === \"function\";\n}\nexport class Comparer {\n    constructor(f) {\n        this.Compare = f || compare;\n    }\n}\nexport function comparerFromEqualityComparer(comparer) {\n    // Sometimes IEqualityComparer also implements IComparer\n    if (isComparer(comparer)) {\n        return new Comparer(comparer.Compare);\n    }\n    else {\n        return new Comparer((x, y) => {\n            const xhash = comparer.GetHashCode(x);\n            const yhash = comparer.GetHashCode(y);\n            if (xhash === yhash) {\n                return comparer.Equals(x, y) ? 0 : -1;\n            }\n            else {\n                return xhash < yhash ? -1 : 1;\n            }\n        });\n    }\n}\n// TODO: Move these three methods to Map and Set modules\nexport function containsValue(v, map) {\n    for (const kv of map) {\n        if (equals(v, kv[1])) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function tryGetValue(map, key, defaultValue) {\n    return map.has(key) ? [true, map.get(key)] : [false, defaultValue];\n}\nexport function addToSet(v, set) {\n    if (set.has(v)) {\n        return false;\n    }\n    set.add(v);\n    return true;\n}\nexport function assertEqual(actual, expected, msg) {\n    if (!equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport function assertNotEqual(actual, expected, msg) {\n    if (equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport class Lazy {\n    constructor(factory) {\n        this.factory = factory;\n        this.isValueCreated = false;\n    }\n    get Value() {\n        if (!this.isValueCreated) {\n            this.createdValue = this.factory();\n            this.isValueCreated = true;\n        }\n        return this.createdValue;\n    }\n    get IsValueCreated() {\n        return this.isValueCreated;\n    }\n}\nexport function lazyFromValue(v) {\n    return new Lazy(() => v);\n}\nexport function padWithZeros(i, length) {\n    let str = i.toString(10);\n    while (str.length < length) {\n        str = \"0\" + str;\n    }\n    return str;\n}\nexport function padLeftAndRightWithZeros(i, lengthLeft, lengthRight) {\n    let str = i.toString(10);\n    while (str.length < lengthLeft) {\n        str = \"0\" + str;\n    }\n    while (str.length < lengthRight) {\n        str = str + \"0\";\n    }\n    return str;\n}\nexport function dateOffset(date) {\n    const date1 = date;\n    return typeof date1.offset === \"number\"\n        ? date1.offset\n        : (date.kind === 1 /* UTC */\n            ? 0 : date.getTimezoneOffset() * -60000);\n}\nexport function int16ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport function int32ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFFFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport class ObjectRef {\n    static id(o) {\n        if (!ObjectRef.idMap.has(o)) {\n            ObjectRef.idMap.set(o, ++ObjectRef.count);\n        }\n        return ObjectRef.idMap.get(o);\n    }\n}\nObjectRef.idMap = new WeakMap();\nObjectRef.count = 0;\nexport function stringHash(s) {\n    let i = 0;\n    let h = 5381;\n    const len = s.length;\n    while (i < len) {\n        h = (h * 33) ^ s.charCodeAt(i++);\n    }\n    return h;\n}\nexport function numberHash(x) {\n    return x * 2654435761 | 0;\n}\n// From https://stackoverflow.com/a/37449594\nexport function combineHashCodes(hashes) {\n    if (hashes.length === 0) {\n        return 0;\n    }\n    return hashes.reduce((h1, h2) => {\n        return ((h1 << 5) + h1) ^ h2;\n    });\n}\nexport function identityHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"string\":\n            return stringHash(x);\n        default:\n            return numberHash(ObjectRef.id(x));\n    }\n}\nexport function structuralHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"string\":\n            return stringHash(x);\n        default: {\n            if (isHashable(x)) {\n                return x.GetHashCode();\n            }\n            else if (isArrayLike(x)) {\n                const len = x.length;\n                const hashes = new Array(len);\n                for (let i = 0; i < len; i++) {\n                    hashes[i] = structuralHash(x[i]);\n                }\n                return combineHashCodes(hashes);\n            }\n            else {\n                return stringHash(String(x));\n            }\n        }\n    }\n}\nexport function equalArraysWith(x, y, eq) {\n    if (x == null) {\n        return y == null;\n    }\n    if (y == null) {\n        return false;\n    }\n    if (x.length !== y.length) {\n        return false;\n    }\n    for (let i = 0; i < x.length; i++) {\n        if (!eq(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function equalArrays(x, y) {\n    return equalArraysWith(x, y, equals);\n}\n// export function equalObjects(x: { [k: string]: any }, y: { [k: string]: any }): boolean {\n//   if (x == null) { return y == null; }\n//   if (y == null) { return false; }\n//   const xKeys = Object.keys(x);\n//   const yKeys = Object.keys(y);\n//   if (xKeys.length !== yKeys.length) {\n//     return false;\n//   }\n//   xKeys.sort();\n//   yKeys.sort();\n//   for (let i = 0; i < xKeys.length; i++) {\n//     if (xKeys[i] !== yKeys[i] || !equals(x[xKeys[i]], y[yKeys[i]])) {\n//       return false;\n//     }\n//   }\n//   return true;\n// }\nexport function equals(x, y) {\n    if (x === y) {\n        return true;\n    }\n    else if (x == null) {\n        return y == null;\n    }\n    else if (y == null) {\n        return false;\n    }\n    else if (typeof x !== \"object\") {\n        return false;\n    }\n    else if (isEquatable(x)) {\n        return x.Equals(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) && equalArrays(x, y);\n    }\n    else if (x instanceof Date) {\n        return (y instanceof Date) && compareDates(x, y) === 0;\n    }\n    else {\n        return false;\n    }\n}\nexport function compareDates(x, y) {\n    let xtime;\n    let ytime;\n    // DateTimeOffset and DateTime deals with equality differently.\n    if (\"offset\" in x && \"offset\" in y) {\n        xtime = x.getTime();\n        ytime = y.getTime();\n    }\n    else {\n        xtime = x.getTime() + dateOffset(x);\n        ytime = y.getTime() + dateOffset(y);\n    }\n    return xtime === ytime ? 0 : (xtime < ytime ? -1 : 1);\n}\nexport function comparePrimitives(x, y) {\n    return x === y ? 0 : (x < y ? -1 : 1);\n}\nexport function compareArraysWith(x, y, comp) {\n    if (x == null) {\n        return y == null ? 0 : 1;\n    }\n    if (y == null) {\n        return -1;\n    }\n    if (x.length !== y.length) {\n        return x.length < y.length ? -1 : 1;\n    }\n    for (let i = 0, j = 0; i < x.length; i++) {\n        j = comp(x[i], y[i]);\n        if (j !== 0) {\n            return j;\n        }\n    }\n    return 0;\n}\nexport function compareArrays(x, y) {\n    return compareArraysWith(x, y, compare);\n}\nexport function compareObjects(x, y) {\n    if (x == null) {\n        return y == null ? 0 : 1;\n    }\n    if (y == null) {\n        return -1;\n    }\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return xKeys.length < yKeys.length ? -1 : 1;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0, j = 0; i < xKeys.length; i++) {\n        const key = xKeys[i];\n        if (key !== yKeys[i]) {\n            return key < yKeys[i] ? -1 : 1;\n        }\n        else {\n            j = compare(x[key], y[key]);\n            if (j !== 0) {\n                return j;\n            }\n        }\n    }\n    return 0;\n}\nexport function compare(x, y) {\n    if (x === y) {\n        return 0;\n    }\n    else if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    else if (y == null) {\n        return 1;\n    }\n    else if (typeof x !== \"object\") {\n        return x < y ? -1 : 1;\n    }\n    else if (isComparable(x)) {\n        return x.CompareTo(y);\n    }\n    else if (isArrayLike(x) && isArrayLike(y)) {\n        return compareArrays(x, y);\n    }\n    else if (x instanceof Date && y instanceof Date) {\n        return compareDates(x, y);\n    }\n    else {\n        return 1;\n    }\n}\nexport function min(comparer, x, y) {\n    return comparer(x, y) < 0 ? x : y;\n}\nexport function max(comparer, x, y) {\n    return comparer(x, y) > 0 ? x : y;\n}\nexport function createAtom(value) {\n    let atom = value;\n    return (value) => {\n        if (value === void 0) {\n            return atom;\n        }\n        else {\n            atom = value;\n            return void 0;\n        }\n    };\n}\nconst CaseRules = {\n    None: 0,\n    LowerFirst: 1,\n    SnakeCase: 2,\n    SnakeCaseAllCaps: 3,\n    KebabCase: 4,\n};\nfunction dashify(str, separator) {\n    return str.replace(/[a-z]?[A-Z]/g, (m) => m.length === 1\n        ? m.toLowerCase()\n        : m.charAt(0) + separator + m.charAt(1).toLowerCase());\n}\nfunction changeCase(str, caseRule) {\n    switch (caseRule) {\n        case CaseRules.LowerFirst:\n            return str.charAt(0).toLowerCase() + str.slice(1);\n        case CaseRules.SnakeCase:\n            return dashify(str, \"_\");\n        case CaseRules.SnakeCaseAllCaps:\n            return dashify(str, \"_\").toUpperCase();\n        case CaseRules.KebabCase:\n            return dashify(str, \"-\");\n        case CaseRules.None:\n        default:\n            return str;\n    }\n}\nexport function createObj(fields, caseRule = CaseRules.None) {\n    function fail(kvPair) {\n        throw new Error(\"Cannot infer key and value of \" + String(kvPair));\n    }\n    const o = {};\n    const definedCaseRule = caseRule;\n    for (let kvPair of fields) {\n        let caseRule = CaseRules.None;\n        if (kvPair == null) {\n            fail(kvPair);\n        }\n        // Deflate unions and use the defined case rule\n        if (typeof kvPair.toJSON === \"function\") {\n            kvPair = kvPair.toJSON();\n            caseRule = definedCaseRule;\n        }\n        if (Array.isArray(kvPair)) {\n            switch (kvPair.length) {\n                case 0:\n                    fail(kvPair);\n                    break;\n                case 1:\n                    o[changeCase(kvPair[0], caseRule)] = true;\n                    break;\n                case 2:\n                    const value = kvPair[1];\n                    o[changeCase(kvPair[0], caseRule)] = value;\n                    break;\n                default:\n                    o[changeCase(kvPair[0], caseRule)] = kvPair.slice(1);\n            }\n        }\n        else if (typeof kvPair === \"string\") {\n            o[changeCase(kvPair, caseRule)] = true;\n        }\n        else {\n            fail(kvPair);\n        }\n    }\n    return o;\n}\nexport function jsOptions(mutator) {\n    const opts = {};\n    mutator(opts);\n    return opts;\n}\nexport function round(value, digits = 0) {\n    const m = Math.pow(10, digits);\n    const n = +(digits ? value * m : value).toFixed(8);\n    const i = Math.floor(n);\n    const f = n - i;\n    const e = 1e-8;\n    const r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 === 0) ? i : i + 1) : Math.round(n);\n    return digits ? r / m : r;\n}\nexport function sign(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n}\nexport function randomNext(min, max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n}\nexport function randomBytes(buffer) {\n    if (buffer == null) {\n        throw new Error(\"Buffer cannot be null\");\n    }\n    for (let i = 0; i < buffer.length; i += 6) {\n        // Pick random 48-bit number. Fill buffer in 2 24-bit chunks to avoid bitwise truncation.\n        let r = Math.floor(Math.random() * 281474976710656); // Low 24 bits = chunk 1.\n        const rhi = Math.floor(r / 16777216); // High 24 bits shifted via division = chunk 2.\n        for (let j = 0; j < 6 && i + j < buffer.length; j++) {\n            if (j === 3) {\n                r = rhi;\n            }\n            buffer[i + j] = r & 255;\n            r >>>= 8;\n        }\n    }\n}\nexport function unescapeDataString(s) {\n    // https://stackoverflow.com/a/4458580/524236\n    return decodeURIComponent((s).replace(/\\+/g, \"%20\"));\n}\nexport function escapeDataString(s) {\n    return encodeURIComponent(s).replace(/!/g, \"%21\")\n        .replace(/'/g, \"%27\")\n        .replace(/\\(/g, \"%28\")\n        .replace(/\\)/g, \"%29\")\n        .replace(/\\*/g, \"%2A\");\n}\nexport function escapeUriString(s) {\n    return encodeURI(s);\n}\n// ICollection.Clear and Count members can be called on Arrays\n// or Dictionaries so we need a runtime check (see #1120)\nexport function count(col) {\n    if (isArrayLike(col)) {\n        return col.length;\n    }\n    else {\n        let count = 0;\n        for (const _ of col) {\n            count++;\n        }\n        return count;\n    }\n}\nexport function clear(col) {\n    if (isArrayLike(col)) {\n        col.splice(0);\n    }\n    else {\n        col.clear();\n    }\n}\nconst CURRIED_KEY = \"__CURRIED__\";\nexport function uncurry(arity, f) {\n    // f may be a function option with None value\n    if (f == null) {\n        return undefined;\n    }\n    // The function is already uncurried\n    if (f.length > 1) {\n        // if (CURRIED_KEY in f) { // This doesn't always work\n        return f;\n    }\n    let uncurriedFn;\n    switch (arity) {\n        case 2:\n            uncurriedFn = (a1, a2) => f(a1)(a2);\n            break;\n        case 3:\n            uncurriedFn = (a1, a2, a3) => f(a1)(a2)(a3);\n            break;\n        case 4:\n            uncurriedFn = (a1, a2, a3, a4) => f(a1)(a2)(a3)(a4);\n            break;\n        case 5:\n            uncurriedFn = (a1, a2, a3, a4, a5) => f(a1)(a2)(a3)(a4)(a5);\n            break;\n        case 6:\n            uncurriedFn = (a1, a2, a3, a4, a5, a6) => f(a1)(a2)(a3)(a4)(a5)(a6);\n            break;\n        case 7:\n            uncurriedFn = (a1, a2, a3, a4, a5, a6, a7) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7);\n            break;\n        case 8:\n            uncurriedFn = (a1, a2, a3, a4, a5, a6, a7, a8) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8);\n            break;\n        default:\n            throw new Error(\"Uncurrying to more than 8-arity is not supported: \" + arity);\n    }\n    uncurriedFn[CURRIED_KEY] = f;\n    return uncurriedFn;\n}\nexport function curry(arity, f) {\n    if (f == null) {\n        return undefined;\n    }\n    if (CURRIED_KEY in f) {\n        return f[CURRIED_KEY];\n    }\n    switch (arity) {\n        case 2:\n            return (a1) => (a2) => f(a1, a2);\n        case 3:\n            return (a1) => (a2) => (a3) => f(a1, a2, a3);\n        case 4:\n            return (a1) => (a2) => (a3) => (a4) => f(a1, a2, a3, a4);\n        case 5:\n            return (a1) => (a2) => (a3) => (a4) => (a5) => f(a1, a2, a3, a4, a5);\n        case 6:\n            return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => f(a1, a2, a3, a4, a5, a6);\n        case 7:\n            return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => f(a1, a2, a3, a4, a5, a6, a7);\n        case 8:\n            return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => f(a1, a2, a3, a4, a5, a6, a7, a8);\n        default:\n            throw new Error(\"Currying to more than 8-arity is not supported: \" + arity);\n    }\n}\nexport function partialApply(arity, f, args) {\n    if (f == null) {\n        return undefined;\n    }\n    else if (CURRIED_KEY in f) {\n        f = f[CURRIED_KEY];\n        for (let i = 0; i < args.length; i++) {\n            f = f(args[i]);\n        }\n        return f;\n    }\n    else {\n        switch (arity) {\n            case 1:\n                // Wrap arguments to make sure .concat doesn't destruct arrays. Example\n                // [1,2].concat([3,4],5)   --> [1,2,3,4,5]    // fails\n                // [1,2].concat([[3,4],5]) --> [1,2,[3,4],5]  // ok\n                return (a1) => f.apply(undefined, args.concat([a1]));\n            case 2:\n                return (a1) => (a2) => f.apply(undefined, args.concat([a1, a2]));\n            case 3:\n                return (a1) => (a2) => (a3) => f.apply(undefined, args.concat([a1, a2, a3]));\n            case 4:\n                return (a1) => (a2) => (a3) => (a4) => f.apply(undefined, args.concat([a1, a2, a3, a4]));\n            case 5:\n                return (a1) => (a2) => (a3) => (a4) => (a5) => f.apply(undefined, args.concat([a1, a2, a3, a4, a5]));\n            case 6:\n                return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => f.apply(undefined, args.concat([a1, a2, a3, a4, a5, a6]));\n            case 7:\n                return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => f.apply(undefined, args.concat([a1, a2, a3, a4, a5, a6, a7]));\n            case 8:\n                return (a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => f.apply(undefined, args.concat([a1, a2, a3, a4, a5, a6, a7, a8]));\n            default:\n                throw new Error(\"Partially applying to more than 8-arity is not supported: \" + arity);\n        }\n    }\n}\nexport function mapCurriedArgs(fn, mappings) {\n    function mapArg(fn, arg, mappings, idx) {\n        const mapping = mappings[idx];\n        if (mapping !== 0) {\n            const expectedArity = mapping[0];\n            const actualArity = mapping[1];\n            if (expectedArity > 1) {\n                arg = curry(expectedArity, arg);\n            }\n            if (actualArity > 1) {\n                arg = uncurry(actualArity, arg);\n            }\n        }\n        const res = fn(arg);\n        if (idx + 1 === mappings.length) {\n            return res;\n        }\n        else {\n            return (arg) => mapArg(res, arg, mappings, idx + 1);\n        }\n    }\n    return (arg) => mapArg(fn, arg, mappings, 0);\n}\nexport function addToDict(dict, k, v) {\n    if (dict.has(k)) {\n        throw new Error(\"An item with the same key has already been added. Key: \" + k);\n    }\n    dict.set(k, v);\n}\nexport function getItemFromDict(map, key) {\n    if (map.has(key)) {\n        return map.get(key);\n    }\n    else {\n        throw new Error(`The given key '${key}' was not present in the dictionary.`);\n    }\n}\n//# sourceMappingURL=Util.js.map","// tslint:disable: space-before-function-paren\nimport { combineHashCodes, compare, compareArrays, equalArrays, equals, identityHash, numberHash, structuralHash } from \"./Util\";\nfunction sameType(x, y) {\n    return y != null && Object.getPrototypeOf(x).constructor === Object.getPrototypeOf(y).constructor;\n}\n// Taken from Babel helpers\nfunction inherits(subClass, superClass) {\n    // if (typeof superClass !== \"function\" && superClass !== null) {\n    //   throw new TypeError(\n    //     \"Super expression must either be null or a function, not \" +\n    //       typeof superClass\n    //   );\n    // }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true,\n        },\n    });\n    // if (superClass)\n    //   Object.setPrototypeOf\n    //     ? Object.setPrototypeOf(subClass, superClass)\n    //     : (subClass.__proto__ = superClass);\n}\nexport function declare(cons, superClass) {\n    inherits(cons, superClass || SystemObject);\n    return cons;\n}\nexport class SystemObject {\n    toString() {\n        return \"{\" + Object.entries(this).map(([k, v]) => k + \" = \" + String(v)).join(\";\\n \") + \"}\";\n    }\n    GetHashCode() {\n        return identityHash(this);\n    }\n    Equals(other) {\n        return this === other;\n    }\n}\nfunction compareList(self, other) {\n    if (self === other) {\n        return 0;\n    }\n    else {\n        if (other == null) {\n            return -1;\n        }\n        while (self.tail != null) {\n            if (other.tail == null) {\n                return 1;\n            }\n            const res = compare(self.head, other.head);\n            if (res !== 0) {\n                return res;\n            }\n            self = self.tail;\n            other = other.tail;\n        }\n        return other.tail == null ? 0 : -1;\n    }\n}\nexport class List {\n    constructor(head, tail) {\n        this.head = head;\n        this.tail = tail;\n    }\n    toString() {\n        return \"[\" + Array.from(this).join(\"; \") + \"]\";\n    }\n    toJSON() {\n        return Array.from(this);\n    }\n    [Symbol.iterator]() {\n        let cur = this;\n        return {\n            next: () => {\n                const value = cur === null || cur === void 0 ? void 0 : cur.head;\n                const done = (cur === null || cur === void 0 ? void 0 : cur.tail) == null;\n                cur = cur === null || cur === void 0 ? void 0 : cur.tail;\n                return { done, value };\n            },\n        };\n    }\n    GetHashCode() {\n        const hashes = Array.from(this).map(structuralHash);\n        return combineHashCodes(hashes);\n    }\n    Equals(other) {\n        return compareList(this, other) === 0;\n    }\n    CompareTo(other) {\n        return compareList(this, other);\n    }\n}\nexport class Union extends SystemObject {\n    constructor(tag, name, ...fields) {\n        super();\n        this.tag = tag | 0;\n        this.name = name;\n        this.fields = fields;\n    }\n    toString() {\n        const len = this.fields.length;\n        if (len === 0) {\n            return this.name;\n        }\n        else if (len === 1) {\n            return this.name + \" \" + String(this.fields[0]);\n        }\n        else {\n            return this.name + \" (\" + this.fields.map((x) => String(x)).join(\",\") + \")\";\n        }\n    }\n    toJSON() {\n        return this.fields.length === 0\n            ? this.name\n            : [this.name].concat(this.fields);\n    }\n    GetHashCode() {\n        const hashes = this.fields.map((x) => structuralHash(x));\n        hashes.splice(0, 0, numberHash(this.tag));\n        return combineHashCodes(hashes);\n    }\n    Equals(other) {\n        return this === other\n            || (sameType(this, other)\n                && this.tag === other.tag\n                && equalArrays(this.fields, other.fields));\n    }\n    CompareTo(other) {\n        if (this === other) {\n            return 0;\n        }\n        else if (!sameType(this, other)) {\n            return -1;\n        }\n        else if (this.tag === other.tag) {\n            return compareArrays(this.fields, other.fields);\n        }\n        else {\n            return this.tag < other.tag ? -1 : 1;\n        }\n    }\n}\nfunction recordToJson(record, getFieldNames) {\n    const o = {};\n    const keys = getFieldNames == null ? Object.keys(record) : getFieldNames(record);\n    for (let i = 0; i < keys.length; i++) {\n        o[keys[i]] = record[keys[i]];\n    }\n    return o;\n}\nfunction recordEquals(self, other, getFieldNames) {\n    if (self === other) {\n        return true;\n    }\n    else if (!sameType(self, other)) {\n        return false;\n    }\n    else {\n        const thisNames = getFieldNames == null ? Object.keys(self) : getFieldNames(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            if (!equals(self[thisNames[i]], other[thisNames[i]])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfunction recordCompare(self, other, getFieldNames) {\n    if (self === other) {\n        return 0;\n    }\n    else if (!sameType(self, other)) {\n        return -1;\n    }\n    else {\n        const thisNames = getFieldNames == null ? Object.keys(self) : getFieldNames(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            const result = compare(self[thisNames[i]], other[thisNames[i]]);\n            if (result !== 0) {\n                return result;\n            }\n        }\n        return 0;\n    }\n}\nexport class Record extends SystemObject {\n    toString() {\n        return \"{\" + Object.entries(this).map(([k, v]) => k + \" = \" + String(v)).join(\";\\n \") + \"}\";\n    }\n    toJSON() {\n        return recordToJson(this);\n    }\n    GetHashCode() {\n        const hashes = Object.values(this).map((v) => structuralHash(v));\n        return combineHashCodes(hashes);\n    }\n    Equals(other) {\n        return recordEquals(this, other);\n    }\n    CompareTo(other) {\n        return recordCompare(this, other);\n    }\n}\nexport function anonRecord(o) {\n    return Object.assign(Object.create(Record.prototype), o);\n}\nexport class FSharpRef extends Record {\n    constructor(contents) {\n        super();\n        this.contents = contents;\n    }\n}\nexport const Exception = declare(function Exception(message) {\n    this.stack = Error().stack;\n    this.message = message;\n}, SystemObject);\nexport function isException(x) {\n    return x instanceof Error || x instanceof Exception;\n}\nfunction getFSharpExceptionFieldNames(self) {\n    return Object.keys(self).filter((k) => k !== \"message\" && k !== \"stack\");\n}\nexport class FSharpException extends Exception {\n    toString() {\n        var _a;\n        // const fieldNames = getFSharpExceptionFieldNames(this);\n        const fields = Object.entries(this).filter(([k, _]) => k !== \"message\" && k !== \"stack\");\n        const len = fields.length;\n        if (len === 0) {\n            return (_a = this.message) !== null && _a !== void 0 ? _a : \"\";\n        }\n        else if (len === 1) {\n            return this.message + \" \" + String(fields[1]);\n        }\n        else {\n            return this.message + \" (\" + fields.map(([_, v]) => String(v)).join(\",\") + \")\";\n        }\n    }\n    toJSON() {\n        return recordToJson(this, getFSharpExceptionFieldNames);\n    }\n    GetHashCode() {\n        const fields = Object.entries(this).filter(([k, _]) => k !== \"message\" && k !== \"stack\");\n        const hashes = fields.map(([_, v]) => structuralHash(v));\n        return combineHashCodes(hashes);\n    }\n    Equals(other) {\n        return recordEquals(this, other, getFSharpExceptionFieldNames);\n    }\n    CompareTo(other) {\n        return recordCompare(this, other, getFSharpExceptionFieldNames);\n    }\n}\nexport class MatchFailureException extends FSharpException {\n    constructor(arg1, arg2, arg3) {\n        super();\n        this.arg1 = arg1;\n        this.arg2 = arg2 | 0;\n        this.arg3 = arg3 | 0;\n        this.message = \"The match cases were incomplete\";\n    }\n}\nexport const Attribute = declare(function Attribute() { return; }, SystemObject);\n//# sourceMappingURL=Types.js.map","import { anonRecord as makeAnonRecord, Record, Union } from \"./Types\";\nimport { compareArraysWith, equalArraysWith } from \"./Util\";\nexport class CaseInfo {\n    constructor(declaringType, tag, name, fields) {\n        this.declaringType = declaringType;\n        this.tag = tag;\n        this.name = name;\n        this.fields = fields;\n    }\n}\nexport class TypeInfo {\n    constructor(fullname, generics, construct, fields, cases, enumCases) {\n        this.fullname = fullname;\n        this.generics = generics;\n        this.construct = construct;\n        this.fields = fields;\n        this.cases = cases;\n        this.enumCases = enumCases;\n    }\n    toString() {\n        return fullName(this);\n    }\n    Equals(other) {\n        return equals(this, other);\n    }\n    CompareTo(other) {\n        return compare(this, other);\n    }\n}\nexport function getGenerics(t) {\n    return t.generics != null ? t.generics : [];\n}\nexport function equals(t1, t2) {\n    if (t1.fullname === \"\") { // Anonymous records\n        return t2.fullname === \"\"\n            && equalArraysWith(getRecordElements(t1), getRecordElements(t2), ([k1, v1], [k2, v2]) => k1 === k2 && equals(v1, v2));\n    }\n    else {\n        return t1.fullname === t2.fullname\n            && equalArraysWith(getGenerics(t1), getGenerics(t2), equals);\n    }\n}\n// System.Type is not comparable in .NET, but let's implement this\n// in case users want to create a dictionary with types as keys\nexport function compare(t1, t2) {\n    if (t1.fullname !== t2.fullname) {\n        return t1.fullname < t2.fullname ? -1 : 1;\n    }\n    else {\n        return compareArraysWith(getGenerics(t1), getGenerics(t2), compare);\n    }\n}\nexport function class_type(fullname, generics, construct) {\n    return new TypeInfo(fullname, generics, construct);\n}\nexport function record_type(fullname, generics, construct, fields) {\n    return new TypeInfo(fullname, generics, construct, fields);\n}\nexport function anonRecord_type(...fields) {\n    return new TypeInfo(\"\", undefined, undefined, () => fields);\n}\nexport function union_type(fullname, generics, construct, cases) {\n    const t = new TypeInfo(fullname, generics, construct, undefined, () => cases().map((x, i) => typeof x === \"string\"\n        ? new CaseInfo(t, i, x)\n        : new CaseInfo(t, i, x[0], x[1])));\n    return t;\n}\nexport function tuple_type(...generics) {\n    return new TypeInfo(\"System.Tuple`\" + generics.length, generics);\n}\nexport function delegate_type(...generics) {\n    return new TypeInfo(\"System.Func`\" + generics.length, generics);\n}\nexport function lambda_type(argType, returnType) {\n    return new TypeInfo(\"Microsoft.FSharp.Core.FSharpFunc`2\", [argType, returnType]);\n}\nexport function option_type(generic) {\n    return new TypeInfo(\"Microsoft.FSharp.Core.FSharpOption`1\", [generic]);\n}\nexport function list_type(generic) {\n    return new TypeInfo(\"Microsoft.FSharp.Collections.FSharpList`1\", [generic]);\n}\nexport function array_type(generic) {\n    return new TypeInfo(generic.fullname + \"[]\", [generic]);\n}\nexport function enum_type(fullname, underlyingType, enumCases) {\n    return new TypeInfo(fullname, [underlyingType], undefined, undefined, undefined, enumCases);\n}\nexport const obj_type = new TypeInfo(\"System.Object\");\nexport const unit_type = new TypeInfo(\"Microsoft.FSharp.Core.Unit\");\nexport const char_type = new TypeInfo(\"System.Char\");\nexport const string_type = new TypeInfo(\"System.String\");\nexport const bool_type = new TypeInfo(\"System.Boolean\");\nexport const int8_type = new TypeInfo(\"System.SByte\");\nexport const uint8_type = new TypeInfo(\"System.Byte\");\nexport const int16_type = new TypeInfo(\"System.Int16\");\nexport const uint16_type = new TypeInfo(\"System.UInt16\");\nexport const int32_type = new TypeInfo(\"System.Int32\");\nexport const uint32_type = new TypeInfo(\"System.UInt32\");\nexport const float32_type = new TypeInfo(\"System.Single\");\nexport const float64_type = new TypeInfo(\"System.Double\");\nexport const decimal_type = new TypeInfo(\"System.Decimal\");\nexport function name(info) {\n    if (Array.isArray(info)) {\n        return info[0];\n    }\n    else if (info instanceof CaseInfo) {\n        return info.name;\n    }\n    else {\n        const i = info.fullname.lastIndexOf(\".\");\n        return i === -1 ? info.fullname : info.fullname.substr(i + 1);\n    }\n}\nexport function fullName(t) {\n    const gen = t.generics != null && !isArray(t) ? t.generics : [];\n    if (gen.length > 0) {\n        return t.fullname + \"[\" + gen.map((x) => fullName(x)).join(\",\") + \"]\";\n    }\n    else {\n        return t.fullname;\n    }\n}\nexport function namespace(t) {\n    const i = t.fullname.lastIndexOf(\".\");\n    return i === -1 ? \"\" : t.fullname.substr(0, i);\n}\nexport function isArray(t) {\n    return t.fullname.endsWith(\"[]\");\n}\nexport function getElementType(t) {\n    var _a;\n    return isArray(t) ? (_a = t.generics) === null || _a === void 0 ? void 0 : _a[0] : undefined;\n}\nexport function isGenericType(t) {\n    return t.generics != null && t.generics.length > 0;\n}\nexport function isEnum(t) {\n    return t.enumCases != null && t.enumCases.length > 0;\n}\n/**\n * This doesn't replace types for fields (records) or cases (unions)\n * but it should be enough for type comparison purposes\n */\nexport function getGenericTypeDefinition(t) {\n    return t.generics == null ? t : new TypeInfo(t.fullname, t.generics.map(() => obj_type));\n}\nexport function getEnumUnderlyingType(t) {\n    var _a;\n    return (_a = t.generics) === null || _a === void 0 ? void 0 : _a[0];\n}\nexport function getEnumValues(t) {\n    if (isEnum(t) && t.enumCases != null) {\n        return t.enumCases.map((kv) => kv[1]);\n    }\n    else {\n        throw new Error(`${t.fullname} is not an enum type`);\n    }\n}\nexport function getEnumNames(t) {\n    if (isEnum(t) && t.enumCases != null) {\n        return t.enumCases.map((kv) => kv[0]);\n    }\n    else {\n        throw new Error(`${t.fullname} is not an enum type`);\n    }\n}\nfunction getEnumCase(t, v) {\n    if (t.enumCases != null) {\n        if (typeof v === \"string\") {\n            for (const kv of t.enumCases) {\n                if (kv[0] === v) {\n                    return kv;\n                }\n            }\n            throw new Error(`'${v}' was not found in ${t.fullname}`);\n        }\n        else {\n            for (const kv of t.enumCases) {\n                if (kv[1] === v) {\n                    return kv;\n                }\n            }\n            // .NET returns the number even if it doesn't match any of the cases\n            return [\"\", v];\n        }\n    }\n    else {\n        throw new Error(`${t.fullname} is not an enum type`);\n    }\n}\nexport function parseEnum(t, str) {\n    // TODO: better int parsing here, parseInt ceils floats: \"4.8\" -> 4\n    const value = parseInt(str, 10);\n    return getEnumCase(t, isNaN(value) ? str : value)[1];\n}\nexport function tryParseEnum(t, str) {\n    try {\n        const v = parseEnum(t, str);\n        return [true, v];\n    }\n    catch (_a) {\n        // supress error\n    }\n    return [false, NaN];\n}\nexport function getEnumName(t, v) {\n    return getEnumCase(t, v)[0];\n}\nexport function isEnumDefined(t, v) {\n    try {\n        const kv = getEnumCase(t, v);\n        return kv[0] != null && kv[0] !== \"\";\n    }\n    catch (_a) {\n        // supress error\n    }\n    return false;\n}\n// FSharpType\nexport function getUnionCases(t) {\n    if (t.cases != null) {\n        return t.cases();\n    }\n    else {\n        throw new Error(`${t.fullname} is not an F# union type`);\n    }\n}\nexport function getRecordElements(t) {\n    if (t.fields != null) {\n        return t.fields();\n    }\n    else {\n        throw new Error(`${t.fullname} is not an F# record type`);\n    }\n}\nexport function getTupleElements(t) {\n    if (isTuple(t) && t.generics != null) {\n        return t.generics;\n    }\n    else {\n        throw new Error(`${t.fullname} is not a tuple type`);\n    }\n}\nexport function getFunctionElements(t) {\n    if (isFunction(t) && t.generics != null) {\n        const gen = t.generics;\n        return [gen[0], gen[1]];\n    }\n    else {\n        throw new Error(`${t.fullname} is not an F# function type`);\n    }\n}\nexport function isUnion(t) {\n    return t instanceof TypeInfo ? t.cases != null : t instanceof Union;\n}\nexport function isRecord(t) {\n    return t instanceof TypeInfo ? t.fields != null : t instanceof Record;\n}\nexport function isTuple(t) {\n    return t.fullname.startsWith(\"System.Tuple\");\n}\n// In .NET this is false for delegates\nexport function isFunction(t) {\n    return t.fullname === \"Microsoft.FSharp.Core.FSharpFunc`2\";\n}\n// FSharpValue\nexport function getUnionFields(v, t) {\n    const cases = getUnionCases(t);\n    const case_ = cases[v.tag];\n    if (case_ == null) {\n        throw new Error(`Cannot find case ${v.name} in union type`);\n    }\n    return [case_, v.fields];\n}\nexport function getUnionCaseFields(uci) {\n    return uci.fields == null ? [] : uci.fields;\n}\nexport function getRecordFields(v) {\n    return Object.keys(v).map((k) => v[k]);\n}\nexport function getRecordField(v, field) {\n    return v[field[0]];\n}\nexport function getTupleFields(v) {\n    return v;\n}\nexport function getTupleField(v, i) {\n    return v[i];\n}\nexport function makeUnion(uci, values) {\n    const expectedLength = (uci.fields || []).length;\n    if (values.length !== expectedLength) {\n        throw new Error(`Expected an array of length ${expectedLength} but got ${values.length}`);\n    }\n    return uci.declaringType.construct != null\n        ? new uci.declaringType.construct(uci.tag, uci.name, ...values)\n        : {};\n}\nexport function makeRecord(t, values) {\n    const fields = getRecordElements(t);\n    if (fields.length !== values.length) {\n        throw new Error(`Expected an array of length ${fields.length} but got ${values.length}`);\n    }\n    return t.construct != null\n        ? new t.construct(...values)\n        : makeAnonRecord(fields.reduce((obj, [key, _t], i) => {\n            obj[key] = values[i];\n            return obj;\n        }, {}));\n}\nexport function makeTuple(values, _t) {\n    return values;\n}\nexport function makeGenericType(t, generics) {\n    return new TypeInfo(t.fullname, generics, t.construct, t.fields, t.cases);\n}\nexport function createInstance(t, consArgs) {\n    // TODO: Check if consArgs length is same as t.construct?\n    // (Arg types can still be different)\n    if (typeof t.construct === \"function\") {\n        return new t.construct(...(consArgs !== null && consArgs !== void 0 ? consArgs : []));\n    }\n    else {\n        throw new Error(`Cannot access constructor of ${t.fullname}`);\n    }\n}\nexport function getValue(propertyInfo, v) {\n    return v[propertyInfo[0]];\n}\n// Fable.Core.Reflection\nfunction assertUnion(x) {\n    if (!(x instanceof Union)) {\n        throw new Error(`Value is not an F# union type`);\n    }\n}\nexport function getCaseTag(x) {\n    assertUnion(x);\n    return x.tag;\n}\nexport function getCaseName(x) {\n    assertUnion(x);\n    return x.name;\n}\nexport function getCaseFields(x) {\n    assertUnion(x);\n    return x.fields;\n}\n//# sourceMappingURL=Reflection.js.map","// export type decimal = Decimal;\nexport var NumberStyles;\n(function (NumberStyles) {\n    // None = 0x00000000,\n    // AllowLeadingWhite = 0x00000001,\n    // AllowTrailingWhite = 0x00000002,\n    // AllowLeadingSign = 0x00000004,\n    // AllowTrailingSign = 0x00000008,\n    // AllowParentheses = 0x00000010,\n    // AllowDecimalPoint = 0x00000020,\n    // AllowThousands = 0x00000040,\n    // AllowExponent = 0x00000080,\n    // AllowCurrencySymbol = 0x00000100,\n    NumberStyles[NumberStyles[\"AllowHexSpecifier\"] = 512] = \"AllowHexSpecifier\";\n    // Integer = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign,\n    // HexNumber = AllowLeadingWhite | AllowTrailingWhite | AllowHexSpecifier,\n    // Number = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign |\n    //          AllowTrailingSign | AllowDecimalPoint | AllowThousands,\n    // Float = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign |\n    //         AllowDecimalPoint | AllowExponent,\n    // Currency = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowTrailingSign |\n    //            AllowParentheses | AllowDecimalPoint | AllowThousands | AllowCurrencySymbol,\n    // Any = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowTrailingSign |\n    //       AllowParentheses | AllowDecimalPoint | AllowThousands | AllowCurrencySymbol | AllowExponent,\n})(NumberStyles || (NumberStyles = {}));\nfunction validResponse(regexMatch, radix) {\n    const [/*all*/ , sign, prefix, digits] = regexMatch;\n    return {\n        sign: sign || \"\",\n        prefix: prefix || \"\",\n        digits,\n        radix,\n    };\n}\nfunction getRange(unsigned, bitsize) {\n    switch (bitsize) {\n        case 8: return unsigned ? [0, 255] : [-128, 127];\n        case 16: return unsigned ? [0, 65535] : [-32768, 32767];\n        case 32: return unsigned ? [0, 4294967295] : [-2147483648, 2147483647];\n        default: throw new Error(\"Invalid bit size.\");\n    }\n}\nfunction getInvalidDigits(radix) {\n    switch (radix) {\n        case 2: return /[^0-1]/;\n        case 8: return /[^0-7]/;\n        case 10: return /[^0-9]/;\n        case 16: return /[^0-9a-fA-F]/;\n        default:\n            throw new Error(\"Invalid Base.\");\n    }\n}\nfunction getRadix(prefix, style) {\n    if (style & NumberStyles.AllowHexSpecifier) {\n        return 16;\n    }\n    else {\n        switch (prefix) {\n            case \"0b\":\n            case \"0B\": return 2;\n            case \"0o\":\n            case \"0O\": return 8;\n            case \"0x\":\n            case \"0X\": return 16;\n            default: return 10;\n        }\n    }\n}\nexport function isValid(str, style, radix) {\n    const integerRegex = /^\\s*([\\+\\-])?(0[xXoObB])?([0-9a-fA-F]+)\\s*$/;\n    const res = integerRegex.exec(str.replace(/_/g, \"\"));\n    if (res != null) {\n        const [/*all*/ , /*sign*/ , prefix, digits] = res;\n        radix = radix || getRadix(prefix, style);\n        const invalidDigits = getInvalidDigits(radix);\n        if (!invalidDigits.test(digits)) {\n            return validResponse(res, radix);\n        }\n    }\n    return null;\n}\nexport function parse(str, style, unsigned, bitsize, radix) {\n    const res = isValid(str, style, radix);\n    if (res != null) {\n        let v = Number.parseInt(res.sign + res.digits, res.radix);\n        if (!Number.isNaN(v)) {\n            const [umin, umax] = getRange(true, bitsize);\n            if (!unsigned && res.radix !== 10 && v >= umin && v <= umax) {\n                v = v << (32 - bitsize) >> (32 - bitsize);\n            }\n            const [min, max] = getRange(unsigned, bitsize);\n            if (v >= min && v <= max) {\n                return v;\n            }\n        }\n    }\n    throw new Error(\"Input string was not in a correct format.\");\n}\nexport function tryParse(str, style, unsigned, bitsize) {\n    try {\n        const v = parse(str, style, unsigned, bitsize);\n        return [true, v];\n    }\n    catch (_a) {\n        // supress error\n    }\n    return [false, 0];\n}\nexport function op_UnaryNegation_Int8(x) {\n    return x === -128 ? x : -x;\n}\nexport function op_UnaryNegation_Int16(x) {\n    return x === -32768 ? x : -x;\n}\nexport function op_UnaryNegation_Int32(x) {\n    return x === -2147483648 ? x : -x;\n}\n//# sourceMappingURL=Int32.js.map","// Adapted from: https://github.com/dcodeIO/long.js/blob/master/src/long.js\n// Apache License 2.0: https://github.com/dcodeIO/long.js/blob/master/LICENSE\nexport default Long;\n/**\n * wasm optimizations, to do native i64 multiplication and divide\n */\nvar wasm = null;\ntry {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\n    ])), {}).exports;\n}\ncatch (e) {\n    // no wasm support :(\n}\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n *  See the from* functions below for more convenient ways of constructing Longs.\n * @exports Long\n * @class A Long class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @constructor\n */\nexport function Long(low, high, unsigned) {\n    /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */\n    this.low = low | 0;\n    /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */\n    this.high = high | 0;\n    /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */\n    this.unsigned = !!unsigned;\n}\nLong.prototype.GetHashCode = function () {\n    let h1 = this.unsigned ? 1 : 0;\n    h1 = ((h1 << 5) + h1) ^ this.high;\n    h1 = ((h1 << 5) + h1) ^ this.low;\n    return h1;\n};\nLong.prototype.Equals = function (x) { return equals(this, x); };\nLong.prototype.CompareTo = function (x) { return compare(this, x); };\nLong.prototype.toString = function (radix) { return toString(this, radix); };\nLong.prototype.toJSON = function () { return toString(this); };\n// The internal representation of a long is the two given signed, 32-bit values.\n// We use 32-bit pieces because these are the size of integers on which\n// Javascript performs bit-operations.  For operations like addition and\n// multiplication, we split each number into 16 bit pieces, which can easily be\n// multiplied within Javascript's floating-point representation without overflow\n// or change in sign.\n//\n// In the algorithms below, we frequently reduce the negative case to the\n// positive case by negating the input(s) and then post-processing the result.\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n// a positive number, it overflows back into a negative).  Not handling this\n// case would often result in infinite recursion.\n//\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n// methods on which they depend.\n/**\n * An indicator used to reliably determine if an object is a Long or not.\n * @type {boolean}\n * @const\n * @private\n */\nLong.prototype.__isLong__;\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\n/**\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n * @inner\n */\nexport function isLong(obj) {\n    return (obj && obj[\"__isLong__\"]) === true;\n}\n/**\n * Tests if the specified object is a Long.\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n */\n// Long.isLong = isLong;\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @inner\n */\nvar INT_CACHE = {};\n/**\n * A cache of the Long representations of small unsigned integer values.\n * @type {!Object}\n * @inner\n */\nvar UINT_CACHE = {};\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nexport function fromInt(value, unsigned) {\n    var obj, cachedObj, cache;\n    if (unsigned) {\n        value >>>= 0;\n        if (cache = (0 <= value && value < 256)) {\n            cachedObj = UINT_CACHE[value];\n            if (cachedObj)\n                return cachedObj;\n        }\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n        if (cache)\n            UINT_CACHE[value] = obj;\n        return obj;\n    }\n    else {\n        value |= 0;\n        if (cache = (-128 <= value && value < 128)) {\n            cachedObj = INT_CACHE[value];\n            if (cachedObj)\n                return cachedObj;\n        }\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\n        if (cache)\n            INT_CACHE[value] = obj;\n        return obj;\n    }\n}\n/**\n * Returns a Long representing the given 32 bit integer value.\n * @function\n * @param {number} value The 32 bit integer in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromInt = fromInt;\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nexport function fromNumber(value, unsigned) {\n    if (isNaN(value))\n        return unsigned ? UZERO : ZERO;\n    if (unsigned) {\n        if (value < 0)\n            return UZERO;\n        if (value >= TWO_PWR_64_DBL)\n            return MAX_UNSIGNED_VALUE;\n    }\n    else {\n        if (value <= -TWO_PWR_63_DBL)\n            return MIN_VALUE;\n        if (value + 1 >= TWO_PWR_63_DBL)\n            return MAX_VALUE;\n    }\n    if (value < 0)\n        return negate(fromNumber(-value, unsigned));\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\n}\n/**\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @function\n * @param {number} value The number in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromNumber = fromNumber;\n/**\n * @param {number} lowBits\n * @param {number} highBits\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nexport function fromBits(lowBits, highBits, unsigned) {\n    return new Long(lowBits, highBits, unsigned);\n}\n/**\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @function\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromBits = fromBits;\n/**\n * @function\n * @param {number} base\n * @param {number} exponent\n * @returns {number}\n * @inner\n */\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n/**\n * @param {string} str\n * @param {(boolean|number)=} unsigned\n * @param {number=} radix\n * @returns {!Long}\n * @inner\n */\nexport function fromString(str, unsigned, radix) {\n    if (str.length === 0)\n        throw Error('empty string');\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n        return ZERO;\n    if (typeof unsigned === 'number') {\n        // For goog.math.long compatibility\n        radix = unsigned,\n            unsigned = false;\n    }\n    else {\n        unsigned = !!unsigned;\n    }\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix)\n        throw RangeError('radix');\n    var p = str.indexOf('-');\n    if (p > 0)\n        throw Error('interior hyphen');\n    else if (p === 0) {\n        return negate(fromString(str.substring(1), unsigned, radix));\n    }\n    // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\n    var result = ZERO;\n    for (var i = 0; i < str.length; i += 8) {\n        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n        if (size < 8) {\n            var power = fromNumber(pow_dbl(radix, size));\n            result = add(multiply(result, power), fromNumber(value));\n        }\n        else {\n            result = multiply(result, radixToPower);\n            result = add(result, fromNumber(value));\n        }\n    }\n    result.unsigned = unsigned;\n    return result;\n}\n/**\n * Returns a Long representation of the given string, written using the specified radix.\n * @function\n * @param {string} str The textual representation of the Long\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Long} The corresponding Long value\n */\n// Long.fromString = fromString;\n/**\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nexport function fromValue(val, unsigned) {\n    if (typeof val === 'number')\n        return fromNumber(val, unsigned);\n    if (typeof val === 'string')\n        return fromString(val, unsigned);\n    // Throws for non-objects, converts non-instanceof Long:\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n}\n/**\n * Converts the specified value to a Long using the appropriate from* function for its type.\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long}\n */\n// Long.fromValue = fromValue;\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n// no runtime penalty for these.\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_16_DBL = 1 << 16;\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_24_DBL = 1 << 24;\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n/**\n * @type {!Long}\n * @const\n * @inner\n */\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n/**\n * @type {!Long}\n * @inner\n */\nexport var ZERO = fromInt(0);\n/**\n * Signed zero.\n * @type {!Long}\n */\n// Long.ZERO = ZERO;\n/**\n * @type {!Long}\n * @inner\n */\nexport var UZERO = fromInt(0, true);\n/**\n * Unsigned zero.\n * @type {!Long}\n */\n// Long.UZERO = UZERO;\n/**\n * @type {!Long}\n * @inner\n */\nexport var ONE = fromInt(1);\n/**\n * Signed one.\n * @type {!Long}\n */\n// Long.ONE = ONE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var UONE = fromInt(1, true);\n/**\n * Unsigned one.\n * @type {!Long}\n */\n// Long.UONE = UONE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var NEG_ONE = fromInt(-1);\n/**\n * Signed negative one.\n * @type {!Long}\n */\n// Long.NEG_ONE = NEG_ONE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n/**\n * Maximum signed value.\n * @type {!Long}\n */\n// Long.MAX_VALUE = MAX_VALUE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n/**\n * Maximum unsigned value.\n * @type {!Long}\n */\n// Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n/**\n * @type {!Long}\n * @inner\n */\nexport var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n/**\n * Minimum signed value.\n * @type {!Long}\n */\n// Long.MIN_VALUE = MIN_VALUE;\n/**\n * @alias Long.prototype\n * @inner\n */\n// var LongPrototype = Long.prototype;\n/**\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n * @this {!Long}\n * @returns {number}\n */\nexport function toInt($this) {\n    return $this.unsigned ? $this.low >>> 0 : $this.low;\n}\n;\n/**\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n * @this {!Long}\n * @returns {number}\n */\nexport function toNumber($this) {\n    if ($this.unsigned)\n        return (($this.high >>> 0) * TWO_PWR_32_DBL) + ($this.low >>> 0);\n    return $this.high * TWO_PWR_32_DBL + ($this.low >>> 0);\n}\n;\n/**\n * Converts the Long to a string written in the specified radix.\n * @this {!Long}\n * @param {number=} radix Radix (2-36), defaults to 10\n * @returns {string}\n * @override\n * @throws {RangeError} If `radix` is out of range\n */\nexport function toString($this, radix) {\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix)\n        throw RangeError('radix');\n    if (isZero($this))\n        return '0';\n    if (isNegative($this)) { // Unsigned Longs are never negative\n        if (equals($this, MIN_VALUE)) {\n            // We need to change the Long value before it can be negated, so we remove\n            // the bottom-most digit in this base and then recurse to do the rest.\n            var radixLong = fromNumber(radix), div = divide($this, radixLong), rem1 = subtract(multiply(div, radixLong), $this);\n            return toString(div, radix) + toInt(rem1).toString(radix);\n        }\n        else\n            return '-' + toString(negate($this), radix);\n    }\n    // Do several (6) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 6), $this.unsigned), rem = $this;\n    var result = '';\n    while (true) {\n        var remDiv = divide(rem, radixToPower), intval = toInt(subtract(rem, multiply(remDiv, radixToPower))) >>> 0, digits = intval.toString(radix);\n        rem = remDiv;\n        if (isZero(rem))\n            return digits + result;\n        else {\n            while (digits.length < 6)\n                digits = '0' + digits;\n            result = '' + digits + result;\n        }\n    }\n}\n;\n/**\n * Gets the high 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed high bits\n */\nexport function getHighBits($this) {\n    return $this.high;\n}\n;\n/**\n * Gets the high 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned high bits\n */\nexport function getHighBitsUnsigned($this) {\n    return $this.high >>> 0;\n}\n;\n/**\n * Gets the low 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed low bits\n */\nexport function getLowBits($this) {\n    return $this.low;\n}\n;\n/**\n * Gets the low 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned low bits\n */\nexport function getLowBitsUnsigned($this) {\n    return $this.low >>> 0;\n}\n;\n/**\n * Gets the number of bits needed to represent the absolute value of this Long.\n * @this {!Long}\n * @returns {number}\n */\nexport function getNumBitsAbs($this) {\n    if (isNegative($this)) // Unsigned Longs are never negative\n        return equals($this, MIN_VALUE) ? 64 : getNumBitsAbs(negate($this));\n    var val = $this.high != 0 ? $this.high : $this.low;\n    for (var bit = 31; bit > 0; bit--)\n        if ((val & (1 << bit)) != 0)\n            break;\n    return $this.high != 0 ? bit + 33 : bit + 1;\n}\n;\n/**\n * Tests if this Long's value equals zero.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isZero($this) {\n    return $this.high === 0 && $this.low === 0;\n}\n;\n/**\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n * @returns {boolean}\n */\n// LongPrototype.eqz = LongPrototype.isZero;\n/**\n * Tests if this Long's value is negative.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isNegative($this) {\n    return !$this.unsigned && $this.high < 0;\n}\n;\n/**\n * Tests if this Long's value is positive.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isPositive($this) {\n    return $this.unsigned || $this.high >= 0;\n}\n;\n/**\n * Tests if this Long's value is odd.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isOdd($this) {\n    return ($this.low & 1) === 1;\n}\n;\n/**\n * Tests if this Long's value is even.\n * @this {!Long}\n * @returns {boolean}\n */\nexport function isEven($this) {\n    return ($this.low & 1) === 0;\n}\n;\n/**\n * Tests if this Long's value equals the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function equals($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    if ($this.unsigned !== other.unsigned && ($this.high >>> 31) === 1 && (other.high >>> 31) === 1)\n        return false;\n    return $this.high === other.high && $this.low === other.low;\n}\n;\n/**\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.eq = LongPrototype.equals;\n/**\n * Tests if this Long's value differs from the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function notEquals($this, other) {\n    return !equals($this, /* validates */ other);\n}\n;\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.neq = LongPrototype.notEquals;\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.ne = LongPrototype.notEquals;\n/**\n * Tests if this Long's value is less than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function lessThan($this, other) {\n    return compare($this, /* validates */ other) < 0;\n}\n;\n/**\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.lt = LongPrototype.lessThan;\n/**\n * Tests if this Long's value is less than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function lessThanOrEqual($this, other) {\n    return compare($this, /* validates */ other) <= 0;\n}\n;\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.lte = LongPrototype.lessThanOrEqual;\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.le = LongPrototype.lessThanOrEqual;\n/**\n * Tests if this Long's value is greater than the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function greaterThan($this, other) {\n    return compare($this, /* validates */ other) > 0;\n}\n;\n/**\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.gt = LongPrototype.greaterThan;\n/**\n * Tests if this Long's value is greater than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\nexport function greaterThanOrEqual($this, other) {\n    return compare($this, /* validates */ other) >= 0;\n}\n;\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {boolean}\n */\n// LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n/**\n * Compares this Long's value with the specified's.\n * @this {!Long}\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nexport function compare($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    if (equals($this, other))\n        return 0;\n    var thisNeg = isNegative($this), otherNeg = isNegative(other);\n    if (thisNeg && !otherNeg)\n        return -1;\n    if (!thisNeg && otherNeg)\n        return 1;\n    // At this point the sign bits are the same\n    if (!$this.unsigned)\n        return isNegative(subtract($this, other)) ? -1 : 1;\n    // Both are positive if at least one is unsigned\n    return (other.high >>> 0) > ($this.high >>> 0) || (other.high === $this.high && (other.low >>> 0) > ($this.low >>> 0)) ? -1 : 1;\n}\n;\n/**\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n * @function\n * @param {!Long|number|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\n// LongPrototype.comp = LongPrototype.compare;\n/**\n * Negates this Long's value.\n * @this {!Long}\n * @returns {!Long} Negated Long\n */\nexport function negate($this) {\n    if (!$this.unsigned && equals($this, MIN_VALUE))\n        return MIN_VALUE;\n    return add(not($this), ONE);\n}\n;\n/**\n * Negates this Long's value. This is an alias of {@link Long#negate}.\n * @function\n * @returns {!Long} Negated Long\n */\n// LongPrototype.neg = LongPrototype.negate;\n/**\n * Returns the sum of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} addend Addend\n * @returns {!Long} Sum\n */\nexport function add($this, addend) {\n    if (!isLong(addend))\n        addend = fromValue(addend);\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n    var a48 = $this.high >>> 16;\n    var a32 = $this.high & 0xFFFF;\n    var a16 = $this.low >>> 16;\n    var a00 = $this.low & 0xFFFF;\n    var b48 = addend.high >>> 16;\n    var b32 = addend.high & 0xFFFF;\n    var b16 = addend.low >>> 16;\n    var b00 = addend.low & 0xFFFF;\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 + b48;\n    c48 &= 0xFFFF;\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, $this.unsigned);\n}\n;\n/**\n * Returns the difference of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nexport function subtract($this, subtrahend) {\n    if (!isLong(subtrahend))\n        subtrahend = fromValue(subtrahend);\n    return add($this, negate(subtrahend));\n}\n;\n/**\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n * @function\n * @param {!Long|number|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\n// LongPrototype.sub = LongPrototype.subtract;\n/**\n * Returns the product of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nexport function multiply($this, multiplier) {\n    if (isZero($this))\n        return $this.unsigned ? UZERO : ZERO;\n    if (!isLong(multiplier))\n        multiplier = fromValue(multiplier);\n    // use wasm support if present\n    if (wasm) {\n        var low = wasm.mul($this.low, $this.high, multiplier.low, multiplier.high);\n        return fromBits(low, wasm.get_high(), $this.unsigned);\n    }\n    if (isZero(multiplier))\n        return $this.unsigned ? UZERO : ZERO;\n    if (equals($this, MIN_VALUE))\n        return isOdd(multiplier) ? MIN_VALUE : ZERO;\n    if (equals(multiplier, MIN_VALUE))\n        return isOdd($this) ? MIN_VALUE : ZERO;\n    if (isNegative($this)) {\n        if (isNegative(multiplier))\n            return multiply(negate($this), negate(multiplier));\n        else\n            return negate(multiply(negate($this), multiplier));\n    }\n    else if (isNegative(multiplier))\n        return negate(multiply($this, negate(multiplier)));\n    // If both longs are small, use float multiplication\n    if (lessThan($this, TWO_PWR_24) && lessThan(multiplier, TWO_PWR_24))\n        return fromNumber(toNumber($this) * toNumber(multiplier), $this.unsigned);\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n    var a48 = $this.high >>> 16;\n    var a32 = $this.high & 0xFFFF;\n    var a16 = $this.low >>> 16;\n    var a00 = $this.low & 0xFFFF;\n    var b48 = multiplier.high >>> 16;\n    var b32 = multiplier.high & 0xFFFF;\n    var b16 = multiplier.low >>> 16;\n    var b00 = multiplier.low & 0xFFFF;\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xFFFF;\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, $this.unsigned);\n}\n;\n/**\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n * @function\n * @param {!Long|number|string} multiplier Multiplier\n * @returns {!Long} Product\n */\n// LongPrototype.mul = LongPrototype.multiply;\n/**\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\n *  unsigned if this Long is unsigned.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nexport function divide($this, divisor) {\n    if (!isLong(divisor))\n        divisor = fromValue(divisor);\n    if (isZero(divisor))\n        throw Error('division by zero');\n    // use wasm support if present\n    if (wasm) {\n        // guard against signed division overflow: the largest\n        // negative number / -1 would be 1 larger than the largest\n        // positive number, due to two's complement.\n        if (!$this.unsigned &&\n            $this.high === -0x80000000 &&\n            divisor.low === -1 && divisor.high === -1) {\n            // be consistent with non-wasm code path\n            return $this;\n        }\n        var low = ($this.unsigned ? wasm.div_u : wasm.div_s)($this.low, $this.high, divisor.low, divisor.high);\n        return fromBits(low, wasm.get_high(), $this.unsigned);\n    }\n    if (isZero($this))\n        return $this.unsigned ? UZERO : ZERO;\n    var approx, rem, res;\n    if (!$this.unsigned) {\n        // This section is only relevant for signed longs and is derived from the\n        // closure library as a whole.\n        if (equals($this, MIN_VALUE)) {\n            if (equals(divisor, ONE) || equals(divisor, NEG_ONE))\n                return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n            else if (equals(divisor, MIN_VALUE))\n                return ONE;\n            else {\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                var halfThis = shiftRight($this, 1);\n                approx = shiftLeft(divide(halfThis, divisor), 1);\n                if (equals(approx, ZERO)) {\n                    return isNegative(divisor) ? ONE : NEG_ONE;\n                }\n                else {\n                    rem = subtract($this, multiply(divisor, approx));\n                    res = add(approx, divide(rem, divisor));\n                    return res;\n                }\n            }\n        }\n        else if (equals(divisor, MIN_VALUE))\n            return $this.unsigned ? UZERO : ZERO;\n        if (isNegative($this)) {\n            if (isNegative(divisor))\n                return divide(negate($this), negate(divisor));\n            return negate(divide(negate($this), divisor));\n        }\n        else if (isNegative(divisor))\n            return negate(divide($this, negate(divisor)));\n        res = ZERO;\n    }\n    else {\n        // The algorithm below has not been made for unsigned longs. It's therefore\n        // required to take special care of the MSB prior to running it.\n        if (!divisor.unsigned)\n            divisor = toUnsigned(divisor);\n        if (greaterThan(divisor, $this))\n            return UZERO;\n        if (greaterThan(divisor, shiftRightUnsigned($this, 1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n            return UONE;\n        res = UZERO;\n    }\n    // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n    rem = $this;\n    while (greaterThanOrEqual(rem, divisor)) {\n        // Approximate the result of division. This may be a little greater or\n        // smaller than the actual value.\n        approx = Math.max(1, Math.floor(toNumber(rem) / toNumber(divisor)));\n        // We will tweak the approximate result by changing it in the 48-th digit or\n        // the smallest non-fractional digit, whichever is larger.\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48), \n        // Decrease the approximation until it is smaller than the remainder.  Note\n        // that if it is too large, the product overflows and is negative.\n        approxRes = fromNumber(approx), approxRem = multiply(approxRes, divisor);\n        while (isNegative(approxRem) || greaterThan(approxRem, rem)) {\n            approx -= delta;\n            approxRes = fromNumber(approx, $this.unsigned);\n            approxRem = multiply(approxRes, divisor);\n        }\n        // We know the answer can't be zero... and actually, zero would cause\n        // infinite recursion since we would make no progress.\n        if (isZero(approxRes))\n            approxRes = ONE;\n        res = add(res, approxRes);\n        rem = subtract(rem, approxRem);\n    }\n    return res;\n}\n;\n/**\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Quotient\n */\n// LongPrototype.div = LongPrototype.divide;\n/**\n * Returns this Long modulo the specified.\n * @this {!Long}\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nexport function modulo($this, divisor) {\n    if (!isLong(divisor))\n        divisor = fromValue(divisor);\n    // use wasm support if present\n    if (wasm) {\n        var low = ($this.unsigned ? wasm.rem_u : wasm.rem_s)($this.low, $this.high, divisor.low, divisor.high);\n        return fromBits(low, wasm.get_high(), $this.unsigned);\n    }\n    return subtract($this, multiply(divide($this, divisor), divisor));\n}\n;\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\n// LongPrototype.mod = LongPrototype.modulo;\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|string} divisor Divisor\n * @returns {!Long} Remainder\n */\n// LongPrototype.rem = LongPrototype.modulo;\n/**\n * Returns the bitwise NOT of this Long.\n * @this {!Long}\n * @returns {!Long}\n */\nexport function not($this) {\n    return fromBits(~$this.low, ~$this.high, $this.unsigned);\n}\n;\n/**\n * Returns the bitwise AND of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nexport function and($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits($this.low & other.low, $this.high & other.high, $this.unsigned);\n}\n;\n/**\n * Returns the bitwise OR of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nexport function or($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits($this.low | other.low, $this.high | other.high, $this.unsigned);\n}\n;\n/**\n * Returns the bitwise XOR of this Long and the given one.\n * @this {!Long}\n * @param {!Long|number|string} other Other Long\n * @returns {!Long}\n */\nexport function xor($this, other) {\n    if (!isLong(other))\n        other = fromValue(other);\n    return fromBits($this.low ^ other.low, $this.high ^ other.high, $this.unsigned);\n}\n;\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nexport function shiftLeft($this, numBits) {\n    if (isLong(numBits))\n        numBits = toInt(numBits);\n    if ((numBits &= 63) === 0)\n        return $this;\n    else if (numBits < 32)\n        return fromBits($this.low << numBits, ($this.high << numBits) | ($this.low >>> (32 - numBits)), $this.unsigned);\n    else\n        return fromBits(0, $this.low << (numBits - 32), $this.unsigned);\n}\n;\n/**\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shl = LongPrototype.shiftLeft;\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nexport function shiftRight($this, numBits) {\n    if (isLong(numBits))\n        numBits = toInt(numBits);\n    if ((numBits &= 63) === 0)\n        return $this;\n    else if (numBits < 32)\n        return fromBits(($this.low >>> numBits) | ($this.high << (32 - numBits)), $this.high >> numBits, $this.unsigned);\n    else\n        return fromBits($this.high >> (numBits - 32), $this.high >= 0 ? 0 : -1, $this.unsigned);\n}\n;\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shr = LongPrototype.shiftRight;\n/**\n * Returns this Long with bits logically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nexport function shiftRightUnsigned($this, numBits) {\n    if (isLong(numBits))\n        numBits = toInt(numBits);\n    numBits &= 63;\n    if (numBits === 0)\n        return $this;\n    else {\n        var high = $this.high;\n        if (numBits < 32) {\n            var low = $this.low;\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, $this.unsigned);\n        }\n        else if (numBits === 32)\n            return fromBits(high, 0, $this.unsigned);\n        else\n            return fromBits(high >>> (numBits - 32), 0, $this.unsigned);\n    }\n}\n;\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\n// LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n/**\n * Returns this Long with bits rotated to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nexport const rotateLeft = function rotateLeft(numBits) {\n    var b;\n    if (isLong(numBits))\n        numBits = numBits.toInt();\n    if ((numBits &= 63) === 0)\n        return this;\n    if (numBits === 32)\n        return fromBits(this.high, this.low, this.unsigned);\n    if (numBits < 32) {\n        b = (32 - numBits);\n        return fromBits(((this.low << numBits) | (this.high >>> b)), ((this.high << numBits) | (this.low >>> b)), this.unsigned);\n    }\n    numBits -= 32;\n    b = (32 - numBits);\n    return fromBits(((this.high << numBits) | (this.low >>> b)), ((this.low << numBits) | (this.high >>> b)), this.unsigned);\n};\n/**\n * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\n// LongPrototype.rotl = LongPrototype.rotateLeft;\n/**\n * Returns this Long with bits rotated to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nexport const rotateRight = function rotateRight(numBits) {\n    var b;\n    if (isLong(numBits))\n        numBits = numBits.toInt();\n    if ((numBits &= 63) === 0)\n        return this;\n    if (numBits === 32)\n        return fromBits(this.high, this.low, this.unsigned);\n    if (numBits < 32) {\n        b = (32 - numBits);\n        return fromBits(((this.high << b) | (this.low >>> numBits)), ((this.low << b) | (this.high >>> numBits)), this.unsigned);\n    }\n    numBits -= 32;\n    b = (32 - numBits);\n    return fromBits(((this.low << b) | (this.high >>> numBits)), ((this.high << b) | (this.low >>> numBits)), this.unsigned);\n};\n/**\n * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\n// LongPrototype.rotr = LongPrototype.rotateRight;\n/**\n * Converts this Long to signed.\n * @this {!Long}\n * @returns {!Long} Signed long\n */\nexport function toSigned($this) {\n    if (!$this.unsigned)\n        return $this;\n    return fromBits($this.low, $this.high, false);\n}\n;\n/**\n * Converts this Long to unsigned.\n * @this {!Long}\n * @returns {!Long} Unsigned long\n */\nexport function toUnsigned($this) {\n    if ($this.unsigned)\n        return $this;\n    return fromBits($this.low, $this.high, true);\n}\n;\n/**\n * Converts this Long to its byte representation.\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @this {!Long}\n * @returns {!Array.<number>} Byte representation\n */\nexport function toBytes($this, le) {\n    return le ? toBytesLE($this) : toBytesBE($this);\n}\n;\n/**\n * Converts this Long to its little endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Little endian byte representation\n */\nexport function toBytesLE($this) {\n    var hi = $this.high, lo = $this.low;\n    return [\n        lo & 0xff,\n        lo >>> 8 & 0xff,\n        lo >>> 16 & 0xff,\n        lo >>> 24,\n        hi & 0xff,\n        hi >>> 8 & 0xff,\n        hi >>> 16 & 0xff,\n        hi >>> 24\n    ];\n}\n;\n/**\n * Converts this Long to its big endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Big endian byte representation\n */\nexport function toBytesBE($this) {\n    var hi = $this.high, lo = $this.low;\n    return [\n        hi >>> 24,\n        hi >>> 16 & 0xff,\n        hi >>> 8 & 0xff,\n        hi & 0xff,\n        lo >>> 24,\n        lo >>> 16 & 0xff,\n        lo >>> 8 & 0xff,\n        lo & 0xff\n    ];\n}\n;\n/**\n * Creates a Long from its byte representation.\n * @param {!Array.<number>} bytes Byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @returns {Long} The corresponding Long value\n */\nexport function fromBytes(bytes, unsigned, le) {\n    return le ? fromBytesLE(bytes, unsigned) : fromBytesBE(bytes, unsigned);\n}\n;\n/**\n * Creates a Long from its little endian byte representation.\n * @param {!Array.<number>} bytes Little endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nexport function fromBytesLE(bytes, unsigned) {\n    return new Long(bytes[0] |\n        bytes[1] << 8 |\n        bytes[2] << 16 |\n        bytes[3] << 24, bytes[4] |\n        bytes[5] << 8 |\n        bytes[6] << 16 |\n        bytes[7] << 24, unsigned);\n}\n;\n/**\n * Creates a Long from its big endian byte representation.\n * @param {!Array.<number>} bytes Big endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nexport function fromBytesBE(bytes, unsigned) {\n    return new Long(bytes[4] << 24 |\n        bytes[5] << 16 |\n        bytes[6] << 8 |\n        bytes[7], bytes[0] << 24 |\n        bytes[1] << 16 |\n        bytes[2] << 8 |\n        bytes[3], unsigned);\n}\n;\n//# sourceMappingURL=long.js.map","import { isValid } from \"./Int32\";\nimport * as LongLib from \"./lib/long\";\nexport default LongLib.Long;\nexport const get_Zero = LongLib.ZERO;\nexport const get_One = LongLib.ONE;\nexport const op_Addition = LongLib.add;\nexport const op_Subtraction = LongLib.subtract;\nexport const op_Multiply = LongLib.multiply;\nexport const op_Division = LongLib.divide;\nexport const op_Modulus = LongLib.modulo;\nexport const op_UnaryNegation = LongLib.negate;\nexport const op_LeftShift = LongLib.shiftLeft;\nexport const op_RightShift = LongLib.shiftRight;\nexport const op_RightShiftUnsigned = LongLib.shiftRightUnsigned;\nexport const op_BitwiseAnd = LongLib.and;\nexport const op_BitwiseOr = LongLib.or;\nexport const op_ExclusiveOr = LongLib.xor;\nexport const op_LogicalNot = LongLib.not;\nexport const op_LessThan = LongLib.lessThan;\nexport const op_LessThanOrEqual = LongLib.lessThanOrEqual;\nexport const op_GreaterThan = LongLib.greaterThan;\nexport const op_GreaterThanOrEqual = LongLib.greaterThanOrEqual;\nexport const op_Equality = LongLib.equals;\nexport const op_Inequality = LongLib.notEquals;\nexport const equals = LongLib.equals;\nexport const compare = LongLib.compare;\nexport const fromInt = LongLib.fromInt;\nexport const fromBits = LongLib.fromBits;\nexport const fromBytes = LongLib.fromBytes;\nexport const fromNumber = LongLib.fromNumber;\nexport const fromString = LongLib.fromString;\nexport const fromValue = LongLib.fromValue;\nexport const toInt = LongLib.toInt;\nexport const toBytes = LongLib.toBytes;\nexport const toNumber = LongLib.toNumber;\nexport const toString = LongLib.toString;\nexport const getLowBits = LongLib.getLowBits;\nexport const getHighBits = LongLib.getHighBits;\nexport const getLowBitsUnsigned = LongLib.getLowBitsUnsigned;\nexport const getHighBitsUnsigned = LongLib.getHighBitsUnsigned;\nfunction getMaxValue(unsigned, radix, isNegative) {\n    switch (radix) {\n        case 2: return unsigned ?\n            \"1111111111111111111111111111111111111111111111111111111111111111\" :\n            (isNegative ? \"1000000000000000000000000000000000000000000000000000000000000000\"\n                : \"111111111111111111111111111111111111111111111111111111111111111\");\n        case 8: return unsigned ?\n            \"1777777777777777777777\" :\n            (isNegative ? \"1000000000000000000000\" : \"777777777777777777777\");\n        case 10: return unsigned ?\n            \"18446744073709551615\" :\n            (isNegative ? \"9223372036854775808\" : \"9223372036854775807\");\n        case 16: return unsigned ?\n            \"FFFFFFFFFFFFFFFF\" :\n            (isNegative ? \"8000000000000000\" : \"7FFFFFFFFFFFFFFF\");\n        default: throw new Error(\"Invalid radix.\");\n    }\n}\nexport function abs(x) {\n    if (!x.unsigned && LongLib.isNegative(x)) {\n        return op_UnaryNegation(x);\n    }\n    else {\n        return x;\n    }\n}\nexport function fromInteger(value, unsigned, kind) {\n    let x = value;\n    let xh = 0;\n    switch (kind) {\n        case 0:\n            x = value << 24 >> 24;\n            xh = x;\n            break;\n        case 4:\n            x = value << 24 >>> 24;\n            break;\n        case 1:\n            x = value << 16 >> 16;\n            xh = x;\n            break;\n        case 5:\n            x = value << 16 >>> 16;\n            break;\n        case 2:\n            x = value >> 0;\n            xh = x;\n            break;\n        case 6:\n            x = value >>> 0;\n            break;\n    }\n    return LongLib.fromBits(x, xh >> 31, unsigned);\n}\nexport function parse(str, style, unsigned, _bitsize, radix) {\n    const res = isValid(str, style, radix);\n    if (res != null) {\n        const lessOrEqual = (x, y) => {\n            const len = Math.max(x.length, y.length);\n            return x.padStart(len, \"0\") <= y.padStart(len, \"0\");\n        };\n        const isNegative = res.sign === \"-\";\n        const maxValue = getMaxValue(unsigned || res.radix !== 10, res.radix, isNegative);\n        if (lessOrEqual(res.digits.toUpperCase(), maxValue)) {\n            str = isNegative ? res.sign + res.digits : res.digits;\n            return LongLib.fromString(str, unsigned, res.radix);\n        }\n    }\n    throw new Error(\"Input string was not in a correct format.\");\n}\nexport function tryParse(str, style, unsigned, bitsize) {\n    try {\n        const v = parse(str, style, unsigned, bitsize);\n        return [true, v];\n    }\n    catch (_a) {\n        // supress error\n    }\n    return [false, LongLib.ZERO];\n}\nexport function unixEpochMillisecondsToTicks(ms, offset) {\n    return op_Multiply(op_Addition(op_Addition(LongLib.fromNumber(ms), 62135596800000), offset), 10000);\n}\nexport function ticksToUnixEpochMilliseconds(ticks) {\n    return LongLib.toNumber(op_Subtraction(op_Division(ticks, 10000), 62135596800000));\n}\nexport function makeRangeStepFunction(step, last, unsigned) {\n    const stepComparedWithZero = LongLib.compare(step, unsigned ? LongLib.UZERO : LongLib.ZERO);\n    if (stepComparedWithZero === 0) {\n        throw new Error(\"The step of a range cannot be zero\");\n    }\n    const stepGreaterThanZero = stepComparedWithZero > 0;\n    return (x) => {\n        const comparedWithLast = LongLib.compare(x, last);\n        if ((stepGreaterThanZero && comparedWithLast <= 0)\n            || (!stepGreaterThanZero && comparedWithLast >= 0)) {\n            return [x, op_Addition(x, step)];\n        }\n        else {\n            return undefined;\n        }\n    };\n}\n//# sourceMappingURL=Long.js.map","/**\n * DateTimeOffset functions.\n *\n * Note: Date instances are always DateObjects in local\n * timezone (because JS dates are all kinds of messed up).\n * A local date returns UTC epoc when `.getTime()` is called.\n *\n * Basically; invariant: date.getTime() always return UTC time.\n */\nimport { fromValue, ticksToUnixEpochMilliseconds, unixEpochMillisecondsToTicks } from \"./Long\";\nimport { compareDates, dateOffset, padWithZeros } from \"./Util\";\nexport const offsetRegex = /(?:Z|[+-](\\d+):?([0-5]?\\d)?)\\s*$/;\nexport function dateOffsetToString(offset) {\n    const isMinus = offset < 0;\n    offset = Math.abs(offset);\n    const hours = ~~(offset / 3600000);\n    const minutes = (offset % 3600000) / 60000;\n    return (isMinus ? \"-\" : \"+\") +\n        padWithZeros(hours, 2) + \":\" +\n        padWithZeros(minutes, 2);\n}\nexport function dateToHalfUTCString(date, half) {\n    const str = date.toISOString();\n    return half === \"first\"\n        ? str.substring(0, str.indexOf(\"T\"))\n        : str.substring(str.indexOf(\"T\") + 1, str.length - 1);\n}\nfunction dateToISOString(d, utc) {\n    if (utc) {\n        return d.toISOString();\n    }\n    else {\n        // JS Date is always local\n        const printOffset = d.kind == null ? true : d.kind === 2 /* Local */;\n        return padWithZeros(d.getFullYear(), 4) + \"-\" +\n            padWithZeros(d.getMonth() + 1, 2) + \"-\" +\n            padWithZeros(d.getDate(), 2) + \"T\" +\n            padWithZeros(d.getHours(), 2) + \":\" +\n            padWithZeros(d.getMinutes(), 2) + \":\" +\n            padWithZeros(d.getSeconds(), 2) + \".\" +\n            padWithZeros(d.getMilliseconds(), 3) +\n            (printOffset ? dateOffsetToString(d.getTimezoneOffset() * -60000) : \"\");\n    }\n}\nfunction dateToISOStringWithOffset(dateWithOffset, offset) {\n    const str = dateWithOffset.toISOString();\n    return str.substring(0, str.length - 1) + dateOffsetToString(offset);\n}\nfunction dateToStringWithCustomFormat(date, format, utc) {\n    return format.replace(/(\\w)\\1*/g, (match) => {\n        let rep = Number.NaN;\n        switch (match.substring(0, 1)) {\n            case \"y\":\n                const y = utc ? date.getUTCFullYear() : date.getFullYear();\n                rep = match.length < 4 ? y % 100 : y;\n                break;\n            case \"M\":\n                rep = (utc ? date.getUTCMonth() : date.getMonth()) + 1;\n                break;\n            case \"d\":\n                rep = utc ? date.getUTCDate() : date.getDate();\n                break;\n            case \"H\":\n                rep = utc ? date.getUTCHours() : date.getHours();\n                break;\n            case \"h\":\n                const h = utc ? date.getUTCHours() : date.getHours();\n                rep = h > 12 ? h % 12 : h;\n                break;\n            case \"m\":\n                rep = utc ? date.getUTCMinutes() : date.getMinutes();\n                break;\n            case \"s\":\n                rep = utc ? date.getUTCSeconds() : date.getSeconds();\n                break;\n            case \"f\":\n                rep = utc ? date.getUTCMilliseconds() : date.getMilliseconds();\n                break;\n        }\n        if (Number.isNaN(rep)) {\n            return match;\n        }\n        else {\n            return (rep < 10 && match.length > 1) ? \"0\" + rep : \"\" + rep;\n        }\n    });\n}\nfunction dateToStringWithOffset(date, format) {\n    var _a, _b, _c;\n    const d = new Date(date.getTime() + ((_a = date.offset) !== null && _a !== void 0 ? _a : 0));\n    if (typeof format !== \"string\") {\n        return d.toISOString().replace(/\\.\\d+/, \"\").replace(/[A-Z]|\\.\\d+/g, \" \") + dateOffsetToString(((_b = date.offset) !== null && _b !== void 0 ? _b : 0));\n    }\n    else if (format.length === 1) {\n        switch (format) {\n            case \"D\":\n            case \"d\": return dateToHalfUTCString(d, \"first\");\n            case \"T\":\n            case \"t\": return dateToHalfUTCString(d, \"second\");\n            case \"O\":\n            case \"o\": return dateToISOStringWithOffset(d, ((_c = date.offset) !== null && _c !== void 0 ? _c : 0));\n            default: throw new Error(\"Unrecognized Date print format\");\n        }\n    }\n    else {\n        return dateToStringWithCustomFormat(d, format, true);\n    }\n}\nfunction dateToStringWithKind(date, format) {\n    const utc = date.kind === 1 /* UTC */;\n    if (typeof format !== \"string\") {\n        return utc ? date.toUTCString() : date.toLocaleString();\n    }\n    else if (format.length === 1) {\n        switch (format) {\n            case \"D\":\n            case \"d\":\n                return utc ? dateToHalfUTCString(date, \"first\") : date.toLocaleDateString();\n            case \"T\":\n            case \"t\":\n                return utc ? dateToHalfUTCString(date, \"second\") : date.toLocaleTimeString();\n            case \"O\":\n            case \"o\":\n                return dateToISOString(date, utc);\n            default:\n                throw new Error(\"Unrecognized Date print format\");\n        }\n    }\n    else {\n        return dateToStringWithCustomFormat(date, format, utc);\n    }\n}\nexport function toString(date, format, _provider) {\n    return date.offset != null\n        ? dateToStringWithOffset(date, format)\n        : dateToStringWithKind(date, format);\n}\nexport default function DateTime(value, kind) {\n    const d = new Date(value);\n    d.kind = (kind == null ? 0 /* Unspecified */ : kind) | 0;\n    return d;\n}\nexport function fromTicks(ticks, kind) {\n    ticks = fromValue(ticks);\n    kind = kind != null ? kind : 0 /* Unspecified */;\n    let date = DateTime(ticksToUnixEpochMilliseconds(ticks), kind);\n    // Ticks are local to offset (in this case, either UTC or Local/Unknown).\n    // If kind is anything but UTC, that means that the tick number was not\n    // in utc, thus getTime() cannot return UTC, and needs to be shifted.\n    if (kind !== 1 /* UTC */) {\n        date = DateTime(date.getTime() - dateOffset(date), kind);\n    }\n    return date;\n}\nexport function fromDateTimeOffset(date, kind) {\n    var _a;\n    switch (kind) {\n        case 1 /* UTC */: return DateTime(date.getTime(), 1 /* UTC */);\n        case 2 /* Local */: return DateTime(date.getTime(), 2 /* Local */);\n        default:\n            const d = DateTime(date.getTime() + ((_a = date.offset) !== null && _a !== void 0 ? _a : 0), kind);\n            return DateTime(d.getTime() - dateOffset(d), kind);\n    }\n}\nexport function getTicks(date) {\n    return unixEpochMillisecondsToTicks(date.getTime(), dateOffset(date));\n}\nexport function minValue() {\n    // This is \"0001-01-01T00:00:00.000Z\", actual JS min value is -8640000000000000\n    return DateTime(-62135596800000, 0 /* Unspecified */);\n}\nexport function maxValue() {\n    // This is \"9999-12-31T23:59:59.999Z\", actual JS max value is 8640000000000000\n    return DateTime(253402300799999, 0 /* Unspecified */);\n}\nexport function parseRaw(str) {\n    let date = new Date(str);\n    if (isNaN(date.getTime())) {\n        // Try to check strings JS Date cannot parse (see #1045, #1422)\n        // tslint:disable-next-line:max-line-length\n        const m = /^\\s*(\\d+[^\\w\\s:]\\d+[^\\w\\s:]\\d+)?\\s*(\\d+:\\d+(?::\\d+(?:\\.\\d+)?)?)?\\s*([AaPp][Mm])?\\s*([+-]\\d+(?::\\d+)?)?\\s*$/.exec(str);\n        if (m != null) {\n            let baseDate;\n            let timeInSeconds = 0;\n            if (m[2] != null) {\n                const timeParts = m[2].split(\":\");\n                timeInSeconds =\n                    parseInt(timeParts[0], 10) * 3600 +\n                        parseInt(timeParts[1] || \"0\", 10) * 60 +\n                        parseFloat(timeParts[2] || \"0\");\n                if (m[3] != null && m[3].toUpperCase() === \"PM\") {\n                    timeInSeconds += 720;\n                }\n            }\n            if (m[4] != null) { // There's an offset, parse as UTC\n                if (m[1] != null) {\n                    baseDate = new Date(m[1] + \" UTC\");\n                }\n                else {\n                    const d = new Date();\n                    baseDate = new Date(d.getUTCFullYear() + \"/\" + (d.getUTCMonth() + 1) + \"/\" + d.getUTCDate());\n                }\n                const offsetParts = m[4].substr(1).split(\":\");\n                let offsetInMinutes = parseInt(offsetParts[0], 10) * 60 + parseInt(offsetParts[1] || \"0\", 10);\n                if (m[4][0] === \"+\") {\n                    offsetInMinutes *= -1;\n                }\n                timeInSeconds += offsetInMinutes * 60;\n            }\n            else {\n                if (m[1] != null) {\n                    baseDate = new Date(m[1]);\n                }\n                else {\n                    const d = new Date();\n                    baseDate = new Date(d.getFullYear() + \"/\" + (d.getMonth() + 1) + \"/\" + d.getDate());\n                }\n            }\n            date = new Date(baseDate.getTime() + timeInSeconds * 1000);\n            // correct for daylight savings time\n            date = new Date(date.getTime() + (date.getTimezoneOffset() - baseDate.getTimezoneOffset()) * 60000);\n        }\n        else {\n            throw new Error(\"The string is not a valid Date.\");\n        }\n    }\n    return date;\n}\nexport function parse(str, detectUTC = false) {\n    const date = parseRaw(str);\n    const offset = offsetRegex.exec(str);\n    // .NET always parses DateTime as Local if there's offset info (even \"Z\")\n    // Newtonsoft.Json uses UTC if the offset is \"Z\"\n    const kind = offset != null\n        ? (detectUTC && offset[0] === \"Z\" ? 1 /* UTC */ : 2 /* Local */)\n        : 0 /* Unspecified */;\n    return DateTime(date.getTime(), kind);\n}\nexport function tryParse(v, _refValue) {\n    try {\n        // if value is null or whitespace, parsing fails\n        if (v == null || v.trim() === \"\") {\n            return [false, minValue()];\n        }\n        return [true, parse(v)];\n    }\n    catch (_err) {\n        return [false, minValue()];\n    }\n}\nexport function create(year, month, day, h = 0, m = 0, s = 0, ms = 0, kind) {\n    const dateValue = kind === 1 /* UTC */\n        ? Date.UTC(year, month - 1, day, h, m, s, ms)\n        : new Date(year, month - 1, day, h, m, s, ms).getTime();\n    if (isNaN(dateValue)) {\n        throw new Error(\"The parameters describe an unrepresentable Date.\");\n    }\n    const date = DateTime(dateValue, kind);\n    if (year <= 99) {\n        date.setFullYear(year, month - 1, day);\n    }\n    return date;\n}\nexport function now() {\n    return DateTime(Date.now(), 2 /* Local */);\n}\nexport function utcNow() {\n    return DateTime(Date.now(), 1 /* UTC */);\n}\nexport function today() {\n    return date(now());\n}\nexport function isLeapYear(year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n}\nexport function daysInMonth(year, month) {\n    return month === 2\n        ? (isLeapYear(year) ? 29 : 28)\n        : (month >= 8 ? (month % 2 === 0 ? 31 : 30) : (month % 2 === 0 ? 30 : 31));\n}\nexport function toUniversalTime(date) {\n    return date.kind === 1 /* UTC */ ? date : DateTime(date.getTime(), 1 /* UTC */);\n}\nexport function toLocalTime(date) {\n    return date.kind === 2 /* Local */ ? date : DateTime(date.getTime(), 2 /* Local */);\n}\nexport function specifyKind(d, kind) {\n    return create(year(d), month(d), day(d), hour(d), minute(d), second(d), millisecond(d), kind);\n}\nexport function timeOfDay(d) {\n    return hour(d) * 3600000\n        + minute(d) * 60000\n        + second(d) * 1000\n        + millisecond(d);\n}\nexport function date(d) {\n    return create(year(d), month(d), day(d), 0, 0, 0, 0, d.kind);\n}\nexport function day(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCDate() : d.getDate();\n}\nexport function hour(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCHours() : d.getHours();\n}\nexport function millisecond(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCMilliseconds() : d.getMilliseconds();\n}\nexport function minute(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCMinutes() : d.getMinutes();\n}\nexport function month(d) {\n    return (d.kind === 1 /* UTC */ ? d.getUTCMonth() : d.getMonth()) + 1;\n}\nexport function second(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCSeconds() : d.getSeconds();\n}\nexport function year(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCFullYear() : d.getFullYear();\n}\nexport function dayOfWeek(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCDay() : d.getDay();\n}\nexport function dayOfYear(d) {\n    const _year = year(d);\n    const _month = month(d);\n    let _day = day(d);\n    for (let i = 1; i < _month; i++) {\n        _day += daysInMonth(_year, i);\n    }\n    return _day;\n}\nexport function add(d, ts) {\n    const newDate = DateTime(d.getTime() + ts, d.kind);\n    if (d.kind === 2 /* Local */) {\n        const oldTzOffset = d.getTimezoneOffset();\n        const newTzOffset = newDate.getTimezoneOffset();\n        return oldTzOffset !== newTzOffset\n            ? DateTime(newDate.getTime() + (newTzOffset - oldTzOffset) * 60000, d.kind)\n            : newDate;\n    }\n    else {\n        return newDate;\n    }\n}\nexport function addDays(d, v) {\n    return add(d, v * 86400000);\n}\nexport function addHours(d, v) {\n    return add(d, v * 3600000);\n}\nexport function addMinutes(d, v) {\n    return add(d, v * 60000);\n}\nexport function addSeconds(d, v) {\n    return add(d, v * 1000);\n}\nexport function addMilliseconds(d, v) {\n    return add(d, v);\n}\nexport function addYears(d, v) {\n    const newMonth = month(d);\n    const newYear = year(d) + v;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function addMonths(d, v) {\n    let newMonth = month(d) + v;\n    let newMonth_ = 0;\n    let yearOffset = 0;\n    if (newMonth > 12) {\n        newMonth_ = newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12);\n        newMonth = newMonth_;\n    }\n    else if (newMonth < 1) {\n        newMonth_ = 12 + newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12) + (newMonth_ === 12 ? -1 : 0);\n        newMonth = newMonth_;\n    }\n    const newYear = year(d) + yearOffset;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function subtract(d, that) {\n    return typeof that === \"number\"\n        ? add(d, -that)\n        : d.getTime() - that.getTime();\n}\nexport function toLongDateString(d) {\n    return d.toDateString();\n}\nexport function toShortDateString(d) {\n    return d.toLocaleDateString();\n}\nexport function toLongTimeString(d) {\n    return d.toLocaleTimeString();\n}\nexport function toShortTimeString(d) {\n    return d.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\n}\nexport function equals(d1, d2) {\n    return d1.getTime() === d2.getTime();\n}\nexport const compare = compareDates;\nexport const compareTo = compareDates;\nexport function op_Addition(x, y) {\n    return add(x, y);\n}\nexport function op_Subtraction(x, y) {\n    return subtract(x, y);\n}\nexport function isDaylightSavingTime(x) {\n    const jan = new Date(x.getFullYear(), 0, 1);\n    const jul = new Date(x.getFullYear(), 6, 1);\n    return isDST(jan.getTimezoneOffset(), jul.getTimezoneOffset(), x.getTimezoneOffset());\n}\nfunction isDST(janOffset, julOffset, tOffset) {\n    return Math.min(janOffset, julOffset) === tOffset;\n}\n//# sourceMappingURL=Date.js.map","// https://github.com/MikeMcl/big.js/blob/01b3ce3a6b0ba7b42442ea48ec4ffc88d1669ec4/big.mjs\n/* tslint:disable */\nimport { combineHashCodes } from \"../Util\";\n// The shared prototype object.\nvar P = {\n    GetHashCode() { return combineHashCodes([this.s, this.e].concat(this.c)); },\n    Equals(x) { return !this.cmp(x); },\n    CompareTo(x) { return this.cmp(x); },\n};\n/*\n *  big.js v5.2.2\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\n *  Copyright (c) 2018 Michael Mclaughlin <M8ch88l@gmail.com>\n *  https://github.com/MikeMcl/big.js/LICENCE\n */\n/************************************** EDITABLE DEFAULTS *****************************************/\n// The default values below must be integers within the stated ranges.\n/*\n * The maximum number of decimal places (DP) of the results of operations involving division:\n * div and sqrt, and pow with negative exponents.\n */\nvar DP = 28, // 0 to MAX_DP\n/*\n * The rounding mode (RM) used when rounding to the above decimal places.\n *\n *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\n *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\n *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\n *  3  Away from zero.                                  (ROUND_UP)\n */\nRM = 1, // 0, 1, 2 or 3\n// The maximum value of DP and Big.DP.\nMAX_DP = 1E6, // 0 to 1000000\n// The maximum magnitude of the exponent argument to the pow method.\nMAX_POWER = 1E6, // 1 to 1000000\n/*\n * The negative exponent (NE) at and beneath which toString returns exponential notation.\n * (JavaScript numbers: -7)\n * -1000000 is the minimum recommended exponent value of a Big.\n */\nNE = -29, // 0 to -1000000\n/*\n * The positive exponent (PE) at and above which toString returns exponential notation.\n * (JavaScript numbers: 21)\n * 1000000 is the maximum recommended exponent value of a Big.\n * (This limit is not enforced or checked.)\n */\nPE = 29, // 0 to 1000000\n/**************************************************************************************************/\n// Error messages.\nNAME = '[big.js] ', INVALID = NAME + 'Invalid ', INVALID_DP = INVALID + 'decimal places', INVALID_RM = INVALID + 'rounding mode', DIV_BY_ZERO = NAME + 'Division by zero', UNDEFINED = void 0, NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\n/*\n * Create and return a Big constructor.\n *\n */\nfunction _Big_() {\n    /*\n     * The Big constructor and exported function.\n     * Create and return a new instance of a Big number object.\n     *\n     * n {number|string|Big} A numeric value.\n     */\n    function Big(n) {\n        var x = this;\n        // Enable constructor usage without new.\n        if (!(x instanceof Big))\n            return n === UNDEFINED ? _Big_() : new Big(n);\n        // Duplicate.\n        if (n instanceof Big) {\n            x.s = n.s;\n            x.e = n.e;\n            x.c = n.c.slice();\n            normalize(x);\n        }\n        else {\n            parse(x, n);\n        }\n        /*\n         * Retain a reference to this Big constructor, and shadow Big.prototype.constructor which\n         * points to Object.\n         */\n        x.constructor = Big;\n    }\n    Big.prototype = P;\n    Big.DP = DP;\n    Big.RM = RM;\n    Big.NE = NE;\n    Big.PE = PE;\n    Big.version = '5.2.2';\n    return Big;\n}\nfunction normalize(x) {\n    x = round(x, DP, 0);\n    if (x.c.length > 1 && !x.c[0]) {\n        let i = x.c.findIndex(x => x);\n        x.c = x.c.slice(i);\n        x.e = x.e - i;\n    }\n}\n/*\n * Parse the number or string value passed to a Big constructor.\n *\n * x {Big} A Big number instance.\n * n {number|string} A numeric value.\n */\nfunction parse(x, n) {\n    var e, i, nl;\n    // Minus zero?\n    if (n === 0 && 1 / n < 0)\n        n = '-0';\n    else if (!NUMERIC.test(n += ''))\n        throw Error(INVALID + 'number');\n    // Determine sign.\n    x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;\n    // Decimal point?\n    if ((e = n.indexOf('.')) > -1)\n        n = n.replace('.', '');\n    // Exponential form?\n    if ((i = n.search(/e/i)) > 0) {\n        // Determine exponent.\n        if (e < 0)\n            e = i;\n        e += +n.slice(i + 1);\n        n = n.substring(0, i);\n    }\n    else if (e < 0) {\n        // Integer.\n        e = n.length;\n    }\n    nl = n.length;\n    // Determine leading zeros before decimal point.\n    for (i = 0; i < e && i < nl && n.charAt(i) == '0';)\n        ++i;\n    // older version (ignores decimal point).\n    // // Determine leading zeros.\n    // for (i = 0; i < nl && n.charAt(i) == '0';) ++i;\n    if (i == nl) {\n        // Zero.\n        x.c = [x.e = 0];\n    }\n    else {\n        x.e = e - i - 1;\n        x.c = [];\n        // Convert string to array of digits without leading zeros\n        for (e = 0; i < nl;)\n            x.c[e++] = +n.charAt(i++);\n        // older version (doesn't keep trailing zeroes).\n        // // Determine trailing zeros.\n        // for (; nl > 0 && n.charAt(--nl) == '0';);\n        // // Convert string to array of digits without leading/trailing zeros.\n        // for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);\n    }\n    x = round(x, Big.DP, Big.RM);\n    return x;\n}\n/*\n * Round Big x to a maximum of dp decimal places using rounding mode rm.\n * Called by stringify, P.div, P.round and P.sqrt.\n *\n * x {Big} The Big to round.\n * dp {number} Integer, 0 to MAX_DP inclusive.\n * rm {number} 0, 1, 2 or 3 (DOWN, HALF_UP, HALF_EVEN, UP)\n * [more] {boolean} Whether the result of division was truncated.\n */\nfunction round(x, dp, rm, more) {\n    var xc = x.c, i = x.e + dp + 1;\n    if (i < xc.length) {\n        if (rm === 1) {\n            // xc[i] is the digit after the digit that may be rounded up.\n            more = xc[i] >= 5;\n        }\n        else if (rm === 2) {\n            more = xc[i] > 5 || xc[i] == 5 &&\n                (more || i < 0 || xc[i + 1] !== UNDEFINED || xc[i - 1] & 1);\n        }\n        else if (rm === 3) {\n            more = more || !!xc[0];\n        }\n        else {\n            more = false;\n            if (rm !== 0)\n                throw Error(INVALID_RM);\n        }\n        if (i < 1) {\n            xc.length = 1;\n            if (more) {\n                // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                x.e = -dp;\n                xc[0] = 1;\n            }\n            else {\n                // Zero.\n                xc[0] = x.e = 0;\n            }\n        }\n        else {\n            // Remove any digits after the required decimal places.\n            xc.length = i--;\n            // Round up?\n            if (more) {\n                // Rounding up may mean the previous digit has to be rounded up.\n                for (; ++xc[i] > 9;) {\n                    xc[i] = 0;\n                    if (!i--) {\n                        ++x.e;\n                        xc.unshift(1);\n                    }\n                }\n            }\n            // Remove trailing zeros.\n            for (i = xc.length; !xc[--i];)\n                xc.pop();\n        }\n    }\n    else if (rm < 0 || rm > 3 || rm !== ~~rm) {\n        throw Error(INVALID_RM);\n    }\n    return x;\n}\n/*\n * Return a string representing the value of Big x in normal or exponential notation.\n * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\n *\n * x {Big}\n * id? {number} Caller id.\n *         1 toExponential\n *         2 toFixed\n *         3 toPrecision\n *         4 valueOf\n * n? {number|undefined} Caller's argument.\n * k? {number|undefined}\n */\nfunction stringify(x, id, n, k) {\n    var e, s, Big = x.constructor, z = !x.c[0];\n    if (n !== UNDEFINED) {\n        if (n !== ~~n || n < (id == 3) || n > MAX_DP) {\n            throw Error(id == 3 ? INVALID + 'precision' : INVALID_DP);\n        }\n        x = new Big(x);\n        // The index of the digit that may be rounded up.\n        n = k - x.e;\n        // Round?\n        if (x.c.length > ++k)\n            round(x, n, Big.RM);\n        // toFixed: recalculate k as x.e may have changed if value rounded up.\n        if (id == 2)\n            k = x.e + n + 1;\n        // Append zeros?\n        for (; x.c.length < k;)\n            x.c.push(0);\n    }\n    e = x.e;\n    s = x.c.join('');\n    n = s.length;\n    // Exponential notation?\n    if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big.NE || e >= Big.PE)) {\n        s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;\n        // Normal notation.\n    }\n    else if (e < 0) {\n        for (; ++e;)\n            s = '0' + s;\n        s = '0.' + s;\n    }\n    else if (e > 0) {\n        if (++e > n)\n            for (e -= n; e--;)\n                s += '0';\n        else if (e < n)\n            s = s.slice(0, e) + '.' + s.slice(e);\n    }\n    else if (n > 1) {\n        s = s.charAt(0) + '.' + s.slice(1);\n    }\n    return x.s < 0 && (!z || id == 4) ? '-' + s : s;\n}\n// Prototype/instance methods\n/*\n * Return a new Big whose value is the absolute value of this Big.\n */\nP.abs = function () {\n    var x = new this.constructor(this);\n    x.s = 1;\n    return x;\n};\n/*\n * Return 1 if the value of this Big is greater than the value of Big y,\n *       -1 if the value of this Big is less than the value of Big y, or\n *        0 if they have the same value.\n*/\nP.cmp = function (y) {\n    var isneg, Big = this.constructor, x = new Big(this), y = new Big(y), xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0])\n        return !xc[0] ? !yc[0] ? 0 : -j : i;\n    // Signs differ?\n    if (i != j)\n        return i;\n    isneg = i < 0;\n    // Compare exponents.\n    if (k != l)\n        return k > l ^ isneg ? 1 : -1;\n    // Compare digit by digit.\n    j = Math.max(xc.length, yc.length);\n    for (i = 0; i < j; i++) {\n        k = i < xc.length ? xc[i] : 0;\n        l = i < yc.length ? yc[i] : 0;\n        if (k != l)\n            return k > l ^ isneg ? 1 : -1;\n    }\n    return 0;\n    // old version (doesn't compare well trailing zeroes, e.g. 1.0 with 1.00)\n    // j = (k = xc.length) < (l = yc.length) ? k : l;\n    // // Compare digit by digit.\n    // for (i = -1; ++i < j;) {\n    //   if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\n    // }\n    // // Compare lengths.\n    // return k == l ? 0 : k > l ^ isneg ? 1 : -1;\n};\n/*\n * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\n * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\n */\nP.div = function (y) {\n    var Big = this.constructor, x = new Big(this), y = new Big(y), a = x.c, // dividend\n    b = y.c, // divisor\n    k = x.s == y.s ? 1 : -1, dp = Big.DP;\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP)\n        throw Error(INVALID_DP);\n    // Divisor is zero?\n    if (!b[0])\n        throw Error(DIV_BY_ZERO);\n    // Dividend is 0? Return +-0.\n    if (!a[0])\n        return new Big(k * 0);\n    var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), // remainder\n    rl = r.length, q = y, // quotient\n    qc = q.c = [], qi = 0, d = dp + (q.e = x.e - y.e) + 1; // number of digits of the result\n    q.s = k;\n    k = d < 0 ? 0 : d;\n    // Create version of divisor with leading zero.\n    bz.unshift(0);\n    // Add zeros to make remainder as long as divisor.\n    for (; rl++ < bl;)\n        r.push(0);\n    do {\n        // n is how many times the divisor goes into current remainder.\n        for (n = 0; n < 10; n++) {\n            // Compare divisor and remainder.\n            if (bl != (rl = r.length)) {\n                cmp = bl > rl ? 1 : -1;\n            }\n            else {\n                for (ri = -1, cmp = 0; ++ri < bl;) {\n                    if (b[ri] != r[ri]) {\n                        cmp = b[ri] > r[ri] ? 1 : -1;\n                        break;\n                    }\n                }\n            }\n            // If divisor < remainder, subtract divisor from remainder.\n            if (cmp < 0) {\n                // Remainder can't be more than 1 digit longer than divisor.\n                // Equalise lengths using divisor with extra leading zero?\n                for (bt = rl == bl ? b : bz; rl;) {\n                    if (r[--rl] < bt[rl]) {\n                        ri = rl;\n                        for (; ri && !r[--ri];)\n                            r[ri] = 9;\n                        --r[ri];\n                        r[rl] += 10;\n                    }\n                    r[rl] -= bt[rl];\n                }\n                for (; !r[0];)\n                    r.shift();\n            }\n            else {\n                break;\n            }\n        }\n        // Add the digit n to the result array.\n        qc[qi++] = cmp ? n : ++n;\n        // Update the remainder.\n        if (r[0] && cmp)\n            r[rl] = a[ai] || 0;\n        else\n            r = [a[ai]];\n    } while ((ai++ < al || r[0] !== UNDEFINED) && k--);\n    // Leading zero? Do not remove if result is simply zero (qi == 1).\n    if (!qc[0] && qi != 1) {\n        // There can't be more than one zero.\n        qc.shift();\n        q.e--;\n    }\n    // Round?\n    if (qi > d)\n        round(q, dp, Big.RM, r[0] !== UNDEFINED);\n    return q;\n};\n/*\n * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\n */\nP.eq = function (y) {\n    return !this.cmp(y);\n};\n/*\n * Return true if the value of this Big is greater than the value of Big y, otherwise return\n * false.\n */\nP.gt = function (y) {\n    return this.cmp(y) > 0;\n};\n/*\n * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\n * return false.\n */\nP.gte = function (y) {\n    return this.cmp(y) > -1;\n};\n/*\n * Return true if the value of this Big is less than the value of Big y, otherwise return false.\n */\nP.lt = function (y) {\n    return this.cmp(y) < 0;\n};\n/*\n * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\n * return false.\n */\nP.lte = function (y) {\n    return this.cmp(y) < 1;\n};\n/*\n * Return a new Big whose value is the value of this Big minus the value of Big y.\n */\nP.minus = P.sub = function (y) {\n    var i, j, t, xlty, Big = this.constructor, x = new Big(this), y = new Big(y), a = x.s, b = y.s;\n    // Signs differ?\n    if (a != b) {\n        y.s = -b;\n        return x.plus(y);\n    }\n    var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0]) {\n        // y is non-zero? x is non-zero? Or both are zero.\n        return yc[0] ? (y.s = -b, y) : new Big(xc[0] ? x : 0);\n    }\n    // Determine which is the bigger number. Prepend zeros to equalise exponents.\n    if (a = xe - ye) {\n        if (xlty = a < 0) {\n            a = -a;\n            t = xc;\n        }\n        else {\n            ye = xe;\n            t = yc;\n        }\n        t.reverse();\n        for (b = a; b--;)\n            t.push(0);\n        t.reverse();\n    }\n    else {\n        // Exponents equal. Check digit by digit.\n        j = ((xlty = xc.length < yc.length) ? xc : yc).length;\n        for (a = b = 0; b < j; b++) {\n            if (xc[b] != yc[b]) {\n                xlty = xc[b] < yc[b];\n                break;\n            }\n        }\n    }\n    // x < y? Point xc to the array of the bigger number.\n    if (xlty) {\n        t = xc;\n        xc = yc;\n        yc = t;\n        y.s = -y.s;\n    }\n    /*\n     * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\n     * needs to start at yc.length.\n     */\n    if ((b = (j = yc.length) - (i = xc.length)) > 0)\n        for (; b--;)\n            xc[i++] = 0;\n    // Subtract yc from xc.\n    for (b = i; j > a;) {\n        if (xc[--j] < yc[j]) {\n            for (i = j; i && !xc[--i];)\n                xc[i] = 9;\n            --xc[i];\n            xc[j] += 10;\n        }\n        xc[j] -= yc[j];\n    }\n    // Remove trailing zeros.\n    for (; xc[--b] === 0;)\n        xc.pop();\n    // Remove leading zeros and adjust exponent accordingly.\n    for (; xc[0] === 0;) {\n        xc.shift();\n        --ye;\n    }\n    if (!xc[0]) {\n        // n - n = +0\n        y.s = 1;\n        // Result must be zero.\n        xc = [ye = 0];\n    }\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\n * Return a new Big whose value is the value of this Big modulo the value of Big y.\n */\nP.mod = function (y) {\n    var ygtx, Big = this.constructor, x = new Big(this), y = new Big(y), a = x.s, b = y.s;\n    if (!y.c[0])\n        throw Error(DIV_BY_ZERO);\n    x.s = y.s = 1;\n    ygtx = y.cmp(x) == 1;\n    x.s = a;\n    y.s = b;\n    if (ygtx)\n        return new Big(x);\n    a = Big.DP;\n    b = Big.RM;\n    Big.DP = Big.RM = 0;\n    x = x.div(y);\n    Big.DP = a;\n    Big.RM = b;\n    return this.minus(x.times(y));\n};\n/*\n * Return a new Big whose value is the value of this Big plus the value of Big y.\n */\nP.plus = P.add = function (y) {\n    var t, Big = this.constructor, x = new Big(this), y = new Big(y), a = x.s, b = y.s;\n    // Signs differ?\n    if (a != b) {\n        y.s = -b;\n        return x.minus(y);\n    }\n    var xe = x.e, xc = x.c, ye = y.e, yc = y.c;\n    // Either zero? y is non-zero? x is non-zero? Or both are zero.\n    if (!xc[0] || !yc[0])\n        return yc[0] ? y : new Big(xc[0] ? x : a * 0);\n    xc = xc.slice();\n    // Prepend zeros to equalise exponents.\n    // Note: reverse faster than unshifts.\n    if (a = xe - ye) {\n        if (a > 0) {\n            ye = xe;\n            t = yc;\n        }\n        else {\n            a = -a;\n            t = xc;\n        }\n        t.reverse();\n        for (; a--;)\n            t.push(0);\n        t.reverse();\n    }\n    // Point xc to the longer array.\n    if (xc.length - yc.length < 0) {\n        t = yc;\n        yc = xc;\n        xc = t;\n    }\n    a = yc.length;\n    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\n    for (b = 0; a; xc[a] %= 10)\n        b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n    if (b) {\n        xc.unshift(b);\n        ++ye;\n    }\n    // Remove trailing zeros.\n    for (a = xc.length; xc[--a] === 0;)\n        xc.pop();\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\n * Return a Big whose value is the value of this Big raised to the power n.\n * If n is negative, round to a maximum of Big.DP decimal places using rounding\n * mode Big.RM.\n *\n * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\n */\nP.pow = function (n) {\n    var Big = this.constructor, x = new Big(this), y = new Big(1), one = new Big(1), isneg = n < 0;\n    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER)\n        throw Error(INVALID + 'exponent');\n    if (isneg)\n        n = -n;\n    for (;;) {\n        if (n & 1)\n            y = y.times(x);\n        n >>= 1;\n        if (!n)\n            break;\n        x = x.times(x);\n    }\n    return isneg ? one.div(y) : y;\n};\n/*\n * Return a new Big whose value is the value of this Big rounded using rounding mode rm\n * to a maximum of dp decimal places, or, if dp is negative, to an integer which is a\n * multiple of 10**-dp.\n * If dp is not specified, round to 0 decimal places.\n * If rm is not specified, use Big.RM.\n *\n * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\n * rm? 0, 1, 2 or 3 (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_UP)\n */\nP.round = function (dp, rm) {\n    var Big = this.constructor;\n    if (dp === UNDEFINED)\n        dp = 0;\n    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP)\n        throw Error(INVALID_DP);\n    return round(new Big(this), dp, rm === UNDEFINED ? Big.RM : rm);\n};\n/*\n * Return a new Big whose value is the square root of the value of this Big, rounded, if\n * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\n */\nP.sqrt = function () {\n    var r, c, t, Big = this.constructor, x = new Big(this), s = x.s, e = x.e, half = new Big(0.5);\n    // Zero?\n    if (!x.c[0])\n        return new Big(x);\n    // Negative?\n    if (s < 0)\n        throw Error(NAME + 'No square root');\n    // Estimate.\n    s = Math.sqrt(x + '');\n    // Math.sqrt underflow/overflow?\n    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\n    if (s === 0 || s === 1 / 0) {\n        c = x.c.join('');\n        if (!(c.length + e & 1))\n            c += '0';\n        s = Math.sqrt(c);\n        e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\n        r = new Big((s == 1 / 0 ? '1e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);\n    }\n    else {\n        r = new Big(s);\n    }\n    e = r.e + (Big.DP += 4);\n    // Newton-Raphson iteration.\n    do {\n        t = r;\n        r = half.times(t.plus(x.div(t)));\n    } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));\n    return round(r, Big.DP -= 4, Big.RM);\n};\n/*\n * Return a new Big whose value is the value of this Big times the value of Big y.\n */\nP.times = P.mul = function (y) {\n    var c, Big = this.constructor, x = new Big(this), y = new Big(y), xc = x.c, yc = y.c, a = xc.length, b = yc.length, i = x.e, j = y.e;\n    // Determine sign of result.\n    y.s = x.s == y.s ? 1 : -1;\n    // Return signed 0 if either 0.\n    if (!xc[0] || !yc[0])\n        return new Big(y.s * 0);\n    // Initialise exponent of result as x.e + y.e.\n    y.e = i + j;\n    // If array xc has fewer digits than yc, swap xc and yc, and lengths.\n    if (a < b) {\n        c = xc;\n        xc = yc;\n        yc = c;\n        j = a;\n        a = b;\n        b = j;\n    }\n    // Initialise coefficient array of result with zeros.\n    for (c = new Array(j = a + b); j--;)\n        c[j] = 0;\n    // Multiply.\n    // i is initially xc.length.\n    for (i = b; i--;) {\n        b = 0;\n        // a is yc.length.\n        for (j = a + i; j > i;) {\n            // Current sum of products at this digit position, plus carry.\n            b = c[j] + yc[i] * xc[j - i - 1] + b;\n            c[j--] = b % 10;\n            // carry\n            b = b / 10 | 0;\n        }\n        c[j] = (c[j] + b) % 10;\n    }\n    // Increment result exponent if there is a final carry, otherwise remove leading zero.\n    if (b)\n        ++y.e;\n    else\n        c.shift();\n    // Remove trailing zeros.\n    for (i = c.length; !c[--i];)\n        c.pop();\n    y.c = c;\n    return y;\n};\n/*\n * Return a string representing the value of this Big in exponential notation to dp fixed decimal\n * places and rounded using Big.RM.\n *\n * dp? {number} Integer, 0 to MAX_DP inclusive.\n */\nP.toExponential = function (dp) {\n    return stringify(this, 1, dp, dp);\n};\n/*\n * Return a string representing the value of this Big in normal notation to dp fixed decimal\n * places and rounded using Big.RM.\n *\n * dp? {number} Integer, 0 to MAX_DP inclusive.\n *\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\n */\nP.toFixed = function (dp) {\n    return stringify(this, 2, dp, this.e + dp);\n};\n/*\n * Return a string representing the value of this Big rounded to sd significant digits using\n * Big.RM. Use exponential notation if sd is less than the number of digits necessary to represent\n * the integer part of the value in normal notation.\n *\n * sd {number} Integer, 1 to MAX_DP inclusive.\n */\nP.toPrecision = function (sd) {\n    return stringify(this, 3, sd, sd - 1);\n};\n/*\n * Return a string representing the value of this Big.\n * Return exponential notation if this Big has a positive exponent equal to or greater than\n * Big.PE, or a negative exponent equal to or less than Big.NE.\n * Omit the sign for negative zero.\n */\nP.toString = function () {\n    return stringify(this);\n};\n/*\n * Return a string representing the value of this Big.\n * Return exponential notation if this Big has a positive exponent equal to or greater than\n * Big.PE, or a negative exponent equal to or less than Big.NE.\n * Include the sign for negative zero.\n */\nP.valueOf = P.toJSON = function () {\n    return stringify(this, 4);\n};\n// Export\nexport var Big = _Big_();\nexport default Big;\n//# sourceMappingURL=big.js.map","import Decimal from \"./lib/big\";\nexport default Decimal;\nexport const get_Zero = new Decimal(0);\nexport const get_One = new Decimal(1);\nexport const get_MinusOne = new Decimal(-1);\nexport const get_MaxValue = new Decimal(\"79228162514264337593543950335\");\nexport const get_MinValue = new Decimal(\"-79228162514264337593543950335\");\nexport function compare(x, y) {\n    return x.cmp(y);\n}\nexport function equals(x, y) {\n    return !x.cmp(y);\n}\nexport function abs(x) {\n    return x.abs();\n}\nexport function round(x, digits = 0) {\n    return x.round(digits, 2 /* ROUND_HALF_EVEN */);\n}\nexport function truncate(x) {\n    return x.round(0, 0 /* ROUND_DOWN */);\n}\nexport function ceiling(x) {\n    return x.round(0, x.cmp(0) >= 0 ? 3 /* ROUND_UP */ : 0 /* ROUND_DOWN */);\n}\nexport function floor(x) {\n    return x.round(0, x.cmp(0) >= 0 ? 0 /* ROUND_DOWN */ : 3 /* ROUND_UP */);\n}\nexport function pow(x, n) {\n    return x.pow(n);\n}\nexport function sqrt(x) {\n    return x.sqrt();\n}\nexport function op_Addition(x, y) {\n    return x.add(y);\n}\nexport function op_Subtraction(x, y) {\n    return x.sub(y);\n}\nexport function op_Multiply(x, y) {\n    return x.mul(y);\n}\nexport function op_Division(x, y) {\n    return x.div(y);\n}\nexport function op_Modulus(x, y) {\n    return x.mod(y);\n}\nexport function op_UnaryNegation(x) {\n    const x2 = new Decimal(x);\n    x2.s = -x2.s || 0;\n    return x2;\n}\nexport const add = op_Addition;\nexport const subtract = op_Subtraction;\nexport const multiply = op_Multiply;\nexport const divide = op_Division;\nexport const remainder = op_Modulus;\nexport const negate = op_UnaryNegation;\nexport function toString(x) {\n    return x.toString();\n}\nexport function tryParse(str) {\n    try {\n        return [true, new Decimal(str.trim())];\n    }\n    catch (_a) {\n        return [false, get_Zero];\n    }\n}\nexport function parse(str) {\n    const [ok, value] = tryParse(str);\n    if (ok) {\n        return value;\n    }\n    else {\n        throw new Error(\"Input string was not in a correct format.\");\n    }\n}\nexport function toNumber(x) {\n    return +x;\n}\nfunction decimalToHex(dec, bitSize) {\n    const hex = new Uint8Array(bitSize / 4 | 0);\n    let hexCount = 1;\n    for (let d = 0; d < dec.length; d++) {\n        let value = dec[d];\n        for (let i = 0; i < hexCount; i++) {\n            const digit = hex[i] * 10 + value | 0;\n            hex[i] = digit & 0xF;\n            value = digit >> 4;\n        }\n        if (value !== 0) {\n            hex[hexCount++] = value;\n        }\n    }\n    return hex.slice(0, hexCount); // digits in reverse order\n}\nfunction hexToDecimal(hex, bitSize) {\n    const dec = new Uint8Array(bitSize * 301 / 1000 + 1 | 0);\n    let decCount = 1;\n    for (let d = hex.length - 1; d >= 0; d--) {\n        let carry = hex[d];\n        for (let i = 0; i < decCount; i++) {\n            const val = dec[i] * 16 + carry | 0;\n            dec[i] = (val % 10) | 0;\n            carry = (val / 10) | 0;\n        }\n        while (carry > 0) {\n            dec[decCount++] = (carry % 10) | 0;\n            carry = (carry / 10) | 0;\n        }\n    }\n    return dec.slice(0, decCount); // digits in reverse order\n}\nfunction setInt32Bits(hexDigits, bits, offset) {\n    for (let i = 0; i < 8; i++) {\n        hexDigits[offset + i] = (bits >> (i * 4)) & 0xF;\n    }\n}\nfunction getInt32Bits(hexDigits, offset) {\n    let bits = 0;\n    for (let i = 0; i < 8; i++) {\n        bits = bits | (hexDigits[offset + i] << (i * 4));\n    }\n    return bits;\n}\nexport function fromIntArray(bits) {\n    return fromInts(bits[0], bits[1], bits[2], bits[3]);\n}\nexport function fromInts(low, mid, high, signExp) {\n    const isNegative = signExp < 0;\n    const scale = (signExp >> 16) & 0x7F;\n    return fromParts(low, mid, high, isNegative, scale);\n}\nexport function fromParts(low, mid, high, isNegative, scale) {\n    const bitSize = 96;\n    const hexDigits = new Uint8Array(bitSize / 4);\n    setInt32Bits(hexDigits, low, 0);\n    setInt32Bits(hexDigits, mid, 8);\n    setInt32Bits(hexDigits, high, 16);\n    const decDigits = hexToDecimal(hexDigits, bitSize);\n    scale = scale & 0x7F;\n    const big = new Decimal(0);\n    big.c = Array.from(decDigits.reverse());\n    big.e = decDigits.length - scale - 1;\n    big.s = isNegative ? -1 : 1;\n    const d = new Decimal(big);\n    return d;\n}\nexport function getBits(d) {\n    const bitSize = 96;\n    const decDigits = Uint8Array.from(d.c);\n    const hexDigits = decimalToHex(decDigits, bitSize);\n    const low = getInt32Bits(hexDigits, 0);\n    const mid = getInt32Bits(hexDigits, 8);\n    const high = getInt32Bits(hexDigits, 16);\n    const decStr = d.toString();\n    const dotPos = decStr.indexOf(\".\");\n    const scale = dotPos < 0 ? 0 : decStr.length - dotPos - 1;\n    const signExp = ((scale & 0x7F) << 16) | (d.s < 0 ? 0x80000000 : 0);\n    return [low, mid, high, signExp];\n}\nexport function makeRangeStepFunction(step, last) {\n    const stepComparedWithZero = step.cmp(get_Zero);\n    if (stepComparedWithZero === 0) {\n        throw new Error(\"The step of a range cannot be zero\");\n    }\n    const stepGreaterThanZero = stepComparedWithZero > 0;\n    return (x) => {\n        const comparedWithLast = x.cmp(last);\n        if ((stepGreaterThanZero && comparedWithLast <= 0)\n            || (!stepGreaterThanZero && comparedWithLast >= 0)) {\n            return [x, op_Addition(x, step)];\n        }\n        else {\n            return undefined;\n        }\n    };\n}\n//# sourceMappingURL=Decimal.js.map","export function create(pattern, options = 0) {\n    // Supported RegexOptions\n    // * IgnoreCase:  0x0001\n    // * Multiline:   0x0002\n    // * Singleline:  0x0010\n    // * ECMAScript:  0x0100 (ignored)\n    if ((options & ~(1 ^ 2 ^ 16 ^ 256)) !== 0) {\n        throw new Error(\"RegexOptions only supports: IgnoreCase, Multiline, Singleline and ECMAScript\");\n    }\n    let flags = \"g\";\n    flags += options & 1 ? \"i\" : \"\"; // 0x0001 RegexOptions.IgnoreCase\n    flags += options & 2 ? \"m\" : \"\";\n    flags += options & 16 ? \"s\" : \"\";\n    return new RegExp(pattern, flags);\n}\n// From http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex\nexport function escape(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\nexport function unescape(str) {\n    return str.replace(/\\\\([\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|])/g, \"$1\");\n}\nexport function isMatch(str, pattern, options = 0) {\n    let reg;\n    reg = str instanceof RegExp\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\n        : reg = create(pattern, options);\n    return reg.test(str);\n}\nexport function match(str, pattern, options = 0) {\n    let reg;\n    reg = str instanceof RegExp\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\n        : reg = create(pattern, options);\n    return reg.exec(str);\n}\nexport function matches(str, pattern, options = 0) {\n    let reg;\n    reg = str instanceof RegExp\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\n        : reg = create(pattern, options);\n    if (!reg.global) {\n        throw new Error(\"Non-global RegExp\"); // Prevent infinite loop\n    }\n    let m = reg.exec(str);\n    const matches = [];\n    while (m !== null) {\n        matches.push(m);\n        m = reg.exec(str);\n    }\n    return matches;\n}\nexport function options(reg) {\n    let options = 256; // ECMAScript\n    options |= reg.ignoreCase ? 1 : 0;\n    options |= reg.multiline ? 2 : 0;\n    return options;\n}\nexport function replace(reg, input, replacement, limit, offset = 0) {\n    function replacer() {\n        let res = arguments[0];\n        if (limit) {\n            limit--;\n            const match = [];\n            const len = arguments.length;\n            for (let i = 0; i < len - 2; i++) {\n                match.push(arguments[i]);\n            }\n            match.index = arguments[len - 2];\n            match.input = arguments[len - 1];\n            res = replacement(match);\n        }\n        return res;\n    }\n    if (typeof reg === \"string\") {\n        const tmp = reg;\n        reg = create(input, limit !== null && limit !== void 0 ? limit : 0);\n        input = tmp;\n        limit = undefined;\n    }\n    if (typeof replacement === \"function\") {\n        limit = limit == null ? -1 : limit;\n        return input.substring(0, offset) + input.substring(offset).replace(reg, replacer);\n    }\n    else {\n        // $0 doesn't work with JS regex, see #1155\n        replacement = replacement.replace(/\\$0/g, (_s) => \"$&\");\n        if (limit != null) {\n            let m;\n            const sub1 = input.substring(offset);\n            const _matches = matches(reg, sub1);\n            const sub2 = matches.length > limit ? (m = _matches[limit - 1], sub1.substring(0, m.index + m[0].length)) : sub1;\n            return input.substring(0, offset) + sub2.replace(reg, replacement)\n                + input.substring(offset + sub2.length);\n        }\n        else {\n            return input.replace(reg, replacement);\n        }\n    }\n}\nexport function split(reg, input, limit, offset = 0) {\n    if (typeof reg === \"string\") {\n        const tmp = reg;\n        reg = create(input, limit !== null && limit !== void 0 ? limit : 0);\n        input = tmp;\n        limit = undefined;\n    }\n    input = input.substring(offset);\n    return input.split(reg, limit);\n}\n//# sourceMappingURL=RegExp.js.map","import { toString as dateToString } from \"./Date\";\nimport Decimal from \"./Decimal\";\nimport Long, * as _Long from \"./Long\";\nimport { escape } from \"./RegExp\";\nconst fsFormatRegExp = /(^|[^%])%([0+\\- ]*)(\\d+)?(?:\\.(\\d+))?(\\w)/;\nconst formatRegExp = /\\{(\\d+)(,-?\\d+)?(?:\\:([a-zA-Z])(\\d{0,2})|\\:(.+?))?\\}/g;\n// RFC 4122 compliant. From https://stackoverflow.com/a/13653180/3922220\n// const guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/;\n// Relax GUID parsing, see #1637\nconst guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;\n// These are used for formatting and only take longs and decimals into account (no bigint)\nfunction isNumeric(x) {\n    return typeof x === \"number\" || x instanceof Long || x instanceof Decimal;\n}\nfunction isLessThan(x, y) {\n    if (x instanceof Long) {\n        return _Long.compare(x, y) < 0;\n    }\n    else if (x instanceof Decimal) {\n        return x.cmp(y) < 0;\n    }\n    else {\n        return x < y;\n    }\n}\nfunction multiply(x, y) {\n    if (x instanceof Long) {\n        return _Long.op_Multiply(x, y);\n    }\n    else if (x instanceof Decimal) {\n        return x.mul(y);\n    }\n    else {\n        return x * y;\n    }\n}\nfunction toFixed(x, dp) {\n    if (x instanceof Long) {\n        return String(x) + (0).toFixed(dp).substr(1);\n    }\n    else {\n        return x.toFixed(dp);\n    }\n}\nfunction toPrecision(x, sd) {\n    if (x instanceof Long) {\n        return String(x) + (0).toPrecision(sd).substr(1);\n    }\n    else {\n        return x.toPrecision(sd);\n    }\n}\nfunction toExponential(x, dp) {\n    if (x instanceof Long) {\n        return String(x) + (0).toExponential(dp).substr(1);\n    }\n    else {\n        return x.toExponential(dp);\n    }\n}\nfunction cmp(x, y, ic) {\n    function isIgnoreCase(i) {\n        return i === true ||\n            i === 1 /* CurrentCultureIgnoreCase */ ||\n            i === 3 /* InvariantCultureIgnoreCase */ ||\n            i === 5 /* OrdinalIgnoreCase */;\n    }\n    function isOrdinal(i) {\n        return i === 4 /* Ordinal */ ||\n            i === 5 /* OrdinalIgnoreCase */;\n    }\n    if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    if (y == null) {\n        return 1;\n    } // everything is bigger than null\n    if (isOrdinal(ic)) {\n        if (isIgnoreCase(ic)) {\n            x = x.toLowerCase();\n            y = y.toLowerCase();\n        }\n        return (x === y) ? 0 : (x < y ? -1 : 1);\n    }\n    else {\n        if (isIgnoreCase(ic)) {\n            x = x.toLocaleLowerCase();\n            y = y.toLocaleLowerCase();\n        }\n        return x.localeCompare(y);\n    }\n}\nexport function compare(...args) {\n    switch (args.length) {\n        case 2: return cmp(args[0], args[1], false);\n        case 3: return cmp(args[0], args[1], args[2]);\n        case 4: return cmp(args[0], args[1], args[2] === true);\n        case 5: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), false);\n        case 6: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5]);\n        case 7: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5] === true);\n        default: throw new Error(\"String.compare: Unsupported number of parameters\");\n    }\n}\nexport function compareOrdinal(x, y) {\n    return cmp(x, y, 4 /* Ordinal */);\n}\nexport function compareTo(x, y) {\n    return cmp(x, y, 0 /* CurrentCulture */);\n}\nexport function startsWith(str, pattern, ic) {\n    if (str.length >= pattern.length) {\n        return cmp(str.substr(0, pattern.length), pattern, ic) === 0;\n    }\n    return false;\n}\nexport function indexOfAny(str, anyOf, ...args) {\n    if (str == null || str === \"\") {\n        return -1;\n    }\n    const startIndex = (args.length > 0) ? args[0] : 0;\n    if (startIndex < 0) {\n        throw new Error(\"Start index cannot be negative\");\n    }\n    const length = (args.length > 1) ? args[1] : str.length - startIndex;\n    if (length < 0) {\n        throw new Error(\"Length cannot be negative\");\n    }\n    if (length > str.length - startIndex) {\n        throw new Error(\"Invalid startIndex and length\");\n    }\n    str = str.substr(startIndex, length);\n    for (const c of anyOf) {\n        const index = str.indexOf(c);\n        if (index > -1) {\n            return index + startIndex;\n        }\n    }\n    return -1;\n}\nfunction toHex(x) {\n    if (x instanceof Long) {\n        return _Long.toString(x.unsigned ? x : _Long.fromBytes(_Long.toBytes(x), true), 16);\n    }\n    else {\n        return (Number(x) >>> 0).toString(16);\n    }\n}\nexport function printf(input) {\n    return {\n        input,\n        cont: fsFormat(input),\n    };\n}\nexport function toConsole(arg) {\n    // Don't remove the lambda here, see #1357\n    return arg.cont((x) => { console.log(x); });\n}\nexport function toConsoleError(arg) {\n    return arg.cont((x) => { console.error(x); });\n}\nexport function toText(arg) {\n    return arg.cont((x) => x);\n}\nexport function toFail(arg) {\n    return arg.cont((x) => { throw new Error(x); });\n}\nfunction formatOnce(str2, rep) {\n    return str2.replace(fsFormatRegExp, (_, prefix, flags, padLength, precision, format) => {\n        let sign = \"\";\n        if (isNumeric(rep)) {\n            if (format.toLowerCase() !== \"x\") {\n                if (isLessThan(rep, 0)) {\n                    rep = multiply(rep, -1);\n                    sign = \"-\";\n                }\n                else {\n                    if (flags.indexOf(\" \") >= 0) {\n                        sign = \" \";\n                    }\n                    else if (flags.indexOf(\"+\") >= 0) {\n                        sign = \"+\";\n                    }\n                }\n            }\n            precision = precision == null ? null : parseInt(precision, 10);\n            switch (format) {\n                case \"f\":\n                case \"F\":\n                    precision = precision != null ? precision : 6;\n                    rep = toFixed(rep, precision);\n                    break;\n                case \"g\":\n                case \"G\":\n                    rep = precision != null ? toPrecision(rep, precision) : toPrecision(rep);\n                    break;\n                case \"e\":\n                case \"E\":\n                    rep = precision != null ? toExponential(rep, precision) : toExponential(rep);\n                    break;\n                case \"x\":\n                    rep = toHex(rep);\n                    break;\n                case \"X\":\n                    rep = toHex(rep).toUpperCase();\n                    break;\n                default: // AOid\n                    rep = String(rep);\n                    break;\n            }\n        }\n        padLength = parseInt(padLength, 10);\n        if (!isNaN(padLength)) {\n            const zeroFlag = flags.indexOf(\"0\") >= 0; // Use '0' for left padding\n            const minusFlag = flags.indexOf(\"-\") >= 0; // Right padding\n            const ch = minusFlag || !zeroFlag ? \" \" : \"0\";\n            if (ch === \"0\") {\n                rep = padLeft(rep, padLength - sign.length, ch, minusFlag);\n                rep = sign + rep;\n            }\n            else {\n                rep = padLeft(sign + rep, padLength, ch, minusFlag);\n            }\n        }\n        else {\n            rep = sign + rep;\n        }\n        const once = prefix + rep;\n        return once.replace(/%/g, \"%%\");\n    });\n}\nfunction createPrinter(str, cont) {\n    return (...args) => {\n        // Make a copy as the function may be used several times\n        let strCopy = str;\n        for (const arg of args) {\n            strCopy = formatOnce(strCopy, arg);\n        }\n        return fsFormatRegExp.test(strCopy)\n            ? createPrinter(strCopy, cont)\n            : cont(strCopy.replace(/%%/g, \"%\"));\n    };\n}\nexport function fsFormat(str) {\n    return (cont) => {\n        return fsFormatRegExp.test(str)\n            ? createPrinter(str, cont)\n            : cont(str);\n    };\n}\nexport function format(str, ...args) {\n    if (typeof str === \"object\" && args.length > 0) {\n        // Called with culture info\n        str = args[0];\n        args.shift();\n    }\n    return str.replace(formatRegExp, (_, idx, padLength, format, precision, pattern) => {\n        let rep = args[idx];\n        if (isNumeric(rep)) {\n            precision = precision == null ? null : parseInt(precision, 10);\n            switch (format) {\n                case \"f\":\n                case \"F\":\n                    precision = precision != null ? precision : 2;\n                    rep = toFixed(rep, precision);\n                    break;\n                case \"g\":\n                case \"G\":\n                    rep = precision != null ? toPrecision(rep, precision) : toPrecision(rep);\n                    break;\n                case \"e\":\n                case \"E\":\n                    rep = precision != null ? toExponential(rep, precision) : toExponential(rep);\n                    break;\n                case \"p\":\n                case \"P\":\n                    precision = precision != null ? precision : 2;\n                    rep = toFixed(multiply(rep, 100), precision) + \" %\";\n                    break;\n                case \"d\":\n                case \"D\":\n                    rep = precision != null ? padLeft(String(rep), precision, \"0\") : String(rep);\n                    break;\n                case \"x\":\n                case \"X\":\n                    rep = precision != null ? padLeft(toHex(rep), precision, \"0\") : toHex(rep);\n                    if (format === \"X\") {\n                        rep = rep.toUpperCase();\n                    }\n                    break;\n                default:\n                    if (pattern) {\n                        let sign = \"\";\n                        rep = pattern.replace(/(0+)(\\.0+)?/, (_, intPart, decimalPart) => {\n                            if (isLessThan(rep, 0)) {\n                                rep = multiply(rep, -1);\n                                sign = \"-\";\n                            }\n                            rep = toFixed(rep, decimalPart != null ? decimalPart.length - 1 : 0);\n                            return padLeft(rep, (intPart || \"\").length - sign.length + (decimalPart != null ? decimalPart.length : 0), \"0\");\n                        });\n                        rep = sign + rep;\n                    }\n            }\n        }\n        else if (rep instanceof Date) {\n            rep = dateToString(rep, pattern || format);\n        }\n        padLength = parseInt((padLength || \" \").substring(1), 10);\n        if (!isNaN(padLength)) {\n            rep = padLeft(String(rep), Math.abs(padLength), \" \", padLength < 0);\n        }\n        return rep;\n    });\n}\nexport function endsWith(str, search) {\n    const idx = str.lastIndexOf(search);\n    return idx >= 0 && idx === str.length - search.length;\n}\nexport function initialize(n, f) {\n    if (n < 0) {\n        throw new Error(\"String length must be non-negative\");\n    }\n    const xs = new Array(n);\n    for (let i = 0; i < n; i++) {\n        xs[i] = f(i);\n    }\n    return xs.join(\"\");\n}\nexport function insert(str, startIndex, value) {\n    if (startIndex < 0 || startIndex > str.length) {\n        throw new Error(\"startIndex is negative or greater than the length of this instance.\");\n    }\n    return str.substring(0, startIndex) + value + str.substring(startIndex);\n}\nexport function isNullOrEmpty(str) {\n    return typeof str !== \"string\" || str.length === 0;\n}\nexport function isNullOrWhiteSpace(str) {\n    return typeof str !== \"string\" || /^\\s*$/.test(str);\n}\nexport function concat(...xs) {\n    return xs.map((x) => String(x)).join(\"\");\n}\nexport function join(delimiter, xs) {\n    if (Array.isArray(xs)) {\n        return xs.join(delimiter);\n    }\n    else {\n        return Array.from(xs).join(delimiter);\n    }\n}\nexport function joinWithIndices(delimiter, xs, startIndex, count) {\n    const endIndexPlusOne = startIndex + count;\n    if (endIndexPlusOne > xs.length) {\n        throw new Error(\"Index and count must refer to a location within the buffer.\");\n    }\n    return xs.slice(startIndex, endIndexPlusOne).join(delimiter);\n}\n/** Validates UUID as specified in RFC4122 (versions 1-5). Trims braces. */\nexport function validateGuid(str, doNotThrow) {\n    const trimmedAndLowered = trim(str, \"{\", \"}\").toLowerCase();\n    if (guidRegex.test(trimmedAndLowered)) {\n        return doNotThrow ? [true, trimmedAndLowered] : trimmedAndLowered;\n    }\n    else if (doNotThrow) {\n        return [false, \"00000000-0000-0000-0000-000000000000\"];\n    }\n    throw new Error(\"Guid should contain 32 digits with 4 dashes: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\");\n}\n// From https://gist.github.com/LeverOne/1308368\nexport function newGuid() {\n    let b = \"\";\n    for (let a = 0; a++ < 36;) {\n        b += a * 51 & 52\n            ? (a ^ 15 ? 8 ^ Math.random() * (a ^ 20 ? 16 : 4) : 4).toString(16)\n            : \"-\";\n    }\n    return b;\n}\n// Maps for number <-> hex string conversion\nlet _convertMapsInitialized = false;\nlet _byteToHex;\nlet _hexToByte;\nfunction initConvertMaps() {\n    _byteToHex = new Array(256);\n    _hexToByte = {};\n    for (let i = 0; i < 256; i++) {\n        _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n        _hexToByte[_byteToHex[i]] = i;\n    }\n    _convertMapsInitialized = true;\n}\n/** Parse a UUID into it's component bytes */\n// Adapted from https://github.com/zefferus/uuid-parse\nexport function guidToArray(s) {\n    if (!_convertMapsInitialized) {\n        initConvertMaps();\n    }\n    let i = 0;\n    const buf = new Uint8Array(16);\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, ((oct) => {\n        switch (i) {\n            // .NET saves first three byte groups with different endianness\n            // See https://stackoverflow.com/a/16722909/3922220\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n                buf[3 - i++] = _hexToByte[oct];\n                break;\n            case 4:\n            case 5:\n                buf[9 - i++] = _hexToByte[oct];\n                break;\n            case 6:\n            case 7:\n                buf[13 - i++] = _hexToByte[oct];\n                break;\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n                buf[i++] = _hexToByte[oct];\n                break;\n        }\n    }));\n    // Zero out remaining bytes if string was short\n    while (i < 16) {\n        buf[i++] = 0;\n    }\n    return buf;\n}\n/** Convert UUID byte array into a string */\nexport function arrayToGuid(buf) {\n    if (buf.length !== 16) {\n        throw new Error(\"Byte array for GUID must be exactly 16 bytes long\");\n    }\n    if (!_convertMapsInitialized) {\n        initConvertMaps();\n    }\n    const guid = _byteToHex[buf[3]] + _byteToHex[buf[2]] +\n        _byteToHex[buf[1]] + _byteToHex[buf[0]] + \"-\" +\n        _byteToHex[buf[5]] + _byteToHex[buf[4]] + \"-\" +\n        _byteToHex[buf[7]] + _byteToHex[buf[6]] + \"-\" +\n        _byteToHex[buf[8]] + _byteToHex[buf[9]] + \"-\" +\n        _byteToHex[buf[10]] + _byteToHex[buf[11]] +\n        _byteToHex[buf[12]] + _byteToHex[buf[13]] +\n        _byteToHex[buf[14]] + _byteToHex[buf[15]];\n    return guid;\n}\nfunction notSupported(name) {\n    throw new Error(\"The environment doesn't support '\" + name + \"', please use a polyfill.\");\n}\nexport function toBase64String(inArray) {\n    let str = \"\";\n    for (let i = 0; i < inArray.length; i++) {\n        str += String.fromCharCode(inArray[i]);\n    }\n    return typeof btoa === \"function\" ? btoa(str) : notSupported(\"btoa\");\n}\nexport function fromBase64String(b64Encoded) {\n    const binary = typeof atob === \"function\" ? atob(b64Encoded) : notSupported(\"atob\");\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\nexport function padLeft(str, len, ch, isRight) {\n    ch = ch || \" \";\n    len = len - str.length;\n    for (let i = 0; i < len; i++) {\n        str = isRight ? str + ch : ch + str;\n    }\n    return str;\n}\nexport function padRight(str, len, ch) {\n    return padLeft(str, len, ch, true);\n}\nexport function remove(str, startIndex, count) {\n    if (startIndex >= str.length) {\n        throw new Error(\"startIndex must be less than length of string\");\n    }\n    if (typeof count === \"number\" && (startIndex + count) > str.length) {\n        throw new Error(\"Index and count must refer to a location within the string.\");\n    }\n    return str.slice(0, startIndex) + (typeof count === \"number\" ? str.substr(startIndex + count) : \"\");\n}\nexport function replace(str, search, replace) {\n    return str.replace(new RegExp(escape(search), \"g\"), replace);\n}\nexport function replicate(n, x) {\n    return initialize(n, () => x);\n}\nexport function getCharAtIndex(input, index) {\n    if (index < 0 || index >= input.length) {\n        throw new Error(\"Index was outside the bounds of the array.\");\n    }\n    return input[index];\n}\nexport function split(str, splitters, count, removeEmpty) {\n    count = typeof count === \"number\" ? count : undefined;\n    removeEmpty = typeof removeEmpty === \"number\" ? removeEmpty : undefined;\n    if (count && count < 0) {\n        throw new Error(\"Count cannot be less than zero\");\n    }\n    if (count === 0) {\n        return [];\n    }\n    if (!Array.isArray(splitters)) {\n        if (removeEmpty === 0) {\n            return str.split(splitters, count);\n        }\n        const len = arguments.length;\n        splitters = Array(len - 1);\n        for (let key = 1; key < len; key++) {\n            splitters[key - 1] = arguments[key];\n        }\n    }\n    splitters = splitters.map((x) => escape(x));\n    splitters = splitters.length > 0 ? splitters : [\" \"];\n    let i = 0;\n    const splits = [];\n    const reg = new RegExp(splitters.join(\"|\"), \"g\");\n    while (count == null || count > 1) {\n        const m = reg.exec(str);\n        if (m === null) {\n            break;\n        }\n        if (!removeEmpty || (m.index - i) > 0) {\n            count = count != null ? count - 1 : count;\n            splits.push(str.substring(i, m.index));\n        }\n        i = reg.lastIndex;\n    }\n    if (!removeEmpty || (str.length - i) > 0) {\n        splits.push(str.substring(i));\n    }\n    return splits;\n}\nexport function trim(str, ...chars) {\n    if (chars.length === 0) {\n        return str.trim();\n    }\n    const pattern = \"[\" + escape(chars.join(\"\")) + \"]+\";\n    return str.replace(new RegExp(\"^\" + pattern), \"\").replace(new RegExp(pattern + \"$\"), \"\");\n}\nexport function trimStart(str, ...chars) {\n    return chars.length === 0\n        ? str.trimStart()\n        : str.replace(new RegExp(\"^[\" + escape(chars.join(\"\")) + \"]+\"), \"\");\n}\nexport function trimEnd(str, ...chars) {\n    return chars.length === 0\n        ? str.trimEnd()\n        : str.replace(new RegExp(\"[\" + escape(chars.join(\"\")) + \"]+$\"), \"\");\n}\nexport function filter(pred, x) {\n    return x.split(\"\").filter((c) => pred(c)).join(\"\");\n}\nexport function substring(str, startIndex, length) {\n    if ((startIndex + (length || 0) > str.length)) {\n        throw new Error(\"Invalid startIndex and/or length\");\n    }\n    return length != null ? str.substr(startIndex, length) : str.substr(startIndex);\n}\n//# sourceMappingURL=String.js.map","import { Union } from \"./Types\";\nimport { compare, equals, structuralHash } from \"./Util\";\n// Using a class here for better compatibility with TS files importing Some\nexport class Some {\n    constructor(value) {\n        this.value = value;\n    }\n    // Don't add \"Some\" for consistency with erased options\n    toString() {\n        return String(this.value);\n    }\n    toJSON() {\n        return this.value;\n    }\n    GetHashCode() {\n        return structuralHash(this.value);\n    }\n    Equals(other) {\n        if (other == null) {\n            return false;\n        }\n        else {\n            return equals(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n    CompareTo(other) {\n        if (other == null) {\n            return 1;\n        }\n        else {\n            return compare(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n}\nexport function some(x) {\n    return x == null || x instanceof Some ? new Some(x) : x;\n}\nexport function value(x) {\n    if (x == null) {\n        throw new Error(\"Option has no value\");\n    }\n    else {\n        return x instanceof Some ? x.value : x;\n    }\n}\nexport function tryValue(x) {\n    return x instanceof Some ? x.value : x;\n}\nexport function toArray(opt) {\n    return (opt == null) ? [] : [value(opt)];\n}\nexport function defaultArg(opt, defaultValue) {\n    return (opt != null) ? value(opt) : defaultValue;\n}\nexport function defaultArgWith(opt, defThunk) {\n    return (opt != null) ? value(opt) : defThunk();\n}\nexport function filter(predicate, opt) {\n    return (opt != null) ? (predicate(value(opt)) ? opt : undefined) : opt;\n}\nexport function map(mapping, opt) {\n    return (opt != null) ? some(mapping(value(opt))) : undefined;\n}\nexport function map2(mapping, opt1, opt2) {\n    return (opt1 != null && opt2 != null) ? mapping(value(opt1), value(opt2)) : undefined;\n}\nexport function map3(mapping, opt1, opt2, opt3) {\n    return (opt1 != null && opt2 != null && opt3 != null) ? mapping(value(opt1), value(opt2), value(opt3)) : undefined;\n}\nexport function bind(binder, opt) {\n    return opt != null ? binder(value(opt)) : undefined;\n}\nexport function tryOp(op, arg) {\n    try {\n        return some(op(arg));\n    }\n    catch (_a) {\n        return undefined;\n    }\n}\n// CHOICE\nexport class Choice extends Union {\n}\nexport class Choice3 extends Union {\n}\nexport class Choice4 extends Union {\n}\nexport class Choice5 extends Union {\n}\nexport class Choice6 extends Union {\n}\nexport class Choice7 extends Union {\n}\nexport function choice1Of2(x) {\n    return new Choice(0, \"Choice1Of2\", x);\n}\nexport function choice2Of2(x) {\n    return new Choice(1, \"Choice2Of2\", x);\n}\nexport function tryValueIfChoice1Of2(x) {\n    return x.tag === 0 ? some(x.fields[0]) : undefined;\n}\nexport function tryValueIfChoice2Of2(x) {\n    return x.tag === 1 ? some(x.fields[0]) : undefined;\n}\n// RESULT\nexport class Result extends Union {\n}\nexport function ok(x) {\n    return new Result(0, \"Ok\", x);\n}\nexport function error(x) {\n    return new Result(1, \"Error\", x);\n}\nexport function mapOk(f, result) {\n    return result.tag === 0 ? ok(f(result.fields[0])) : result;\n}\nexport function mapError(f, result) {\n    return result.tag === 1 ? error(f(result.fields[0])) : result;\n}\nexport function bindOk(f, result) {\n    return result.tag === 0 ? f(result.fields[0]) : result;\n}\n//# sourceMappingURL=Option.js.map","namespace Thoth.Json\nopen System.Text.RegularExpressions\n\ntype JsonValue = obj\n\ntype ErrorReason =\n    | BadPrimitive of string * JsonValue\n    | BadPrimitiveExtra of string * JsonValue * string\n    | BadType of string * JsonValue\n    | BadField of string * JsonValue\n    | BadPath of string * JsonValue * string\n    | TooSmallArray of string * JsonValue\n    | FailMessage of string\n    | BadOneOf of string list\n\ntype CaseStrategy =\n    | PascalCase\n    | CamelCase\n    | SnakeCase\n\ntype DecoderError = string * ErrorReason\n\ntype Decoder<'T> = string -> JsonValue -> Result<'T, DecoderError>\n\ntype Encoder<'T> = 'T -> JsonValue\n\ntype BoxedDecoder = Decoder<obj>\n\ntype BoxedEncoder = Encoder<obj>\n\ntype ExtraCoders =\n    { Hash: string\n      Coders: Map<string, BoxedEncoder * BoxedDecoder> }\n\nmodule internal Util =\n    open System.Collections.Generic\n\n    type Cache<'Value>() =\n        let cache = Dictionary<string, 'Value>()\n        member __.GetOrAdd(key, factory) =\n            match cache.TryGetValue(key) with\n            | true, x -> x\n            | false, _ ->\n                let x = factory()\n                cache.Add(key, x)\n                x\n\n    // Tree shaking will remove this if not used\n    // so no need to make them lazy in Fable\n    let CachedEncoders = Cache<BoxedEncoder>()\n    let CachedDecoders = Cache<BoxedDecoder>()\n\n    /// If used from .NET the type resolver won't be injected,\n    /// throw a more informative error than just a null reference.\n    let inline resolveType (resolver: Fable.Core.ITypeResolver<'T> option): System.Type =\n#if !FABLE_COMPILER\n        failwith \"Thoth.Json is only compatible with Fable, use Thoth.Json.Net\"\n#else\n        resolver.Value.ResolveType()\n#endif\n\n\n    module Casing =\n        let lowerFirst (str : string) = str.[..0].ToLowerInvariant() + str.[1..]\n        let convert caseStrategy fieldName =\n            match caseStrategy with\n            | CamelCase -> lowerFirst fieldName \n            | SnakeCase -> Regex.Replace(lowerFirst fieldName, \"[A-Z]\",\"_$0\").ToLowerInvariant()\n            | PascalCase -> fieldName ","import { makeRangeStepFunction as makeDecimalRangeStepFunction } from \"./Decimal\";\nimport { makeRangeStepFunction as makeLongRangeStepFunction } from \"./Long\";\nimport { some, value } from \"./Option\";\nimport { compare, equals } from \"./Util\";\nexport class Enumerator {\n    constructor(iter) {\n        this.iter = iter;\n    }\n    MoveNext() {\n        const cur = this.iter.next();\n        this.current = cur.value;\n        return !cur.done;\n    }\n    get Current() {\n        return this.current;\n    }\n    Reset() {\n        throw new Error(\"JS iterators cannot be reset\");\n    }\n    Dispose() {\n        return;\n    }\n}\nexport function getEnumerator(o) {\n    return new Enumerator(o[Symbol.iterator]());\n}\nexport function toIterator(en) {\n    return {\n        next() {\n            return en.MoveNext()\n                ? { done: false, value: en.Current }\n                : { done: true, value: undefined };\n        },\n    };\n}\n// export function toIterable<T>(en: IEnumerable<T>): Iterable<T> {\n//   return {\n//     [Symbol.iterator]() {\n//       return toIterator(en.GetEnumerator());\n//     },\n//   };\n// }\nfunction __failIfNone(res) {\n    if (res == null) {\n        throw new Error(\"Seq did not contain any matching element\");\n    }\n    return value(res);\n}\nfunction makeSeq(f) {\n    const seq = {\n        [Symbol.iterator]: f,\n        toString: () => \"seq [\" + Array.from(seq).join(\"; \") + \"]\",\n    };\n    return seq;\n}\nexport function ofArray(xs) {\n    return delay(() => unfold((i) => i != null && i < xs.length ? [xs[i], i + 1] : undefined, 0));\n}\nexport function allPairs(xs, ys) {\n    let firstEl = true;\n    const ysCache = [];\n    return collect((x) => {\n        if (firstEl) {\n            firstEl = false;\n            return map((y) => {\n                ysCache.push(y);\n                return [x, y];\n            }, ys);\n        }\n        else {\n            return ysCache.map((y) => [x, y]);\n            // return map(function (i) {\n            //     return [x, ysCache[i]];\n            // }, rangeNumber(0, 1, ysCache.length - 1));\n        }\n    }, xs);\n}\nexport function append(xs, ys) {\n    return delay(() => {\n        let firstDone = false;\n        const i = xs[Symbol.iterator]();\n        let iters = [i, undefined];\n        return unfold(() => {\n            var _a, _b;\n            let cur;\n            if (!firstDone) {\n                cur = (_a = iters[0]) === null || _a === void 0 ? void 0 : _a.next();\n                if (cur != null && !cur.done) {\n                    return [cur.value, iters];\n                }\n                else {\n                    firstDone = true;\n                    iters = [undefined, ys[Symbol.iterator]()];\n                }\n            }\n            cur = (_b = iters[1]) === null || _b === void 0 ? void 0 : _b.next();\n            return cur != null && !cur.done ? [cur.value, iters] : undefined;\n        }, iters);\n    });\n}\nexport function average(xs, averager) {\n    let count = 0;\n    const total = fold((acc, x) => {\n        count++;\n        return averager.Add(acc, x);\n    }, averager.GetZero(), xs);\n    return averager.DivideByInt(total, count);\n}\nexport function averageBy(f, xs, averager) {\n    let count = 0;\n    const total = fold((acc, x) => {\n        count++;\n        return averager.Add(acc, f(x));\n    }, averager.GetZero(), xs);\n    return averager.DivideByInt(total, count);\n}\nexport function concat(xs) {\n    return delay(() => {\n        const iter = xs[Symbol.iterator]();\n        let output;\n        return unfold((innerIter) => {\n            let hasFinished = false;\n            while (!hasFinished) {\n                if (innerIter == null) {\n                    const cur = iter.next();\n                    if (!cur.done) {\n                        innerIter = cur.value[Symbol.iterator]();\n                    }\n                    else {\n                        hasFinished = true;\n                    }\n                }\n                else {\n                    const cur = innerIter.next();\n                    if (!cur.done) {\n                        output = cur.value;\n                        hasFinished = true;\n                    }\n                    else {\n                        innerIter = undefined;\n                    }\n                }\n            }\n            return innerIter != null ? [output, innerIter] : undefined;\n        }, undefined);\n    });\n}\nexport function collect(f, xs) {\n    return concat(map(f, xs));\n}\nexport function choose(f, xs) {\n    return delay(() => unfold((iter) => {\n        let cur = iter.next();\n        while (!cur.done) {\n            const y = f(cur.value);\n            if (y != null) {\n                return [value(y), iter];\n            }\n            cur = iter.next();\n        }\n        return undefined;\n    }, xs[Symbol.iterator]()));\n}\nexport function compareWith(f, xs, ys) {\n    const nonZero = tryFind((i) => i !== 0, map2(f, xs, ys));\n    return nonZero != null ? value(nonZero) : length(xs) - length(ys);\n}\nexport function delay(f) {\n    return makeSeq(() => f()[Symbol.iterator]());\n}\nexport function empty() {\n    return [];\n}\nexport function singleton(y) {\n    return [y];\n}\nexport function enumerateFromFunctions(factory, moveNext, current) {\n    return delay(() => unfold((e) => moveNext(e) ? [current(e), e] : undefined, factory()));\n}\nexport function enumerateWhile(cond, xs) {\n    return concat(unfold(() => cond() ? [xs, true] : undefined, undefined));\n}\nexport function enumerateThenFinally(xs, finalFn) {\n    return delay(() => {\n        let iter;\n        try {\n            iter = xs[Symbol.iterator]();\n        }\n        catch (err) {\n            try {\n                return empty();\n            }\n            finally {\n                finalFn();\n            }\n        }\n        return unfold((it) => {\n            try {\n                const cur = it.next();\n                return !cur.done ? [cur.value, it] : undefined;\n            }\n            catch (err) {\n                return undefined;\n            }\n            finally {\n                finalFn();\n            }\n        }, iter);\n    });\n}\nexport function enumerateUsing(disp, work) {\n    let isDisposed = false;\n    const disposeOnce = () => {\n        if (!isDisposed) {\n            isDisposed = true;\n            disp.Dispose();\n        }\n    };\n    try {\n        return enumerateThenFinally(work(disp), disposeOnce);\n    }\n    catch (err) {\n        return void 0;\n    }\n    finally {\n        disposeOnce();\n    }\n}\nexport function exactlyOne(xs) {\n    const iter = xs[Symbol.iterator]();\n    const fst = iter.next();\n    if (fst.done) {\n        throw new Error(\"Seq was empty\");\n    }\n    const snd = iter.next();\n    if (!snd.done) {\n        throw new Error(\"Seq had multiple items\");\n    }\n    return fst.value;\n}\nexport function except(itemsToExclude, source) {\n    const exclusionItems = Array.from(itemsToExclude);\n    const testIsNotInExclusionItems = (element) => !exclusionItems.some((excludedItem) => equals(excludedItem, element));\n    return filter(testIsNotInExclusionItems, source);\n}\nexport function exists(f, xs) {\n    let cur;\n    for (const iter = xs[Symbol.iterator]();;) {\n        cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        if (f(cur.value)) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function exists2(f, xs, ys) {\n    let cur1;\n    let cur2;\n    for (const iter1 = xs[Symbol.iterator](), iter2 = ys[Symbol.iterator]();;) {\n        cur1 = iter1.next();\n        cur2 = iter2.next();\n        if (cur1.done || cur2.done) {\n            break;\n        }\n        if (f(cur1.value, cur2.value)) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function forAll(f, xs) {\n    return !exists((x) => !f(x), xs);\n}\nexport function forAll2(f, xs, ys) {\n    return !exists2((x, y) => !f(x, y), xs, ys);\n}\nexport function contains(i, xs) {\n    return exists((x) => equals(x, i), xs);\n}\nexport function filter(f, xs) {\n    return delay(() => unfold((iter) => {\n        let cur = iter.next();\n        while (!cur.done) {\n            if (f(cur.value)) {\n                return [cur.value, iter];\n            }\n            cur = iter.next();\n        }\n        return undefined;\n    }, xs[Symbol.iterator]()));\n}\nexport function where(f, xs) {\n    return filter(f, xs);\n}\nexport function fold(f, acc, xs) {\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\n        return xs.reduce(f, acc);\n    }\n    else {\n        let cur;\n        for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n            cur = iter.next();\n            if (cur.done) {\n                break;\n            }\n            acc = f(acc, cur.value, i);\n        }\n        return acc;\n    }\n}\nexport function foldBack(f, xs, acc) {\n    const arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n    for (let i = arr.length - 1; i >= 0; i--) {\n        acc = f(arr[i], acc, i);\n    }\n    return acc;\n}\nexport function fold2(f, acc, xs, ys) {\n    const iter1 = xs[Symbol.iterator]();\n    const iter2 = ys[Symbol.iterator]();\n    let cur1;\n    let cur2;\n    for (let i = 0;; i++) {\n        cur1 = iter1.next();\n        cur2 = iter2.next();\n        if (cur1.done || cur2.done) {\n            break;\n        }\n        acc = f(acc, cur1.value, cur2.value, i);\n    }\n    return acc;\n}\nexport function foldBack2(f, xs, ys, acc) {\n    const ar1 = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n    const ar2 = Array.isArray(ys) || ArrayBuffer.isView(ys) ? ys : Array.from(ys);\n    for (let i = ar1.length - 1; i >= 0; i--) {\n        acc = f(ar1[i], ar2[i], acc, i);\n    }\n    return acc;\n}\nexport function tryHead(xs) {\n    const iter = xs[Symbol.iterator]();\n    const cur = iter.next();\n    return cur.done ? undefined : some(cur.value);\n}\nexport function head(xs) {\n    return __failIfNone(tryHead(xs));\n}\nexport function initialize(n, f) {\n    return delay(() => unfold((i) => i < n ? [f(i), i + 1] : undefined, 0));\n}\nexport function initializeInfinite(f) {\n    return delay(() => unfold((i) => [f(i), i + 1], 0));\n}\nexport function tryItem(i, xs) {\n    if (i < 0) {\n        return undefined;\n    }\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\n        return i < xs.length ? some(xs[i]) : undefined;\n    }\n    for (let j = 0, iter = xs[Symbol.iterator]();; j++) {\n        const cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        if (j === i) {\n            return some(cur.value);\n        }\n    }\n    return undefined;\n}\nexport function item(i, xs) {\n    return __failIfNone(tryItem(i, xs));\n}\nexport function iterate(f, xs) {\n    fold((_, x) => (f(x), undefined), undefined, xs);\n}\nexport function iterate2(f, xs, ys) {\n    fold2((_, x, y) => (f(x, y), undefined), undefined, xs, ys);\n}\nexport function iterateIndexed(f, xs) {\n    fold((_, x, i) => (f(i !== null && i !== void 0 ? i : 0, x), undefined), undefined, xs);\n}\nexport function iterateIndexed2(f, xs, ys) {\n    fold2((_, x, y, i) => (f(i !== null && i !== void 0 ? i : 0, x, y), undefined), undefined, xs, ys);\n}\nexport function isEmpty(xs) {\n    const i = xs[Symbol.iterator]();\n    return i.next().done;\n}\nexport function tryLast(xs) {\n    return isEmpty(xs) ? undefined : some(reduce((_, x) => x, xs));\n}\nexport function last(xs) {\n    return __failIfNone(tryLast(xs));\n}\nexport function length(xs) {\n    return Array.isArray(xs) || ArrayBuffer.isView(xs)\n        ? xs.length\n        : fold((acc, _x) => acc + 1, 0, xs);\n}\nexport function map(f, xs) {\n    return delay(() => unfold((iter) => {\n        const cur = iter.next();\n        return !cur.done ? [f(cur.value), iter] : undefined;\n    }, xs[Symbol.iterator]()));\n}\nexport function mapIndexed(f, xs) {\n    return delay(() => {\n        let i = 0;\n        return unfold((iter) => {\n            const cur = iter.next();\n            return !cur.done ? [f(i++, cur.value), iter] : undefined;\n        }, xs[Symbol.iterator]());\n    });\n}\nexport function indexed(xs) {\n    return mapIndexed((i, x) => [i, x], xs);\n}\nexport function map2(f, xs, ys) {\n    return delay(() => {\n        const iter1 = xs[Symbol.iterator]();\n        const iter2 = ys[Symbol.iterator]();\n        return unfold(() => {\n            const cur1 = iter1.next();\n            const cur2 = iter2.next();\n            return !cur1.done && !cur2.done ? [f(cur1.value, cur2.value), undefined] : undefined;\n        }, undefined);\n    });\n}\nexport function mapIndexed2(f, xs, ys) {\n    return delay(() => {\n        let i = 0;\n        const iter1 = xs[Symbol.iterator]();\n        const iter2 = ys[Symbol.iterator]();\n        return unfold(() => {\n            const cur1 = iter1.next();\n            const cur2 = iter2.next();\n            return !cur1.done && !cur2.done ? [f(i++, cur1.value, cur2.value), undefined] : undefined;\n        }, undefined);\n    });\n}\nexport function map3(f, xs, ys, zs) {\n    return delay(() => {\n        const iter1 = xs[Symbol.iterator]();\n        const iter2 = ys[Symbol.iterator]();\n        const iter3 = zs[Symbol.iterator]();\n        return unfold(() => {\n            const cur1 = iter1.next();\n            const cur2 = iter2.next();\n            const cur3 = iter3.next();\n            return !cur1.done && !cur2.done && !cur3.done ? [f(cur1.value, cur2.value, cur3.value), undefined] : undefined;\n        }, undefined);\n    });\n}\nexport function mapFold(f, acc, xs, transform) {\n    const result = [];\n    let r;\n    let cur;\n    for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n        cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        [r, acc] = f(acc, cur.value);\n        result.push(r);\n    }\n    return transform !== void 0 ? [transform(result), acc] : [result, acc];\n}\nexport function mapFoldBack(f, xs, acc, transform) {\n    const arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n    const result = [];\n    let r;\n    for (let i = arr.length - 1; i >= 0; i--) {\n        [r, acc] = f(arr[i], acc);\n        result.push(r);\n    }\n    return transform !== void 0 ? [transform(result), acc] : [result, acc];\n}\nexport function max(xs, comparer) {\n    const compareFn = comparer != null ? comparer.Compare : compare;\n    return reduce((acc, x) => compareFn(acc, x) === 1 ? acc : x, xs);\n}\nexport function maxBy(f, xs, comparer) {\n    const compareFn = comparer != null ? comparer.Compare : compare;\n    return reduce((acc, x) => compareFn(f(acc), f(x)) === 1 ? acc : x, xs);\n}\nexport function min(xs, comparer) {\n    const compareFn = comparer != null ? comparer.Compare : compare;\n    return reduce((acc, x) => compareFn(acc, x) === -1 ? acc : x, xs);\n}\nexport function minBy(f, xs, comparer) {\n    const compareFn = comparer != null ? comparer.Compare : compare;\n    return reduce((acc, x) => compareFn(f(acc), f(x)) === -1 ? acc : x, xs);\n}\nexport function pairwise(xs) {\n    return delay(() => {\n        const iter = xs[Symbol.iterator]();\n        const cur = iter.next();\n        if (cur.done) {\n            return empty();\n        }\n        const hd = cur.value;\n        const tl = tail(xs);\n        const ys = scan(([_, last], next) => [last, next], [hd, hd], tl);\n        return skip(1, ys);\n    });\n}\nexport function rangeChar(first, last) {\n    return delay(() => unfold((x) => x <= last ? [x, String.fromCharCode(x.charCodeAt(0) + 1)] : undefined, first));\n}\nexport function rangeLong(first, step, last, unsigned) {\n    const stepFn = makeLongRangeStepFunction(step, last, unsigned);\n    return delay(() => unfold(stepFn, first));\n}\nexport function rangeDecimal(first, step, last) {\n    const stepFn = makeDecimalRangeStepFunction(step, last);\n    return delay(() => unfold(stepFn, first));\n}\nexport function rangeNumber(first, step, last) {\n    if (step === 0) {\n        throw new Error(\"Step cannot be 0\");\n    }\n    return delay(() => unfold((x) => step > 0 && x <= last || step < 0 && x >= last ? [x, x + step] : undefined, first));\n}\nexport function readOnly(xs) {\n    return map((x) => x, xs);\n}\nexport function reduce(f, xs) {\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\n        return xs.reduce(f);\n    }\n    const iter = xs[Symbol.iterator]();\n    let cur = iter.next();\n    if (cur.done) {\n        throw new Error(\"Seq was empty\");\n    }\n    let acc = cur.value;\n    while (true) {\n        cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        acc = f(acc, cur.value);\n    }\n    return acc;\n}\nexport function reduceBack(f, xs) {\n    const ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\n    if (ar.length === 0) {\n        throw new Error(\"Seq was empty\");\n    }\n    let acc = ar[ar.length - 1];\n    for (let i = ar.length - 2; i >= 0; i--) {\n        acc = f(ar[i], acc, i);\n    }\n    return acc;\n}\nexport function replicate(n, x) {\n    return initialize(n, () => x);\n}\nexport function reverse(xs) {\n    const ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\n    return ofArray(ar.reverse());\n}\nexport function scan(f, seed, xs) {\n    return delay(() => {\n        const iter = xs[Symbol.iterator]();\n        return unfold((acc) => {\n            if (acc == null) {\n                return [seed, seed];\n            }\n            const cur = iter.next();\n            if (!cur.done) {\n                acc = f(acc, cur.value);\n                return [acc, acc];\n            }\n            return undefined;\n        }, undefined);\n    });\n}\nexport function scanBack(f, xs, seed) {\n    return reverse(scan((acc, x) => f(x, acc), seed, reverse(xs)));\n}\nexport function skip(n, xs) {\n    return makeSeq(() => {\n        const iter = xs[Symbol.iterator]();\n        for (let i = 1; i <= n; i++) {\n            if (iter.next().done) {\n                throw new Error(\"Seq has not enough elements\");\n            }\n        }\n        return iter;\n    });\n}\nexport function skipWhile(f, xs) {\n    return delay(() => {\n        let hasPassed = false;\n        return filter((x) => hasPassed || (hasPassed = !f(x)), xs);\n    });\n}\nexport function sortWith(f, xs) {\n    const ys = Array.from(xs);\n    return ofArray(ys.sort(f));\n}\nexport function sum(xs, adder) {\n    return fold((acc, x) => adder.Add(acc, x), adder.GetZero(), xs);\n}\nexport function sumBy(f, xs, adder) {\n    return fold((acc, x) => adder.Add(acc, f(x)), adder.GetZero(), xs);\n}\nexport function tail(xs) {\n    return skip(1, xs);\n}\nexport function take(n, xs, truncate = false) {\n    return delay(() => {\n        const iter = xs[Symbol.iterator]();\n        return unfold((i) => {\n            if (i < n) {\n                const cur = iter.next();\n                if (!cur.done) {\n                    return [cur.value, i + 1];\n                }\n                if (!truncate) {\n                    throw new Error(\"Seq has not enough elements\");\n                }\n            }\n            return undefined;\n        }, 0);\n    });\n}\nexport function truncate(n, xs) {\n    return take(n, xs, true);\n}\nexport function takeWhile(f, xs) {\n    return delay(() => {\n        const iter = xs[Symbol.iterator]();\n        return unfold(() => {\n            const cur = iter.next();\n            if (!cur.done && f(cur.value)) {\n                return [cur.value, undefined];\n            }\n            return undefined;\n        }, 0);\n    });\n}\nexport function tryFind(f, xs, defaultValue) {\n    for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n        const cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        if (f(cur.value, i)) {\n            return some(cur.value);\n        }\n    }\n    return defaultValue === void 0 ? undefined : some(defaultValue);\n}\nexport function find(f, xs) {\n    return __failIfNone(tryFind(f, xs));\n}\nexport function tryFindBack(f, xs, defaultValue) {\n    const arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\n    return tryFind(f, arr.reverse(), defaultValue);\n}\nexport function findBack(f, xs) {\n    return __failIfNone(tryFindBack(f, xs));\n}\nexport function tryFindIndex(f, xs) {\n    for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n        const cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        if (f(cur.value, i)) {\n            return i;\n        }\n    }\n    return undefined;\n}\nexport function findIndex(f, xs) {\n    return __failIfNone(tryFindIndex(f, xs));\n}\nexport function tryFindIndexBack(f, xs) {\n    const arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (f(arr[i], i)) {\n            return i;\n        }\n    }\n    return undefined;\n}\nexport function findIndexBack(f, xs) {\n    return __failIfNone(tryFindIndexBack(f, xs));\n}\nexport function tryPick(f, xs) {\n    for (let i = 0, iter = xs[Symbol.iterator]();; i++) {\n        const cur = iter.next();\n        if (cur.done) {\n            break;\n        }\n        const y = f(cur.value, i);\n        if (y != null) {\n            return y;\n        }\n    }\n    return undefined;\n}\nexport function pick(f, xs) {\n    return __failIfNone(tryPick(f, xs));\n}\nexport function unfold(f, fst) {\n    return makeSeq(() => {\n        // Capture a copy of the first value in the closure\n        // so the sequence is restarted every time, see #1230\n        let acc = fst;\n        const iter = {\n            next() {\n                const res = f(acc);\n                if (res != null) {\n                    const v = value(res);\n                    if (v != null) {\n                        acc = v[1];\n                        return { done: false, value: v[0] };\n                    }\n                }\n                return { done: true, value: undefined };\n            },\n        };\n        return iter;\n    });\n}\nexport function zip(xs, ys) {\n    return map2((x, y) => [x, y], xs, ys);\n}\nexport function zip3(xs, ys, zs) {\n    return map3((x, y, z) => [x, y, z], xs, ys, zs);\n}\nexport function windowed(windowSize, source) {\n    if (windowSize <= 0) {\n        throw new Error(\"windowSize must be positive\");\n    }\n    return makeSeq(() => {\n        let window = [];\n        const iter = source[Symbol.iterator]();\n        const iter2 = {\n            next() {\n                let cur;\n                while (window.length < windowSize) {\n                    if ((cur = iter.next()).done) {\n                        return { done: true, value: undefined };\n                    }\n                    window.push(cur.value);\n                }\n                const value = window;\n                window = window.slice(1);\n                return { done: false, value };\n            },\n        };\n        return iter2;\n    });\n}\nexport function transpose(source) {\n    return makeSeq(() => {\n        const iters = Array.from(source, (x) => x[Symbol.iterator]());\n        const iter = {\n            next() {\n                if (iters.length === 0) {\n                    return { done: true, value: undefined }; // empty sequence\n                }\n                const results = Array.from(iters, (iter) => iter.next());\n                if (results[0].done) {\n                    if (!results.every((x) => x.done)) {\n                        throw new Error(\"Sequences have different lengths\");\n                    }\n                    return { done: true, value: undefined };\n                }\n                else {\n                    if (!results.every((x) => !x.done)) {\n                        throw new Error(\"Sequences have different lengths\");\n                    }\n                    const values = results.map((x) => x.value);\n                    return { done: false, value: values };\n                }\n            },\n        };\n        return iter;\n    });\n}\n//# sourceMappingURL=Seq.js.map","import { declare, FSharpRef } from \"./Types.js\";\nimport { iterateIndexed, toIterator, getEnumerator, delay, collect, map, sumBy, iterate } from \"./Seq.js\";\nimport { class_type } from \"./Reflection.js\";\nimport { equals, getItemFromDict, tryGetValue } from \"./Util.js\";\nimport { format } from \"./String.js\";\nexport const MutableMap$00602 = declare(function Fable_Collections_MutableMap(pairs, comparer) {\n  const $this$$1 = this;\n  const this$ = new FSharpRef(null);\n  $this$$1.comparer = comparer;\n  this$.contents = $this$$1;\n  $this$$1.hashMap = new Map([]);\n  $this$$1[\"init@20-1\"] = 1;\n  iterate(function (pair) {\n    MutableMap$00602$$Add$$5BDDA1(this$.contents, pair[0], pair[1]);\n  }, pairs);\n  void null;\n});\nexport function MutableMap$00602$reflection($gen$$4, $gen$$5) {\n  return class_type(\"Fable.Collections.MutableMap`2\", [$gen$$4, $gen$$5], MutableMap$00602);\n}\nexport function MutableMap$00602$$$$002Ector$$6623D9B3(pairs, comparer) {\n  return this instanceof MutableMap$00602 ? MutableMap$00602.call(this, pairs, comparer) : new MutableMap$00602(pairs, comparer);\n}\n\nfunction MutableMap$00602$$TryFindIndex$$2B595(this$$$1, k) {\n  const h = this$$$1.comparer.GetHashCode(k) | 0;\n  const matchValue = tryGetValue(this$$$1.hashMap, h, null);\n\n  if (matchValue[0]) {\n    return [true, h, matchValue[1].findIndex(function (pair$$1) {\n      return this$$$1.comparer.Equals(k, pair$$1[0]);\n    })];\n  } else {\n    return [false, h, -1];\n  }\n}\n\nexport function MutableMap$00602$$TryFind$$2B595(this$$$2, k$$1) {\n  const matchValue$$1 = MutableMap$00602$$TryFindIndex$$2B595(this$$$2, k$$1);\n  var $target$$10;\n\n  if (matchValue$$1[0]) {\n    if (matchValue$$1[2] > -1) {\n      $target$$10 = 0;\n    } else {\n      $target$$10 = 1;\n    }\n  } else {\n    $target$$10 = 1;\n  }\n\n  switch ($target$$10) {\n    case 0:\n      {\n        return getItemFromDict(this$$$2.hashMap, matchValue$$1[1])[matchValue$$1[2]];\n      }\n\n    case 1:\n      {\n        return undefined;\n      }\n  }\n}\nexport function MutableMap$00602$$get_Comparer(this$$$3) {\n  return this$$$3.comparer;\n}\nexport function MutableMap$00602$$Clear(this$$$4) {\n  this$$$4.hashMap.clear();\n}\nexport function MutableMap$00602$$get_Count(this$$$5) {\n  const source = this$$$5.hashMap.values();\n  return sumBy(function projection(pairs$$2) {\n    return pairs$$2.length;\n  }, source, {\n    GetZero() {\n      return 0;\n    },\n\n    Add($x$$2, $y$$3) {\n      return $x$$2 + $y$$3;\n    }\n\n  }) | 0;\n}\nexport function MutableMap$00602$$get_Item$$2B595(this$$$6, k$$2) {\n  const matchValue$$2 = MutableMap$00602$$TryFind$$2B595(this$$$6, k$$2);\n\n  if (matchValue$$2 != null) {\n    const pair$$2 = matchValue$$2;\n    return pair$$2[1];\n  } else {\n    throw new Error(\"The item was not found in collection\");\n  }\n}\nexport function MutableMap$00602$$set_Item$$5BDDA1(this$$$7, k$$3, v) {\n  const matchValue$$3 = MutableMap$00602$$TryFindIndex$$2B595(this$$$7, k$$3);\n  var $target$$20;\n\n  if (matchValue$$3[0]) {\n    if (matchValue$$3[2] > -1) {\n      $target$$20 = 0;\n    } else {\n      $target$$20 = 1;\n    }\n  } else {\n    $target$$20 = 1;\n  }\n\n  switch ($target$$20) {\n    case 0:\n      {\n        getItemFromDict(this$$$7.hashMap, matchValue$$3[1])[matchValue$$3[2]] = [k$$3, v];\n        break;\n      }\n\n    case 1:\n      {\n        if (matchValue$$3[0]) {\n          const value = void getItemFromDict(this$$$7.hashMap, matchValue$$3[1]).push([k$$3, v]);\n          void null;\n        } else {\n          this$$$7.hashMap.set(matchValue$$3[1], [[k$$3, v]]);\n        }\n\n        break;\n      }\n  }\n}\nexport function MutableMap$00602$$Add$$5BDDA1(this$$$8, k$$4, v$$1) {\n  const matchValue$$4 = MutableMap$00602$$TryFindIndex$$2B595(this$$$8, k$$4);\n  var $target$$24;\n\n  if (matchValue$$4[0]) {\n    if (matchValue$$4[2] > -1) {\n      $target$$24 = 0;\n    } else {\n      $target$$24 = 1;\n    }\n  } else {\n    $target$$24 = 1;\n  }\n\n  switch ($target$$24) {\n    case 0:\n      {\n        const msg = format(\"An item with the same key has already been added. Key: {0}\", k$$4);\n        throw new Error(msg);\n        break;\n      }\n\n    case 1:\n      {\n        if (matchValue$$4[0]) {\n          const value$$1 = void getItemFromDict(this$$$8.hashMap, matchValue$$4[1]).push([k$$4, v$$1]);\n          void null;\n        } else {\n          this$$$8.hashMap.set(matchValue$$4[1], [[k$$4, v$$1]]);\n        }\n\n        break;\n      }\n  }\n}\nexport function MutableMap$00602$$ContainsKey$$2B595(this$$$9, k$$5) {\n  const matchValue$$5 = MutableMap$00602$$TryFindIndex$$2B595(this$$$9, k$$5);\n  var $target$$27;\n\n  if (matchValue$$5[0]) {\n    if (matchValue$$5[2] > -1) {\n      $target$$27 = 0;\n    } else {\n      $target$$27 = 1;\n    }\n  } else {\n    $target$$27 = 1;\n  }\n\n  switch ($target$$27) {\n    case 0:\n      {\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n}\nexport function MutableMap$00602$$Remove$$2B595(this$$$10, k$$6) {\n  const matchValue$$6 = MutableMap$00602$$TryFindIndex$$2B595(this$$$10, k$$6);\n  var $target$$30;\n\n  if (matchValue$$6[0]) {\n    if (matchValue$$6[2] > -1) {\n      $target$$30 = 0;\n    } else {\n      $target$$30 = 1;\n    }\n  } else {\n    $target$$30 = 1;\n  }\n\n  switch ($target$$30) {\n    case 0:\n      {\n        getItemFromDict(this$$$10.hashMap, matchValue$$6[1]).splice(matchValue$$6[2], 1);\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n}\n\nMutableMap$00602.prototype[Symbol.iterator] = function () {\n  var elems;\n  const this$$$11 = this;\n  return toIterator((elems = delay(function () {\n    return collect(function (pairs$$3) {\n      return map(function (pair$$3) {\n        return pair$$3;\n      }, pairs$$3);\n    }, this$$$11.hashMap.values());\n  }), getEnumerator(elems)));\n};\n\nMutableMap$00602.prototype.Add = function (item) {\n  const this$$$12 = this;\n  MutableMap$00602$$Add$$5BDDA1(this$$$12, item[0], item[1]);\n};\n\nMutableMap$00602.prototype.Clear = function () {\n  const this$$$13 = this;\n  MutableMap$00602$$Clear(this$$$13);\n};\n\nMutableMap$00602.prototype.Contains = function (item$$1) {\n  var p;\n  const this$$$14 = this;\n  const matchValue$$7 = MutableMap$00602$$TryFind$$2B595(this$$$14, item$$1[0]);\n  var $target$$31;\n\n  if (matchValue$$7 != null) {\n    if (p = matchValue$$7, equals(p[1], item$$1[1])) {\n      $target$$31 = 0;\n    } else {\n      $target$$31 = 1;\n    }\n  } else {\n    $target$$31 = 1;\n  }\n\n  switch ($target$$31) {\n    case 0:\n      {\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n};\n\nMutableMap$00602.prototype.CopyTo = function (array, arrayIndex) {\n  const this$$$15 = this;\n  iterateIndexed(function action(i$$10, e) {\n    array[arrayIndex + i$$10] = e;\n  }, this$$$15);\n};\n\nObject.defineProperty(MutableMap$00602.prototype, \"Count\", {\n  \"get\": function () {\n    const this$$$16 = this;\n    return MutableMap$00602$$get_Count(this$$$16) | 0;\n  }\n});\nObject.defineProperty(MutableMap$00602.prototype, \"IsReadOnly\", {\n  \"get\": function () {\n    return false;\n  }\n});\n\nMutableMap$00602.prototype.Remove = function (item$$2) {\n  const this$$$18 = this;\n  const matchValue$$8 = MutableMap$00602$$TryFind$$2B595(this$$$18, item$$2[0]);\n\n  if (matchValue$$8 != null) {\n    const pair$$4 = matchValue$$8;\n\n    if (equals(pair$$4[1], item$$2[1])) {\n      const value$$2 = MutableMap$00602$$Remove$$2B595(this$$$18, item$$2[0]);\n      void value$$2;\n    } else {\n      void null;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n};\n\nObject.defineProperty(MutableMap$00602.prototype, \"size\", {\n  \"get\": function () {\n    const this$$$19 = this;\n    return MutableMap$00602$$get_Count(this$$$19) | 0;\n  }\n});\n\nMutableMap$00602.prototype.clear = function () {\n  const this$$$20 = this;\n  MutableMap$00602$$Clear(this$$$20);\n};\n\nMutableMap$00602.prototype.delete = function (k$$7) {\n  const this$$$21 = this;\n  return MutableMap$00602$$Remove$$2B595(this$$$21, k$$7);\n};\n\nMutableMap$00602.prototype.entries = function () {\n  const this$$$22 = this;\n  return map(function mapping(x) {\n    return x;\n  }, this$$$22);\n};\n\nMutableMap$00602.prototype.get = function (k$$8) {\n  const this$$$23 = this;\n  return MutableMap$00602$$get_Item$$2B595(this$$$23, k$$8);\n};\n\nMutableMap$00602.prototype.has = function (k$$9) {\n  const this$$$24 = this;\n  return MutableMap$00602$$ContainsKey$$2B595(this$$$24, k$$9);\n};\n\nMutableMap$00602.prototype.keys = function () {\n  const this$$$25 = this;\n  return map(function mapping$$1(pair$$5) {\n    return pair$$5[0];\n  }, this$$$25);\n};\n\nMutableMap$00602.prototype.set = function (k$$10, v$$2) {\n  const this$$$26 = this;\n  MutableMap$00602$$set_Item$$5BDDA1(this$$$26, k$$10, v$$2);\n  return this$$$26;\n};\n\nMutableMap$00602.prototype.values = function () {\n  const this$$$27 = this;\n  return map(function mapping$$2(pair$$6) {\n    return pair$$6[1];\n  }, this$$$27);\n};","import { Record, List, declare, Union } from \"./Types.js\";\nimport { class_type, record_type, bool_type, list_type, union_type, int32_type } from \"./Reflection.js\";\nimport { value as value$$3, some } from \"./Option.js\";\nimport { iterate as iterate$$1, empty as empty$$1, toIterator, map as map$$2, unfold, getEnumerator, fold as fold$$1 } from \"./Seq.js\";\nimport { compare, structuralHash, isDisposable } from \"./Util.js\";\nimport { join, format } from \"./String.js\";\nimport { MutableMap$00602$$$$002Ector$$6623D9B3 as MutableMap$002400602$0024$0024$0024$0024002Ector$0024$00246623D9B3 } from \"./MutableMap\";\nexport const MapTree$00602 = declare(function Map_MapTree(tag, name, ...fields) {\n  this.tag = tag | 0;\n  this.name = name;\n  this.fields = fields;\n}, Union);\nexport function MapTree$00602$reflection($gen$$3, $gen$$4) {\n  return union_type(\"Map.MapTree`2\", [$gen$$3, $gen$$4], MapTree$00602, () => [\"MapEmpty\", [\"MapOne\", [[\"Item1\", $gen$$3], [\"Item2\", $gen$$4]]], [\"MapNode\", [[\"Item1\", $gen$$3], [\"Item2\", $gen$$4], [\"Item3\", MapTree$00602$reflection($gen$$3, $gen$$4)], [\"Item4\", MapTree$00602$reflection($gen$$3, $gen$$4)], [\"Item5\", int32_type]]]]);\n}\nexport function MapTreeModule$$$sizeAux($acc$$5, $m$$6) {\n  MapTreeModule$$$sizeAux: while (true) {\n    const acc = $acc$$5,\n          m = $m$$6;\n\n    switch (m.tag) {\n      case 1:\n        {\n          return acc + 1 | 0;\n        }\n\n      case 2:\n        {\n          $acc$$5 = MapTreeModule$$$sizeAux(acc + 1, m.fields[2]);\n          $m$$6 = m.fields[3];\n          continue MapTreeModule$$$sizeAux;\n        }\n\n      default:\n        {\n          return acc | 0;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$size(x) {\n  return MapTreeModule$$$sizeAux(0, x);\n}\nexport function MapTreeModule$$$empty() {\n  return new MapTree$00602(0, \"MapEmpty\");\n}\nexport function MapTreeModule$$$height(_arg1) {\n  switch (_arg1.tag) {\n    case 1:\n      {\n        return 1;\n      }\n\n    case 2:\n      {\n        return _arg1.fields[4] | 0;\n      }\n\n    default:\n      {\n        return 0;\n      }\n  }\n}\nexport function MapTreeModule$$$isEmpty(m$$1) {\n  if (m$$1.tag === 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function MapTreeModule$$$mk(l$$1, k, v, r$$1) {\n  var $target$$14;\n\n  if (l$$1.tag === 0) {\n    if (r$$1.tag === 0) {\n      $target$$14 = 0;\n    } else {\n      $target$$14 = 1;\n    }\n  } else {\n    $target$$14 = 1;\n  }\n\n  switch ($target$$14) {\n    case 0:\n      {\n        return new MapTree$00602(1, \"MapOne\", k, v);\n      }\n\n    case 1:\n      {\n        const hl = MapTreeModule$$$height(l$$1) | 0;\n        const hr = MapTreeModule$$$height(r$$1) | 0;\n        const m$$2 = (hl < hr ? hr : hl) | 0;\n        return new MapTree$00602(2, \"MapNode\", k, v, l$$1, r$$1, m$$2 + 1);\n      }\n  }\n}\nexport function MapTreeModule$$$rebalance(t1, k$$1, v$$1, t2) {\n  const t1h = MapTreeModule$$$height(t1) | 0;\n  const t2h = MapTreeModule$$$height(t2) | 0;\n\n  if (t2h > t1h + 2) {\n    if (t2.tag === 2) {\n      if (MapTreeModule$$$height(t2.fields[2]) > t1h + 1) {\n        if (t2.fields[2].tag === 2) {\n          return MapTreeModule$$$mk(MapTreeModule$$$mk(t1, k$$1, v$$1, t2.fields[2].fields[2]), t2.fields[2].fields[0], t2.fields[2].fields[1], MapTreeModule$$$mk(t2.fields[2].fields[3], t2.fields[0], t2.fields[1], t2.fields[3]));\n        } else {\n          throw new Error(\"rebalance\");\n        }\n      } else {\n        return MapTreeModule$$$mk(MapTreeModule$$$mk(t1, k$$1, v$$1, t2.fields[2]), t2.fields[0], t2.fields[1], t2.fields[3]);\n      }\n    } else {\n      throw new Error(\"rebalance\");\n    }\n  } else if (t1h > t2h + 2) {\n    if (t1.tag === 2) {\n      if (MapTreeModule$$$height(t1.fields[3]) > t2h + 1) {\n        if (t1.fields[3].tag === 2) {\n          return MapTreeModule$$$mk(MapTreeModule$$$mk(t1.fields[2], t1.fields[0], t1.fields[1], t1.fields[3].fields[2]), t1.fields[3].fields[0], t1.fields[3].fields[1], MapTreeModule$$$mk(t1.fields[3].fields[3], k$$1, v$$1, t2));\n        } else {\n          throw new Error(\"re  balance\");\n        }\n      } else {\n        return MapTreeModule$$$mk(t1.fields[2], t1.fields[0], t1.fields[1], MapTreeModule$$$mk(t1.fields[3], k$$1, v$$1, t2));\n      }\n    } else {\n      throw new Error(\"rebalance\");\n    }\n  } else {\n    return MapTreeModule$$$mk(t1, k$$1, v$$1, t2);\n  }\n}\nexport function MapTreeModule$$$add(comparer, k$$2, v$$2, m$$3) {\n  switch (m$$3.tag) {\n    case 1:\n      {\n        const c = comparer.Compare(k$$2, m$$3.fields[0]) | 0;\n\n        if (c < 0) {\n          return new MapTree$00602(2, \"MapNode\", k$$2, v$$2, new MapTree$00602(0, \"MapEmpty\"), m$$3, 2);\n        } else if (c === 0) {\n          return new MapTree$00602(1, \"MapOne\", k$$2, v$$2);\n        } else {\n          return new MapTree$00602(2, \"MapNode\", k$$2, v$$2, m$$3, new MapTree$00602(0, \"MapEmpty\"), 2);\n        }\n      }\n\n    case 2:\n      {\n        const c$$1 = comparer.Compare(k$$2, m$$3.fields[0]) | 0;\n\n        if (c$$1 < 0) {\n          return MapTreeModule$$$rebalance(MapTreeModule$$$add(comparer, k$$2, v$$2, m$$3.fields[2]), m$$3.fields[0], m$$3.fields[1], m$$3.fields[3]);\n        } else if (c$$1 === 0) {\n          return new MapTree$00602(2, \"MapNode\", k$$2, v$$2, m$$3.fields[2], m$$3.fields[3], m$$3.fields[4]);\n        } else {\n          return MapTreeModule$$$rebalance(m$$3.fields[2], m$$3.fields[0], m$$3.fields[1], MapTreeModule$$$add(comparer, k$$2, v$$2, m$$3.fields[3]));\n        }\n      }\n\n    default:\n      {\n        return new MapTree$00602(1, \"MapOne\", k$$2, v$$2);\n      }\n  }\n}\nexport function MapTreeModule$$$find($comparer$$1$$23, $k$$3$$24, $m$$4$$25) {\n  MapTreeModule$$$find: while (true) {\n    const comparer$$1 = $comparer$$1$$23,\n          k$$3 = $k$$3$$24,\n          m$$4 = $m$$4$$25;\n\n    switch (m$$4.tag) {\n      case 1:\n        {\n          const c$$2 = comparer$$1.Compare(k$$3, m$$4.fields[0]) | 0;\n\n          if (c$$2 === 0) {\n            return m$$4.fields[1];\n          } else {\n            throw new Error(\"key not found\");\n          }\n        }\n\n      case 2:\n        {\n          const c$$3 = comparer$$1.Compare(k$$3, m$$4.fields[0]) | 0;\n\n          if (c$$3 < 0) {\n            $comparer$$1$$23 = comparer$$1;\n            $k$$3$$24 = k$$3;\n            $m$$4$$25 = m$$4.fields[2];\n            continue MapTreeModule$$$find;\n          } else if (c$$3 === 0) {\n            return m$$4.fields[1];\n          } else {\n            $comparer$$1$$23 = comparer$$1;\n            $k$$3$$24 = k$$3;\n            $m$$4$$25 = m$$4.fields[3];\n            continue MapTreeModule$$$find;\n          }\n        }\n\n      default:\n        {\n          throw new Error(\"key not found\");\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$tryFind($comparer$$2$$26, $k$$4$$27, $m$$5$$28) {\n  MapTreeModule$$$tryFind: while (true) {\n    const comparer$$2 = $comparer$$2$$26,\n          k$$4 = $k$$4$$27,\n          m$$5 = $m$$5$$28;\n\n    switch (m$$5.tag) {\n      case 1:\n        {\n          const c$$4 = comparer$$2.Compare(k$$4, m$$5.fields[0]) | 0;\n\n          if (c$$4 === 0) {\n            return some(m$$5.fields[1]);\n          } else {\n            return undefined;\n          }\n        }\n\n      case 2:\n        {\n          const c$$5 = comparer$$2.Compare(k$$4, m$$5.fields[0]) | 0;\n\n          if (c$$5 < 0) {\n            $comparer$$2$$26 = comparer$$2;\n            $k$$4$$27 = k$$4;\n            $m$$5$$28 = m$$5.fields[2];\n            continue MapTreeModule$$$tryFind;\n          } else if (c$$5 === 0) {\n            return some(m$$5.fields[1]);\n          } else {\n            $comparer$$2$$26 = comparer$$2;\n            $k$$4$$27 = k$$4;\n            $m$$5$$28 = m$$5.fields[3];\n            continue MapTreeModule$$$tryFind;\n          }\n        }\n\n      default:\n        {\n          return undefined;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$partition1(comparer$$3, f, k$$5, v$$3, acc1, acc2) {\n  if (f(k$$5, v$$3)) {\n    return [MapTreeModule$$$add(comparer$$3, k$$5, v$$3, acc1), acc2];\n  } else {\n    return [acc1, MapTreeModule$$$add(comparer$$3, k$$5, v$$3, acc2)];\n  }\n}\nexport function MapTreeModule$$$partitionAux($comparer$$4$$35, $f$$1$$36, $s$$37, $acc_0$$38, $acc_1$$39) {\n  MapTreeModule$$$partitionAux: while (true) {\n    const comparer$$4 = $comparer$$4$$35,\n          f$$1 = $f$$1$$36,\n          s = $s$$37,\n          acc_0 = $acc_0$$38,\n          acc_1 = $acc_1$$39;\n\n    switch (s.tag) {\n      case 1:\n        {\n          return MapTreeModule$$$partition1(comparer$$4, f$$1, s.fields[0], s.fields[1], acc_0, acc_1);\n        }\n\n      case 2:\n        {\n          const acc$$2 = MapTreeModule$$$partitionAux(comparer$$4, f$$1, s.fields[3], acc_0, acc_1);\n          const acc$$3 = MapTreeModule$$$partition1(comparer$$4, f$$1, s.fields[0], s.fields[1], acc$$2[0], acc$$2[1]);\n          $comparer$$4$$35 = comparer$$4;\n          $f$$1$$36 = f$$1;\n          $s$$37 = s.fields[2];\n          $acc_0$$38 = acc$$3[0];\n          $acc_1$$39 = acc$$3[1];\n          continue MapTreeModule$$$partitionAux;\n        }\n\n      default:\n        {\n          return [acc_0, acc_1];\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$partition(comparer$$5, f$$2, s$$1) {\n  return MapTreeModule$$$partitionAux(comparer$$5, f$$2, s$$1, MapTreeModule$$$empty(), MapTreeModule$$$empty());\n}\nexport function MapTreeModule$$$filter1(comparer$$6, f$$3, k$$8, v$$6, acc$$4) {\n  if (f$$3(k$$8, v$$6)) {\n    return MapTreeModule$$$add(comparer$$6, k$$8, v$$6, acc$$4);\n  } else {\n    return acc$$4;\n  }\n}\nexport function MapTreeModule$$$filterAux($comparer$$7$$48, $f$$4$$49, $s$$2$$50, $acc$$5$$51) {\n  MapTreeModule$$$filterAux: while (true) {\n    const comparer$$7 = $comparer$$7$$48,\n          f$$4 = $f$$4$$49,\n          s$$2 = $s$$2$$50,\n          acc$$5 = $acc$$5$$51;\n\n    switch (s$$2.tag) {\n      case 1:\n        {\n          return MapTreeModule$$$filter1(comparer$$7, f$$4, s$$2.fields[0], s$$2.fields[1], acc$$5);\n        }\n\n      case 2:\n        {\n          const acc$$6 = MapTreeModule$$$filterAux(comparer$$7, f$$4, s$$2.fields[2], acc$$5);\n          const acc$$7 = MapTreeModule$$$filter1(comparer$$7, f$$4, s$$2.fields[0], s$$2.fields[1], acc$$6);\n          $comparer$$7$$48 = comparer$$7;\n          $f$$4$$49 = f$$4;\n          $s$$2$$50 = s$$2.fields[3];\n          $acc$$5$$51 = acc$$7;\n          continue MapTreeModule$$$filterAux;\n        }\n\n      default:\n        {\n          return acc$$5;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$filter(comparer$$8, f$$5, s$$3) {\n  return MapTreeModule$$$filterAux(comparer$$8, f$$5, s$$3, MapTreeModule$$$empty());\n}\nexport function MapTreeModule$$$spliceOutSuccessor(m$$6) {\n  switch (m$$6.tag) {\n    case 1:\n      {\n        return [m$$6.fields[0], m$$6.fields[1], new MapTree$00602(0, \"MapEmpty\")];\n      }\n\n    case 2:\n      {\n        if (m$$6.fields[2].tag === 0) {\n          return [m$$6.fields[0], m$$6.fields[1], m$$6.fields[3]];\n        } else {\n          const patternInput = MapTreeModule$$$spliceOutSuccessor(m$$6.fields[2]);\n          return [patternInput[0], patternInput[1], MapTreeModule$$$mk(patternInput[2], m$$6.fields[0], m$$6.fields[1], m$$6.fields[3])];\n        }\n      }\n\n    default:\n      {\n        throw new Error(\"internal error: Map.spliceOutSuccessor\");\n      }\n  }\n}\nexport function MapTreeModule$$$remove(comparer$$9, k$$11, m$$7) {\n  switch (m$$7.tag) {\n    case 1:\n      {\n        const c$$6 = comparer$$9.Compare(k$$11, m$$7.fields[0]) | 0;\n\n        if (c$$6 === 0) {\n          return new MapTree$00602(0, \"MapEmpty\");\n        } else {\n          return m$$7;\n        }\n      }\n\n    case 2:\n      {\n        const c$$7 = comparer$$9.Compare(k$$11, m$$7.fields[0]) | 0;\n\n        if (c$$7 < 0) {\n          return MapTreeModule$$$rebalance(MapTreeModule$$$remove(comparer$$9, k$$11, m$$7.fields[2]), m$$7.fields[0], m$$7.fields[1], m$$7.fields[3]);\n        } else if (c$$7 === 0) {\n          if (m$$7.fields[2].tag === 0) {\n            return m$$7.fields[3];\n          } else if (m$$7.fields[3].tag === 0) {\n            return m$$7.fields[2];\n          } else {\n            const patternInput$$1 = MapTreeModule$$$spliceOutSuccessor(m$$7.fields[3]);\n            return MapTreeModule$$$mk(m$$7.fields[2], patternInput$$1[0], patternInput$$1[1], patternInput$$1[2]);\n          }\n        } else {\n          return MapTreeModule$$$rebalance(m$$7.fields[2], m$$7.fields[0], m$$7.fields[1], MapTreeModule$$$remove(comparer$$9, k$$11, m$$7.fields[3]));\n        }\n      }\n\n    default:\n      {\n        return MapTreeModule$$$empty();\n      }\n  }\n}\nexport function MapTreeModule$$$mem($comparer$$10$$59, $k$$12$$60, $m$$8$$61) {\n  MapTreeModule$$$mem: while (true) {\n    const comparer$$10 = $comparer$$10$$59,\n          k$$12 = $k$$12$$60,\n          m$$8 = $m$$8$$61;\n\n    switch (m$$8.tag) {\n      case 1:\n        {\n          return comparer$$10.Compare(k$$12, m$$8.fields[0]) === 0;\n        }\n\n      case 2:\n        {\n          const c$$8 = comparer$$10.Compare(k$$12, m$$8.fields[0]) | 0;\n\n          if (c$$8 < 0) {\n            $comparer$$10$$59 = comparer$$10;\n            $k$$12$$60 = k$$12;\n            $m$$8$$61 = m$$8.fields[2];\n            continue MapTreeModule$$$mem;\n          } else if (c$$8 === 0) {\n            return true;\n          } else {\n            $comparer$$10$$59 = comparer$$10;\n            $k$$12$$60 = k$$12;\n            $m$$8$$61 = m$$8.fields[3];\n            continue MapTreeModule$$$mem;\n          }\n        }\n\n      default:\n        {\n          return false;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$iter($f$$6$$62, $m$$9$$63) {\n  MapTreeModule$$$iter: while (true) {\n    const f$$6 = $f$$6$$62,\n          m$$9 = $m$$9$$63;\n\n    switch (m$$9.tag) {\n      case 1:\n        {\n          f$$6(m$$9.fields[0], m$$9.fields[1]);\n          break;\n        }\n\n      case 2:\n        {\n          MapTreeModule$$$iter(f$$6, m$$9.fields[2]);\n          f$$6(m$$9.fields[0], m$$9.fields[1]);\n          $f$$6$$62 = f$$6;\n          $m$$9$$63 = m$$9.fields[3];\n          continue MapTreeModule$$$iter;\n          break;\n        }\n\n      default:\n        {\n          void null;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$tryPick($f$$7$$64, $m$$10$$65) {\n  MapTreeModule$$$tryPick: while (true) {\n    const f$$7 = $f$$7$$64,\n          m$$10 = $m$$10$$65;\n\n    switch (m$$10.tag) {\n      case 1:\n        {\n          return f$$7(m$$10.fields[0], m$$10.fields[1]);\n        }\n\n      case 2:\n        {\n          const matchValue$$2 = MapTreeModule$$$tryPick(f$$7, m$$10.fields[2]);\n\n          if (matchValue$$2 == null) {\n            const matchValue$$3 = f$$7(m$$10.fields[0], m$$10.fields[1]);\n\n            if (matchValue$$3 == null) {\n              $f$$7$$64 = f$$7;\n              $m$$10$$65 = m$$10.fields[3];\n              continue MapTreeModule$$$tryPick;\n            } else {\n              return matchValue$$3;\n            }\n          } else {\n            return matchValue$$2;\n          }\n        }\n\n      default:\n        {\n          return undefined;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$exists($f$$8$$66, $m$$11$$67) {\n  MapTreeModule$$$exists: while (true) {\n    const f$$8 = $f$$8$$66,\n          m$$11 = $m$$11$$67;\n\n    switch (m$$11.tag) {\n      case 1:\n        {\n          return f$$8(m$$11.fields[0], m$$11.fields[1]);\n        }\n\n      case 2:\n        {\n          if (MapTreeModule$$$exists(f$$8, m$$11.fields[2]) ? true : f$$8(m$$11.fields[0], m$$11.fields[1])) {\n            return true;\n          } else {\n            $f$$8$$66 = f$$8;\n            $m$$11$$67 = m$$11.fields[3];\n            continue MapTreeModule$$$exists;\n          }\n        }\n\n      default:\n        {\n          return false;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$forall($f$$9$$68, $m$$12$$69) {\n  MapTreeModule$$$forall: while (true) {\n    const f$$9 = $f$$9$$68,\n          m$$12 = $m$$12$$69;\n\n    switch (m$$12.tag) {\n      case 1:\n        {\n          return f$$9(m$$12.fields[0], m$$12.fields[1]);\n        }\n\n      case 2:\n        {\n          if (MapTreeModule$$$forall(f$$9, m$$12.fields[2]) ? f$$9(m$$12.fields[0], m$$12.fields[1]) : false) {\n            $f$$9$$68 = f$$9;\n            $m$$12$$69 = m$$12.fields[3];\n            continue MapTreeModule$$$forall;\n          } else {\n            return false;\n          }\n        }\n\n      default:\n        {\n          return true;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$map(f$$10, m$$13) {\n  switch (m$$13.tag) {\n    case 1:\n      {\n        return new MapTree$00602(1, \"MapOne\", m$$13.fields[0], f$$10(m$$13.fields[1]));\n      }\n\n    case 2:\n      {\n        const l2 = MapTreeModule$$$map(f$$10, m$$13.fields[2]);\n        const v2$$16 = f$$10(m$$13.fields[1]);\n        const r2 = MapTreeModule$$$map(f$$10, m$$13.fields[3]);\n        return new MapTree$00602(2, \"MapNode\", m$$13.fields[0], v2$$16, l2, r2, m$$13.fields[4]);\n      }\n\n    default:\n      {\n        return MapTreeModule$$$empty();\n      }\n  }\n}\nexport function MapTreeModule$$$mapi(f$$11, m$$14) {\n  switch (m$$14.tag) {\n    case 1:\n      {\n        return new MapTree$00602(1, \"MapOne\", m$$14.fields[0], f$$11(m$$14.fields[0], m$$14.fields[1]));\n      }\n\n    case 2:\n      {\n        const l2$$1 = MapTreeModule$$$mapi(f$$11, m$$14.fields[2]);\n        const v2$$17 = f$$11(m$$14.fields[0], m$$14.fields[1]);\n        const r2$$1 = MapTreeModule$$$mapi(f$$11, m$$14.fields[3]);\n        return new MapTree$00602(2, \"MapNode\", m$$14.fields[0], v2$$17, l2$$1, r2$$1, m$$14.fields[4]);\n      }\n\n    default:\n      {\n        return MapTreeModule$$$empty();\n      }\n  }\n}\nexport function MapTreeModule$$$foldBack($f$$12$$74, $m$$15$$75, $x$$1$$76) {\n  MapTreeModule$$$foldBack: while (true) {\n    const f$$12 = $f$$12$$74,\n          m$$15 = $m$$15$$75,\n          x$$1 = $x$$1$$76;\n\n    switch (m$$15.tag) {\n      case 1:\n        {\n          return f$$12(m$$15.fields[0], m$$15.fields[1], x$$1);\n        }\n\n      case 2:\n        {\n          const x$$2 = MapTreeModule$$$foldBack(f$$12, m$$15.fields[3], x$$1);\n          const x$$3 = f$$12(m$$15.fields[0], m$$15.fields[1], x$$2);\n          $f$$12$$74 = f$$12;\n          $m$$15$$75 = m$$15.fields[2];\n          $x$$1$$76 = x$$3;\n          continue MapTreeModule$$$foldBack;\n        }\n\n      default:\n        {\n          return x$$1;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$fold($f$$13$$77, $x$$4$$78, $m$$16$$79) {\n  MapTreeModule$$$fold: while (true) {\n    const f$$13 = $f$$13$$77,\n          x$$4 = $x$$4$$78,\n          m$$16 = $m$$16$$79;\n\n    switch (m$$16.tag) {\n      case 1:\n        {\n          return f$$13(x$$4, m$$16.fields[0], m$$16.fields[1]);\n        }\n\n      case 2:\n        {\n          const x$$5 = MapTreeModule$$$fold(f$$13, x$$4, m$$16.fields[2]);\n          const x$$6 = f$$13(x$$5, m$$16.fields[0], m$$16.fields[1]);\n          $f$$13$$77 = f$$13;\n          $x$$4$$78 = x$$6;\n          $m$$16$$79 = m$$16.fields[3];\n          continue MapTreeModule$$$fold;\n        }\n\n      default:\n        {\n          return x$$4;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$foldFromTo(comparer$$11, lo, hi, f$$14, m$$17, x$$7) {\n  switch (m$$17.tag) {\n    case 1:\n      {\n        const cLoKey = comparer$$11.Compare(lo, m$$17.fields[0]) | 0;\n        const cKeyHi = comparer$$11.Compare(m$$17.fields[0], hi) | 0;\n        const x$$8 = (cLoKey <= 0 ? cKeyHi <= 0 : false) ? f$$14(m$$17.fields[0], m$$17.fields[1], x$$7) : x$$7;\n        return x$$8;\n      }\n\n    case 2:\n      {\n        const cLoKey$$1 = comparer$$11.Compare(lo, m$$17.fields[0]) | 0;\n        const cKeyHi$$1 = comparer$$11.Compare(m$$17.fields[0], hi) | 0;\n        const x$$9 = cLoKey$$1 < 0 ? MapTreeModule$$$foldFromTo(comparer$$11, lo, hi, f$$14, m$$17.fields[2], x$$7) : x$$7;\n        const x$$10 = (cLoKey$$1 <= 0 ? cKeyHi$$1 <= 0 : false) ? f$$14(m$$17.fields[0], m$$17.fields[1], x$$9) : x$$9;\n        const x$$11 = cKeyHi$$1 < 0 ? MapTreeModule$$$foldFromTo(comparer$$11, lo, hi, f$$14, m$$17.fields[3], x$$10) : x$$10;\n        return x$$11;\n      }\n\n    default:\n      {\n        return x$$7;\n      }\n  }\n}\nexport function MapTreeModule$$$foldSection(comparer$$12, lo$$1, hi$$1, f$$15, m$$18, x$$12) {\n  if (comparer$$12.Compare(lo$$1, hi$$1) === 1) {\n    return x$$12;\n  } else {\n    return MapTreeModule$$$foldFromTo(comparer$$12, lo$$1, hi$$1, f$$15, m$$18, x$$12);\n  }\n}\nexport function MapTreeModule$$$loop($m$$19$$92, $acc$$8$$93) {\n  MapTreeModule$$$loop: while (true) {\n    const m$$19 = $m$$19$$92,\n          acc$$8 = $acc$$8$$93;\n\n    switch (m$$19.tag) {\n      case 1:\n        {\n          return new List([m$$19.fields[0], m$$19.fields[1]], acc$$8);\n        }\n\n      case 2:\n        {\n          $m$$19$$92 = m$$19.fields[2];\n          $acc$$8$$93 = new List([m$$19.fields[0], m$$19.fields[1]], MapTreeModule$$$loop(m$$19.fields[3], acc$$8));\n          continue MapTreeModule$$$loop;\n        }\n\n      default:\n        {\n          return acc$$8;\n        }\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$toList(m$$20) {\n  return MapTreeModule$$$loop(m$$20, new List());\n}\nexport function MapTreeModule$$$ofList(comparer$$13, l$$20) {\n  return fold$$1(function (acc$$9, tupledArg) {\n    return MapTreeModule$$$add(comparer$$13, tupledArg[0], tupledArg[1], acc$$9);\n  }, MapTreeModule$$$empty(), l$$20);\n}\nexport function MapTreeModule$$$mkFromEnumerator($comparer$$14$$97, $acc$$10$$98, $e$$99) {\n  MapTreeModule$$$mkFromEnumerator: while (true) {\n    const comparer$$14 = $comparer$$14$$97,\n          acc$$10 = $acc$$10$$98,\n          e = $e$$99;\n\n    if (e.MoveNext()) {\n      const patternInput$$2 = e.Current;\n      $comparer$$14$$97 = comparer$$14;\n      $acc$$10$$98 = MapTreeModule$$$add(comparer$$14, patternInput$$2[0], patternInput$$2[1], acc$$10);\n      $e$$99 = e;\n      continue MapTreeModule$$$mkFromEnumerator;\n    } else {\n      return acc$$10;\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$ofArray(comparer$$15, arr) {\n  let res$$2 = MapTreeModule$$$empty();\n\n  for (let i = 0; i <= arr.length - 1; i++) {\n    const patternInput$$3 = arr[i];\n    res$$2 = MapTreeModule$$$add(comparer$$15, patternInput$$3[0], patternInput$$3[1], res$$2);\n  }\n\n  return res$$2;\n}\nexport function MapTreeModule$$$ofSeq(comparer$$16, c$$9) {\n  const ie = getEnumerator(c$$9);\n\n  try {\n    return MapTreeModule$$$mkFromEnumerator(comparer$$16, MapTreeModule$$$empty(), ie);\n  } finally {\n    if (isDisposable(ie)) {\n      ie.Dispose();\n    } else {\n      void null;\n    }\n  }\n}\nexport function MapTreeModule$$$copyToArray(s$$4, arr$$1, i$$1) {\n  let j = i$$1 | 0;\n  MapTreeModule$$$iter(function f$$16(x$$15, y$$2) {\n    arr$$1[j] = [x$$15, y$$2];\n    j = j + 1;\n  }, s$$4);\n}\nexport const MapTreeModule$002EMapIterator$00602 = declare(function Map_MapTreeModule_MapIterator(stack, started) {\n  this.stack = stack;\n  this.started = started;\n}, Record);\nexport function MapTreeModule$002EMapIterator$00602$reflection($gen$$109, $gen$$110) {\n  return record_type(\"Map.MapTreeModule.MapIterator`2\", [$gen$$109, $gen$$110], MapTreeModule$002EMapIterator$00602, () => [[\"stack\", list_type(MapTree$00602$reflection($gen$$109, $gen$$110))], [\"started\", bool_type]]);\n}\nexport function MapTreeModule$$$collapseLHS($stack$$111) {\n  MapTreeModule$$$collapseLHS: while (true) {\n    const stack = $stack$$111;\n\n    if (stack.tail != null) {\n      if (stack.head.tag === 1) {\n        return stack;\n      } else if (stack.head.tag === 2) {\n        $stack$$111 = new List(stack.head.fields[2], new List(new MapTree$00602(1, \"MapOne\", stack.head.fields[0], stack.head.fields[1]), new List(stack.head.fields[3], stack.tail)));\n        continue MapTreeModule$$$collapseLHS;\n      } else {\n        $stack$$111 = stack.tail;\n        continue MapTreeModule$$$collapseLHS;\n      }\n    } else {\n      return new List();\n    }\n\n    break;\n  }\n}\nexport function MapTreeModule$$$mkIterator(s$$5) {\n  return new MapTreeModule$002EMapIterator$00602(MapTreeModule$$$collapseLHS(new List(s$$5, new List())), false);\n}\nexport function MapTreeModule$$$notStarted() {\n  throw new Error(\"enumeration not started\");\n}\nexport function MapTreeModule$$$alreadyFinished() {\n  throw new Error(\"enumeration already finished\");\n}\nexport function MapTreeModule$$$current(i$$2) {\n  if (i$$2.started) {\n    const matchValue$$4 = i$$2.stack;\n\n    if (matchValue$$4.tail == null) {\n      return MapTreeModule$$$alreadyFinished();\n    } else if (matchValue$$4.head.tag === 1) {\n      return [matchValue$$4.head.fields[0], matchValue$$4.head.fields[1]];\n    } else {\n      throw new Error(\"Please report error: Map iterator, unexpected stack for current\");\n    }\n  } else {\n    return MapTreeModule$$$notStarted();\n  }\n}\nexport function MapTreeModule$$$moveNext(i$$3) {\n  if (i$$3.started) {\n    const matchValue$$5 = i$$3.stack;\n\n    if (matchValue$$5.tail == null) {\n      return false;\n    } else if (matchValue$$5.head.tag === 1) {\n      i$$3.stack = MapTreeModule$$$collapseLHS(matchValue$$5.tail);\n      return !(i$$3.stack.tail == null);\n    } else {\n      throw new Error(\"Please report error: Map iterator, unexpected stack for moveNext\");\n    }\n  } else {\n    i$$3.started = true;\n    return !(i$$3.stack.tail == null);\n  }\n}\nexport const MapTreeModule$002EmkIEnumerator$0027$00602 = declare(function Map_MapTreeModule_mkIEnumerator_(s$$6) {\n  const $this$$1 = this;\n  $this$$1.s = s$$6;\n  $this$$1.i = MapTreeModule$$$mkIterator($this$$1.s);\n  void null;\n});\nexport function MapTreeModule$002EmkIEnumerator$0027$00602$reflection($gen$$115, $gen$$116) {\n  return class_type(\"Map.MapTreeModule.mkIEnumerator'`2\", [$gen$$115, $gen$$116], MapTreeModule$002EmkIEnumerator$0027$00602);\n}\nexport function MapTreeModule$002EmkIEnumerator$0027$00602$$$$002Ector$$Z26BC498C(s$$6) {\n  return this instanceof MapTreeModule$002EmkIEnumerator$0027$00602 ? MapTreeModule$002EmkIEnumerator$0027$00602.call(this, s$$6) : new MapTreeModule$002EmkIEnumerator$0027$00602(s$$6);\n}\nObject.defineProperty(MapTreeModule$002EmkIEnumerator$0027$00602.prototype, \"Current\", {\n  \"get\": function () {\n    const __ = this;\n    return MapTreeModule$$$current(__.i);\n  }\n});\n\nMapTreeModule$002EmkIEnumerator$0027$00602.prototype.MoveNext = function () {\n  const __$$1 = this;\n  return MapTreeModule$$$moveNext(__$$1.i);\n};\n\nMapTreeModule$002EmkIEnumerator$0027$00602.prototype.Reset = function () {\n  const __$$2 = this;\n  __$$2.i = MapTreeModule$$$mkIterator(__$$2.s);\n};\n\nMapTreeModule$002EmkIEnumerator$0027$00602.prototype.Dispose = function () {\n  void null;\n};\n\nexport function MapTreeModule$$$mkIEnumerator(s$$7) {\n  return MapTreeModule$002EmkIEnumerator$0027$00602$$$$002Ector$$Z26BC498C(s$$7);\n}\nexport function MapTreeModule$$$toSeq(s$$8) {\n  const en = MapTreeModule$$$mkIEnumerator(s$$8);\n  return unfold(function generator(en$$1) {\n    if (en$$1.MoveNext()) {\n      return [en$$1.Current, en$$1];\n    } else {\n      return undefined;\n    }\n  }, en);\n}\nexport const FSharpMap = declare(function Map_Map(comparer$$17, tree) {\n  const $this$$2 = this;\n  $this$$2.comparer = comparer$$17;\n  $this$$2.tree = tree;\n  void null;\n});\nexport function FSharpMap$reflection($gen$$120, $gen$$121) {\n  return class_type(\"Map.FSharpMap\", [$gen$$120, $gen$$121], FSharpMap);\n}\nexport function FSharpMap$$$$002Ector$$58ADD115(comparer$$17, tree) {\n  return this instanceof FSharpMap ? FSharpMap.call(this, comparer$$17, tree) : new FSharpMap(comparer$$17, tree);\n}\nexport function FSharpMap$$get_Comparer(__$$4) {\n  return __$$4.comparer;\n}\nexport function FSharpMap$$get_Tree(__$$5) {\n  return __$$5.tree;\n}\nexport function FSharpMap$$Add$$5BDDA1(__$$6, k$$28, v$$24) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$6.comparer, MapTreeModule$$$add(__$$6.comparer, k$$28, v$$24, __$$6.tree));\n}\nexport function FSharpMap$$get_IsEmpty(__$$7) {\n  return MapTreeModule$$$isEmpty(__$$7.tree);\n}\nexport function FSharpMap$$get_Item$$2B595(__$$8, k$$29) {\n  return MapTreeModule$$$find(__$$8.comparer, k$$29, __$$8.tree);\n}\nexport function FSharpMap$$TryGetValue$$5BDDA1(__$$9, k$$30, defValue) {\n  const matchValue$$6 = MapTreeModule$$$tryFind(__$$9.comparer, k$$30, __$$9.tree);\n\n  if (matchValue$$6 == null) {\n    return [false, defValue];\n  } else {\n    const v$$25 = value$$3(matchValue$$6);\n    return [true, v$$25];\n  }\n}\nexport function FSharpMap$$TryPick$$72321DD7(__$$10, f$$17) {\n  return MapTreeModule$$$tryPick(f$$17, __$$10.tree);\n}\nexport function FSharpMap$$Exists$$Z395DDC35(__$$11, f$$18) {\n  return MapTreeModule$$$exists(f$$18, __$$11.tree);\n}\nexport function FSharpMap$$Filter$$Z395DDC35(__$$12, f$$19) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$12.comparer, MapTreeModule$$$filter(__$$12.comparer, f$$19, __$$12.tree));\n}\nexport function FSharpMap$$ForAll$$Z395DDC35(__$$13, f$$20) {\n  return MapTreeModule$$$forall(f$$20, __$$13.tree);\n}\nexport function FSharpMap$$Fold(__$$14, f$$21, acc$$11) {\n  return MapTreeModule$$$foldBack(f$$21, __$$14.tree, acc$$11);\n}\nexport function FSharpMap$$FoldSection(__$$15, lo$$2, hi$$2, f$$22, acc$$12) {\n  return MapTreeModule$$$foldSection(__$$15.comparer, lo$$2, hi$$2, f$$22, __$$15.tree, acc$$12);\n}\nexport function FSharpMap$$Iterate$$1DCFB91D(__$$16, f$$23) {\n  MapTreeModule$$$iter(f$$23, __$$16.tree);\n}\nexport function FSharpMap$$MapRange$$6DC7247(__$$17, f$$24) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$17.comparer, MapTreeModule$$$map(f$$24, __$$17.tree));\n}\nexport function FSharpMap$$Map$$Z6F6B671C(__$$18, f$$25) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$18.comparer, MapTreeModule$$$mapi(f$$25, __$$18.tree));\n}\nexport function FSharpMap$$Partition$$Z395DDC35(__$$19, f$$26) {\n  const patternInput$$4 = MapTreeModule$$$partition(__$$19.comparer, f$$26, __$$19.tree);\n  return [FSharpMap$$$$002Ector$$58ADD115(__$$19.comparer, patternInput$$4[0]), FSharpMap$$$$002Ector$$58ADD115(__$$19.comparer, patternInput$$4[1])];\n}\nexport function FSharpMap$$get_Count(__$$20) {\n  return MapTreeModule$$$size(__$$20.tree);\n}\nexport function FSharpMap$$ContainsKey$$2B595(__$$21, k$$31) {\n  return MapTreeModule$$$mem(__$$21.comparer, k$$31, __$$21.tree);\n}\nexport function FSharpMap$$Remove$$2B595(__$$22, k$$32) {\n  return FSharpMap$$$$002Ector$$58ADD115(__$$22.comparer, MapTreeModule$$$remove(__$$22.comparer, k$$32, __$$22.tree));\n}\nexport function FSharpMap$$TryFind$$2B595(__$$23, k$$33) {\n  return MapTreeModule$$$tryFind(__$$23.comparer, k$$33, __$$23.tree);\n}\nexport function FSharpMap$$ToList(__$$24) {\n  return MapTreeModule$$$toList(__$$24.tree);\n}\n\nFSharpMap.prototype.toString = function () {\n  const this$ = this;\n  let str;\n  let strings;\n  strings = map$$2(function toStr(kv) {\n    return format(\"({0}, {1})\", kv[0], kv[1]);\n  }, this$);\n  str = join(\"; \", strings);\n  return \"map [\" + str + \"]\";\n};\n\nFSharpMap.prototype.GetHashCode = function () {\n  const this$$$1 = this;\n\n  const combineHash = function combineHash(x$$16, y$$3) {\n    return (x$$16 << 1) + y$$3 + 631;\n  };\n\n  let res$$3 = 0;\n  const e$$1 = MapTreeModule$$$mkIEnumerator(FSharpMap$$get_Tree(this$$$1));\n\n  while (e$$1.MoveNext()) {\n    const patternInput$$5 = e$$1.Current;\n    const activePatternResult3678 = patternInput$$5;\n    res$$3 = combineHash(res$$3, structuralHash(activePatternResult3678[0]));\n    res$$3 = combineHash(res$$3, structuralHash(activePatternResult3678[1]));\n  }\n\n  return Math.abs(res$$3) | 0;\n};\n\nFSharpMap.prototype.Equals = function (that) {\n  const this$$$2 = this;\n  return this$$$2.CompareTo(that) === 0;\n};\n\nFSharpMap.prototype[Symbol.iterator] = function () {\n  const __$$25 = this;\n  return toIterator(MapTreeModule$$$mkIEnumerator(__$$25.tree));\n};\n\nFSharpMap.prototype.CompareTo = function (obj) {\n  const m$$22 = this;\n  let res$$4 = 0;\n  let finished = false;\n  const e1 = MapTreeModule$$$mkIEnumerator(FSharpMap$$get_Tree(m$$22));\n\n  try {\n    const e2 = MapTreeModule$$$mkIEnumerator(FSharpMap$$get_Tree(obj));\n\n    try {\n      while (!finished ? res$$4 === 0 : false) {\n        const matchValue$$7 = [e1.MoveNext(), e2.MoveNext()];\n\n        if (matchValue$$7[0]) {\n          if (matchValue$$7[1]) {\n            const kvp1 = e1.Current;\n            const kvp2 = e2.Current;\n            const c$$10 = m$$22.comparer.Compare(kvp1[0], kvp2[0]) | 0;\n            res$$4 = c$$10 !== 0 ? c$$10 : compare(kvp1[1], kvp2[1]);\n          } else {\n            res$$4 = 1;\n          }\n        } else if (matchValue$$7[1]) {\n          res$$4 = -1;\n        } else {\n          finished = true;\n        }\n      }\n\n      return res$$4 | 0;\n    } finally {\n      if (isDisposable(e2)) {\n        e2.Dispose();\n      } else {\n        void null;\n      }\n    }\n  } finally {\n    if (isDisposable(e1)) {\n      e1.Dispose();\n    } else {\n      void null;\n    }\n  }\n};\n\nObject.defineProperty(FSharpMap.prototype, \"size\", {\n  \"get\": function () {\n    const this$$$3 = this;\n    return FSharpMap$$get_Count(this$$$3) | 0;\n  }\n});\n\nFSharpMap.prototype.clear = function () {\n  throw new Error(\"Map cannot be mutated\");\n};\n\nFSharpMap.prototype.delete = function (_arg1$$1) {\n  throw new Error(\"Map cannot be mutated\");\n};\n\nFSharpMap.prototype.entries = function () {\n  const this$$$4 = this;\n  return MapTreeModule$$$toSeq(FSharpMap$$get_Tree(this$$$4));\n};\n\nFSharpMap.prototype.get = function (k$$34) {\n  const this$$$5 = this;\n  return FSharpMap$$get_Item$$2B595(this$$$5, k$$34);\n};\n\nFSharpMap.prototype.has = function (k$$35) {\n  const this$$$6 = this;\n  return FSharpMap$$ContainsKey$$2B595(this$$$6, k$$35);\n};\n\nFSharpMap.prototype.keys = function () {\n  const this$$$7 = this;\n  const source$$1 = MapTreeModule$$$toSeq(FSharpMap$$get_Tree(this$$$7));\n  return map$$2(function mapping(kv$$1) {\n    return kv$$1[0];\n  }, source$$1);\n};\n\nFSharpMap.prototype.set = function (k$$36, v$$26) {\n  throw new Error(\"Map cannot be mutated\");\n};\n\nFSharpMap.prototype.values = function () {\n  const this$$$8 = this;\n  const source$$2 = MapTreeModule$$$toSeq(FSharpMap$$get_Tree(this$$$8));\n  return map$$2(function mapping$$1(kv$$2) {\n    return kv$$2[1];\n  }, source$$2);\n};\n\nexport function isEmpty(m$$23) {\n  return FSharpMap$$get_IsEmpty(m$$23);\n}\nexport function add(k$$37, v$$27, m$$24) {\n  return FSharpMap$$Add$$5BDDA1(m$$24, k$$37, v$$27);\n}\nexport function find(k$$38, m$$25) {\n  return FSharpMap$$get_Item$$2B595(m$$25, k$$38);\n}\nexport function tryFind(k$$39, m$$26) {\n  return FSharpMap$$TryFind$$2B595(m$$26, k$$39);\n}\nexport function remove(k$$40, m$$27) {\n  return FSharpMap$$Remove$$2B595(m$$27, k$$40);\n}\nexport function containsKey(k$$41, m$$28) {\n  return FSharpMap$$ContainsKey$$2B595(m$$28, k$$41);\n}\nexport function iterate(f$$27, m$$29) {\n  FSharpMap$$Iterate$$1DCFB91D(m$$29, f$$27);\n}\nexport function tryPick(f$$28, m$$30) {\n  return FSharpMap$$TryPick$$72321DD7(m$$30, f$$28);\n}\nexport function pick(f$$29, m$$31) {\n  const matchValue$$8 = tryPick(f$$29, m$$31);\n\n  if (matchValue$$8 != null) {\n    const res$$5 = value$$3(matchValue$$8);\n    return res$$5;\n  } else {\n    throw new Error(\"key not found\");\n  }\n}\nexport function exists(f$$30, m$$32) {\n  return FSharpMap$$Exists$$Z395DDC35(m$$32, f$$30);\n}\nexport function filter(f$$31, m$$33) {\n  return FSharpMap$$Filter$$Z395DDC35(m$$33, f$$31);\n}\nexport function partition(f$$32, m$$34) {\n  return FSharpMap$$Partition$$Z395DDC35(m$$34, f$$32);\n}\nexport function forAll(f$$33, m$$35) {\n  return FSharpMap$$ForAll$$Z395DDC35(m$$35, f$$33);\n}\nexport function mapRange(f$$34, m$$36) {\n  return FSharpMap$$MapRange$$6DC7247(m$$36, f$$34);\n}\nexport function map(f$$35, m$$37) {\n  return FSharpMap$$Map$$Z6F6B671C(m$$37, f$$35);\n}\nexport function fold(f$$36, z, m$$38) {\n  return MapTreeModule$$$fold(f$$36, z, FSharpMap$$get_Tree(m$$38));\n}\nexport function foldBack(f$$37, m$$39, z$$1) {\n  return MapTreeModule$$$foldBack(f$$37, FSharpMap$$get_Tree(m$$39), z$$1);\n}\nexport function toSeq(m$$40) {\n  return MapTreeModule$$$toSeq(FSharpMap$$get_Tree(m$$40));\n}\nexport function findKey(f$$38, m$$41) {\n  let _arg1$$2;\n\n  const m$$42 = FSharpMap$$get_Tree(m$$41);\n  _arg1$$2 = MapTreeModule$$$tryPick(function f$$39(k$$42, v$$28) {\n    if (f$$38(k$$42, v$$28)) {\n      return some(k$$42);\n    } else {\n      return undefined;\n    }\n  }, m$$42);\n\n  if (_arg1$$2 == null) {\n    throw new Error(\"Key not found\");\n  } else {\n    const k$$43 = value$$3(_arg1$$2);\n    return k$$43;\n  }\n}\nexport function tryFindKey(f$$40, m$$43) {\n  const m$$44 = FSharpMap$$get_Tree(m$$43);\n  return MapTreeModule$$$tryPick(function f$$41(k$$44, v$$29) {\n    if (f$$40(k$$44, v$$29)) {\n      return some(k$$44);\n    } else {\n      return undefined;\n    }\n  }, m$$44);\n}\nexport function ofList(l$$22, comparer$$18) {\n  return FSharpMap$$$$002Ector$$58ADD115(comparer$$18, MapTreeModule$$$ofList(comparer$$18, l$$22));\n}\nexport function ofSeq(l$$23, comparer$$19) {\n  return FSharpMap$$$$002Ector$$58ADD115(comparer$$19, MapTreeModule$$$ofSeq(comparer$$19, l$$23));\n}\nexport function ofArray(array, comparer$$20) {\n  return FSharpMap$$$$002Ector$$58ADD115(comparer$$20, MapTreeModule$$$ofArray(comparer$$20, array));\n}\nexport function toList(m$$45) {\n  return FSharpMap$$ToList(m$$45);\n}\nexport function toArray(m$$46) {\n  let res$$6;\n  const len = FSharpMap$$get_Count(m$$46) | 0;\n  res$$6 = new Array(len);\n  MapTreeModule$$$copyToArray(FSharpMap$$get_Tree(m$$46), res$$6, 0);\n  return res$$6;\n}\nexport function empty(comparer$$21) {\n  return FSharpMap$$$$002Ector$$58ADD115(comparer$$21, new MapTree$00602(0, \"MapEmpty\"));\n}\nexport function createMutable(source$$3, comparer$$22) {\n  const map$$1 = MutableMap$002400602$0024$0024$0024$0024002Ector$0024$00246623D9B3(source$$3, comparer$$22);\n  return map$$1;\n}\nexport function groupBy(projection, xs, comparer$$23) {\n  const dict = createMutable(empty$$1(), comparer$$23);\n  iterate$$1(function (v$$30) {\n    const key = projection(v$$30);\n\n    if (dict.has(key)) {\n      void dict.get(key).push(v$$30);\n    } else {\n      const value = dict.set(key, [v$$30]);\n      void value;\n    }\n  }, xs);\n  return map$$2(function mapping$$2(kv$$3) {\n    return [kv$$3[0], kv$$3[1]];\n  }, dict);\n}\nexport function countBy(projection$$1, xs$$1, comparer$$24) {\n  const dict$$1 = createMutable(empty$$1(), comparer$$24);\n  iterate$$1(function (value$$1) {\n    const key$$1 = projection$$1(value$$1);\n    const value$$2 = dict$$1.has(key$$1) ? dict$$1.set(key$$1, dict$$1.get(key$$1) + 1) : dict$$1.set(key$$1, 1);\n    void value$$2;\n  }, xs$$1);\n  return map$$2(function mapping$$3(kv$$4) {\n    return [kv$$4[0], kv$$4[1]];\n  }, dict$$1);\n}\nexport function count(m$$47) {\n  return FSharpMap$$get_Count(m$$47);\n}","import { declare, FSharpRef } from \"./Types.js\";\nimport { iterateIndexed, toIterator, getEnumerator, delay, collect, map, sumBy, iterate } from \"./Seq.js\";\nimport { class_type } from \"./Reflection.js\";\nimport { getItemFromDict, tryGetValue } from \"./Util.js\";\nimport { some } from \"./Option.js\";\nexport const MutableSet$00601 = declare(function Fable_Collections_MutableSet(items, comparer) {\n  const $this$$1 = this;\n  const this$ = new FSharpRef(null);\n  $this$$1.comparer = comparer;\n  this$.contents = $this$$1;\n  $this$$1.hashMap = new Map([]);\n  $this$$1[\"init@21-2\"] = 1;\n  iterate(function (item) {\n    const value = MutableSet$00601$$Add$$2B595(this$.contents, item);\n    void value;\n  }, items);\n  void null;\n});\nexport function MutableSet$00601$reflection($gen$$4) {\n  return class_type(\"Fable.Collections.MutableSet`1\", [$gen$$4], MutableSet$00601);\n}\nexport function MutableSet$00601$$$$002Ector$$Z6150332D(items, comparer) {\n  return this instanceof MutableSet$00601 ? MutableSet$00601.call(this, items, comparer) : new MutableSet$00601(items, comparer);\n}\n\nfunction MutableSet$00601$$TryFindIndex$$2B595(this$$$1, k) {\n  const h = this$$$1.comparer.GetHashCode(k) | 0;\n  const matchValue = tryGetValue(this$$$1.hashMap, h, null);\n\n  if (matchValue[0]) {\n    return [true, h, matchValue[1].findIndex(function (v) {\n      return this$$$1.comparer.Equals(k, v);\n    })];\n  } else {\n    return [false, h, -1];\n  }\n}\n\nfunction MutableSet$00601$$TryFind$$2B595(this$$$2, k$$1) {\n  const matchValue$$1 = MutableSet$00601$$TryFindIndex$$2B595(this$$$2, k$$1);\n  var $target$$9;\n\n  if (matchValue$$1[0]) {\n    if (matchValue$$1[2] > -1) {\n      $target$$9 = 0;\n    } else {\n      $target$$9 = 1;\n    }\n  } else {\n    $target$$9 = 1;\n  }\n\n  switch ($target$$9) {\n    case 0:\n      {\n        return some(getItemFromDict(this$$$2.hashMap, matchValue$$1[1])[matchValue$$1[2]]);\n      }\n\n    case 1:\n      {\n        return undefined;\n      }\n  }\n}\n\nexport function MutableSet$00601$$get_Comparer(this$$$3) {\n  return this$$$3.comparer;\n}\nexport function MutableSet$00601$$Clear(this$$$4) {\n  this$$$4.hashMap.clear();\n}\nexport function MutableSet$00601$$get_Count(this$$$5) {\n  const source = this$$$5.hashMap.values();\n  return sumBy(function projection(pairs) {\n    return pairs.length;\n  }, source, {\n    GetZero() {\n      return 0;\n    },\n\n    Add($x$$2, $y$$3) {\n      return $x$$2 + $y$$3;\n    }\n\n  }) | 0;\n}\nexport function MutableSet$00601$$Add$$2B595(this$$$6, k$$2) {\n  const matchValue$$2 = MutableSet$00601$$TryFindIndex$$2B595(this$$$6, k$$2);\n  var $target$$16;\n\n  if (matchValue$$2[0]) {\n    if (matchValue$$2[2] > -1) {\n      $target$$16 = 0;\n    } else {\n      $target$$16 = 1;\n    }\n  } else {\n    $target$$16 = 1;\n  }\n\n  switch ($target$$16) {\n    case 0:\n      {\n        return false;\n      }\n\n    case 1:\n      {\n        if (matchValue$$2[0]) {\n          const value$$1 = void getItemFromDict(this$$$6.hashMap, matchValue$$2[1]).push(k$$2);\n          void null;\n          return true;\n        } else {\n          this$$$6.hashMap.set(matchValue$$2[1], [k$$2]);\n          return true;\n        }\n      }\n  }\n}\nexport function MutableSet$00601$$Contains$$2B595(this$$$7, k$$3) {\n  const matchValue$$3 = MutableSet$00601$$TryFindIndex$$2B595(this$$$7, k$$3);\n  var $target$$19;\n\n  if (matchValue$$3[0]) {\n    if (matchValue$$3[2] > -1) {\n      $target$$19 = 0;\n    } else {\n      $target$$19 = 1;\n    }\n  } else {\n    $target$$19 = 1;\n  }\n\n  switch ($target$$19) {\n    case 0:\n      {\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n}\nexport function MutableSet$00601$$Remove$$2B595(this$$$8, k$$4) {\n  const matchValue$$4 = MutableSet$00601$$TryFindIndex$$2B595(this$$$8, k$$4);\n  var $target$$22;\n\n  if (matchValue$$4[0]) {\n    if (matchValue$$4[2] > -1) {\n      $target$$22 = 0;\n    } else {\n      $target$$22 = 1;\n    }\n  } else {\n    $target$$22 = 1;\n  }\n\n  switch ($target$$22) {\n    case 0:\n      {\n        getItemFromDict(this$$$8.hashMap, matchValue$$4[1]).splice(matchValue$$4[2], 1);\n        return true;\n      }\n\n    case 1:\n      {\n        return false;\n      }\n  }\n}\n\nMutableSet$00601.prototype[Symbol.iterator] = function () {\n  var elems;\n  const this$$$9 = this;\n  return toIterator((elems = delay(function () {\n    return collect(function (values$$1) {\n      return map(function (value$$2) {\n        return value$$2;\n      }, values$$1);\n    }, this$$$9.hashMap.values());\n  }), getEnumerator(elems)));\n};\n\nMutableSet$00601.prototype.Add = function (item$$1) {\n  const this$$$10 = this;\n  const value$$3 = MutableSet$00601$$Add$$2B595(this$$$10, item$$1);\n  void value$$3;\n};\n\nMutableSet$00601.prototype.Clear = function () {\n  const this$$$11 = this;\n  MutableSet$00601$$Clear(this$$$11);\n};\n\nMutableSet$00601.prototype.Contains = function (item$$2) {\n  const this$$$12 = this;\n  return MutableSet$00601$$Contains$$2B595(this$$$12, item$$2);\n};\n\nMutableSet$00601.prototype.CopyTo = function (array, arrayIndex) {\n  const this$$$13 = this;\n  iterateIndexed(function action(i$$8, e) {\n    array[arrayIndex + i$$8] = e;\n  }, this$$$13);\n};\n\nObject.defineProperty(MutableSet$00601.prototype, \"Count\", {\n  \"get\": function () {\n    const this$$$14 = this;\n    return MutableSet$00601$$get_Count(this$$$14) | 0;\n  }\n});\nObject.defineProperty(MutableSet$00601.prototype, \"IsReadOnly\", {\n  \"get\": function () {\n    return false;\n  }\n});\n\nMutableSet$00601.prototype.Remove = function (item$$3) {\n  const this$$$16 = this;\n  return MutableSet$00601$$Remove$$2B595(this$$$16, item$$3);\n};\n\nObject.defineProperty(MutableSet$00601.prototype, \"size\", {\n  \"get\": function () {\n    const this$$$17 = this;\n    return MutableSet$00601$$get_Count(this$$$17) | 0;\n  }\n});\n\nMutableSet$00601.prototype.add = function (k$$5) {\n  const this$$$18 = this;\n  const value$$4 = MutableSet$00601$$Add$$2B595(this$$$18, k$$5);\n  void value$$4;\n  return this$$$18;\n};\n\nMutableSet$00601.prototype.add_ = function (k$$6) {\n  const this$$$19 = this;\n  return MutableSet$00601$$Add$$2B595(this$$$19, k$$6);\n};\n\nMutableSet$00601.prototype.clear = function () {\n  const this$$$20 = this;\n  MutableSet$00601$$Clear(this$$$20);\n};\n\nMutableSet$00601.prototype.delete = function (k$$7) {\n  const this$$$21 = this;\n  return MutableSet$00601$$Remove$$2B595(this$$$21, k$$7);\n};\n\nMutableSet$00601.prototype.has = function (k$$8) {\n  const this$$$22 = this;\n  return MutableSet$00601$$Contains$$2B595(this$$$22, k$$8);\n};\n\nMutableSet$00601.prototype.keys = function () {\n  const this$$$23 = this;\n  return map(function mapping(x) {\n    return x;\n  }, this$$$23);\n};\n\nMutableSet$00601.prototype.values = function () {\n  const this$$$24 = this;\n  return map(function mapping$$1(x$$1) {\n    return x$$1;\n  }, this$$$24);\n};\n\nMutableSet$00601.prototype.entries = function () {\n  const this$$$25 = this;\n  return map(function mapping$$2(v$$1) {\n    return [v$$1, v$$1];\n  }, this$$$25);\n};","import { List, Record, declare, Union } from \"./Types.js\";\nimport { class_type, record_type, bool_type, list_type, union_type, int32_type } from \"./Reflection.js\";\nimport { value as value$$2, some, Choice } from \"./Option.js\";\nimport { iterate as iterate$$1, delay, collect, singleton as singleton$$1, empty as empty$$1, fold as fold$$1, toIterator, map as map$$1, reduce, getEnumerator, unfold } from \"./Seq.js\";\nimport { structuralHash, isDisposable } from \"./Util.js\";\nimport { join } from \"./String.js\";\nimport { MutableSet$00601$$Add$$2B595 as MutableSet$002400601$0024$0024Add$0024$00242B595, MutableSet$00601$$$$002Ector$$Z6150332D as MutableSet$002400601$0024$0024$0024$0024002Ector$0024$0024Z6150332D } from \"./MutableSet\";\nexport const SetTree$00601 = declare(function Set_SetTree(tag, name, ...fields) {\n  this.tag = tag | 0;\n  this.name = name;\n  this.fields = fields;\n}, Union);\nexport function SetTree$00601$reflection($gen$$3) {\n  return union_type(\"Set.SetTree`1\", [$gen$$3], SetTree$00601, () => [\"SetEmpty\", [\"SetNode\", [[\"Item1\", $gen$$3], [\"Item2\", SetTree$00601$reflection($gen$$3)], [\"Item3\", SetTree$00601$reflection($gen$$3)], [\"Item4\", int32_type]]], [\"SetOne\", [[\"Item\", $gen$$3]]]]);\n}\nexport function SetTreeModule$$$countAux($s$$4, $acc$$5) {\n  SetTreeModule$$$countAux: while (true) {\n    const s = $s$$4,\n          acc = $acc$$5;\n\n    switch (s.tag) {\n      case 2:\n        {\n          return acc + 1 | 0;\n        }\n\n      case 0:\n        {\n          return acc | 0;\n        }\n\n      default:\n        {\n          $s$$4 = s.fields[1];\n          $acc$$5 = SetTreeModule$$$countAux(s.fields[2], acc + 1);\n          continue SetTreeModule$$$countAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$count(s$$1) {\n  return SetTreeModule$$$countAux(s$$1, 0);\n}\nexport function SetTreeModule$$$SetOne(n) {\n  return new SetTree$00601(2, \"SetOne\", n);\n}\nexport function SetTreeModule$$$SetNode(x, l$$1, r$$1, h) {\n  return new SetTree$00601(1, \"SetNode\", x, l$$1, r$$1, h);\n}\nexport function SetTreeModule$$$height(t) {\n  switch (t.tag) {\n    case 2:\n      {\n        return 1;\n      }\n\n    case 1:\n      {\n        return t.fields[3] | 0;\n      }\n\n    default:\n      {\n        return 0;\n      }\n  }\n}\nexport const SetTreeModule$$$tolerance = 2;\nexport function SetTreeModule$$$mk(l$$2, k, r$$2) {\n  var $target$$16;\n\n  if (l$$2.tag === 0) {\n    if (r$$2.tag === 0) {\n      $target$$16 = 0;\n    } else {\n      $target$$16 = 1;\n    }\n  } else {\n    $target$$16 = 1;\n  }\n\n  switch ($target$$16) {\n    case 0:\n      {\n        return SetTreeModule$$$SetOne(k);\n      }\n\n    case 1:\n      {\n        const hl = SetTreeModule$$$height(l$$2) | 0;\n        const hr = SetTreeModule$$$height(r$$2) | 0;\n        const m = (hl < hr ? hr : hl) | 0;\n        return SetTreeModule$$$SetNode(k, l$$2, r$$2, m + 1);\n      }\n  }\n}\nexport function SetTreeModule$$$rebalance(t1, k$$1, t2) {\n  const t1h = SetTreeModule$$$height(t1) | 0;\n  const t2h = SetTreeModule$$$height(t2) | 0;\n\n  if (t2h > t1h + SetTreeModule$$$tolerance) {\n    if (t2.tag === 1) {\n      if (SetTreeModule$$$height(t2.fields[1]) > t1h + 1) {\n        if (t2.fields[1].tag === 1) {\n          return SetTreeModule$$$mk(SetTreeModule$$$mk(t1, k$$1, t2.fields[1].fields[1]), t2.fields[1].fields[0], SetTreeModule$$$mk(t2.fields[1].fields[2], t2.fields[0], t2.fields[2]));\n        } else {\n          throw new Error(\"rebalance\");\n        }\n      } else {\n        return SetTreeModule$$$mk(SetTreeModule$$$mk(t1, k$$1, t2.fields[1]), t2.fields[0], t2.fields[2]);\n      }\n    } else {\n      throw new Error(\"rebalance\");\n    }\n  } else if (t1h > t2h + SetTreeModule$$$tolerance) {\n    if (t1.tag === 1) {\n      if (SetTreeModule$$$height(t1.fields[2]) > t2h + 1) {\n        if (t1.fields[2].tag === 1) {\n          return SetTreeModule$$$mk(SetTreeModule$$$mk(t1.fields[1], t1.fields[0], t1.fields[2].fields[1]), t1.fields[2].fields[0], SetTreeModule$$$mk(t1.fields[2].fields[2], k$$1, t2));\n        } else {\n          throw new Error(\"rebalance\");\n        }\n      } else {\n        return SetTreeModule$$$mk(t1.fields[1], t1.fields[0], SetTreeModule$$$mk(t1.fields[2], k$$1, t2));\n      }\n    } else {\n      throw new Error(\"rebalance\");\n    }\n  } else {\n    return SetTreeModule$$$mk(t1, k$$1, t2);\n  }\n}\nexport function SetTreeModule$$$add(comparer, k$$2, t$$1) {\n  switch (t$$1.tag) {\n    case 2:\n      {\n        const c$$1 = comparer.Compare(k$$2, t$$1.fields[0]) | 0;\n\n        if (c$$1 < 0) {\n          return SetTreeModule$$$SetNode(k$$2, new SetTree$00601(0, \"SetEmpty\"), t$$1, 2);\n        } else if (c$$1 === 0) {\n          return t$$1;\n        } else {\n          return SetTreeModule$$$SetNode(k$$2, t$$1, new SetTree$00601(0, \"SetEmpty\"), 2);\n        }\n      }\n\n    case 0:\n      {\n        return SetTreeModule$$$SetOne(k$$2);\n      }\n\n    default:\n      {\n        const c = comparer.Compare(k$$2, t$$1.fields[0]) | 0;\n\n        if (c < 0) {\n          return SetTreeModule$$$rebalance(SetTreeModule$$$add(comparer, k$$2, t$$1.fields[1]), t$$1.fields[0], t$$1.fields[2]);\n        } else if (c === 0) {\n          return t$$1;\n        } else {\n          return SetTreeModule$$$rebalance(t$$1.fields[1], t$$1.fields[0], SetTreeModule$$$add(comparer, k$$2, t$$1.fields[2]));\n        }\n      }\n  }\n}\nexport function SetTreeModule$$$balance(comparer$$1, t1$$1, k$$3, t2$$1) {\n  var $target$$27, t2$$2, t1$$2, k1, t2$$3, k2$$2, t1$$3, h1, h2, k1$$1, k2$$3, t11, t12, t21, t22;\n\n  if (t1$$1.tag === 2) {\n    if (t2$$1.tag === 0) {\n      $target$$27 = 1;\n      t1$$2 = t1$$1;\n    } else if (t2$$1.tag === 2) {\n      $target$$27 = 2;\n      k1 = t1$$1.fields[0];\n      t2$$3 = t2$$1;\n    } else {\n      $target$$27 = 2;\n      k1 = t1$$1.fields[0];\n      t2$$3 = t2$$1;\n    }\n  } else if (t1$$1.tag === 1) {\n    if (t2$$1.tag === 2) {\n      $target$$27 = 3;\n      k2$$2 = t2$$1.fields[0];\n      t1$$3 = t1$$1;\n    } else if (t2$$1.tag === 1) {\n      $target$$27 = 4;\n      h1 = t1$$1.fields[3];\n      h2 = t2$$1.fields[3];\n      k1$$1 = t1$$1.fields[0];\n      k2$$3 = t2$$1.fields[0];\n      t11 = t1$$1.fields[1];\n      t12 = t1$$1.fields[2];\n      t21 = t2$$1.fields[1];\n      t22 = t2$$1.fields[2];\n    } else {\n      $target$$27 = 1;\n      t1$$2 = t1$$1;\n    }\n  } else {\n    $target$$27 = 0;\n    t2$$2 = t2$$1;\n  }\n\n  switch ($target$$27) {\n    case 0:\n      {\n        return SetTreeModule$$$add(comparer$$1, k$$3, t2$$2);\n      }\n\n    case 1:\n      {\n        return SetTreeModule$$$add(comparer$$1, k$$3, t1$$2);\n      }\n\n    case 2:\n      {\n        return SetTreeModule$$$add(comparer$$1, k$$3, SetTreeModule$$$add(comparer$$1, k1, t2$$3));\n      }\n\n    case 3:\n      {\n        return SetTreeModule$$$add(comparer$$1, k$$3, SetTreeModule$$$add(comparer$$1, k2$$2, t1$$3));\n      }\n\n    case 4:\n      {\n        if (h1 + SetTreeModule$$$tolerance < h2) {\n          return SetTreeModule$$$rebalance(SetTreeModule$$$balance(comparer$$1, t1$$1, k$$3, t21), k2$$3, t22);\n        } else if (h2 + SetTreeModule$$$tolerance < h1) {\n          return SetTreeModule$$$rebalance(t11, k1$$1, SetTreeModule$$$balance(comparer$$1, t12, k$$3, t2$$1));\n        } else {\n          return SetTreeModule$$$mk(t1$$1, k$$3, t2$$1);\n        }\n      }\n  }\n}\nexport function SetTreeModule$$$split(comparer$$2, pivot, t$$2) {\n  switch (t$$2.tag) {\n    case 2:\n      {\n        const c$$3 = comparer$$2.Compare(t$$2.fields[0], pivot) | 0;\n\n        if (c$$3 < 0) {\n          return [t$$2, false, new SetTree$00601(0, \"SetEmpty\")];\n        } else if (c$$3 === 0) {\n          return [new SetTree$00601(0, \"SetEmpty\"), true, new SetTree$00601(0, \"SetEmpty\")];\n        } else {\n          return [new SetTree$00601(0, \"SetEmpty\"), false, t$$2];\n        }\n      }\n\n    case 0:\n      {\n        return [new SetTree$00601(0, \"SetEmpty\"), false, new SetTree$00601(0, \"SetEmpty\")];\n      }\n\n    default:\n      {\n        const c$$2 = comparer$$2.Compare(pivot, t$$2.fields[0]) | 0;\n\n        if (c$$2 < 0) {\n          const patternInput = SetTreeModule$$$split(comparer$$2, pivot, t$$2.fields[1]);\n          return [patternInput[0], patternInput[1], SetTreeModule$$$balance(comparer$$2, patternInput[2], t$$2.fields[0], t$$2.fields[2])];\n        } else if (c$$2 === 0) {\n          return [t$$2.fields[1], true, t$$2.fields[2]];\n        } else {\n          const patternInput$$1 = SetTreeModule$$$split(comparer$$2, pivot, t$$2.fields[2]);\n          return [SetTreeModule$$$balance(comparer$$2, t$$2.fields[1], t$$2.fields[0], patternInput$$1[0]), patternInput$$1[1], patternInput$$1[2]];\n        }\n      }\n  }\n}\nexport function SetTreeModule$$$spliceOutSuccessor(t$$3) {\n  switch (t$$3.tag) {\n    case 2:\n      {\n        return [t$$3.fields[0], new SetTree$00601(0, \"SetEmpty\")];\n      }\n\n    case 1:\n      {\n        if (t$$3.fields[1].tag === 0) {\n          return [t$$3.fields[0], t$$3.fields[2]];\n        } else {\n          const patternInput$$2 = SetTreeModule$$$spliceOutSuccessor(t$$3.fields[1]);\n          return [patternInput$$2[0], SetTreeModule$$$mk(patternInput$$2[1], t$$3.fields[0], t$$3.fields[2])];\n        }\n      }\n\n    default:\n      {\n        throw new Error(\"internal error: Set.spliceOutSuccessor\");\n      }\n  }\n}\nexport function SetTreeModule$$$remove(comparer$$3, k$$4, t$$4) {\n  switch (t$$4.tag) {\n    case 2:\n      {\n        const c$$4 = comparer$$3.Compare(k$$4, t$$4.fields[0]) | 0;\n\n        if (c$$4 === 0) {\n          return new SetTree$00601(0, \"SetEmpty\");\n        } else {\n          return t$$4;\n        }\n      }\n\n    case 1:\n      {\n        const c$$5 = comparer$$3.Compare(k$$4, t$$4.fields[0]) | 0;\n\n        if (c$$5 < 0) {\n          return SetTreeModule$$$rebalance(SetTreeModule$$$remove(comparer$$3, k$$4, t$$4.fields[1]), t$$4.fields[0], t$$4.fields[2]);\n        } else if (c$$5 === 0) {\n          if (t$$4.fields[1].tag === 0) {\n            return t$$4.fields[2];\n          } else if (t$$4.fields[2].tag === 0) {\n            return t$$4.fields[1];\n          } else {\n            const patternInput$$3 = SetTreeModule$$$spliceOutSuccessor(t$$4.fields[2]);\n            return SetTreeModule$$$mk(t$$4.fields[1], patternInput$$3[0], patternInput$$3[1]);\n          }\n        } else {\n          return SetTreeModule$$$rebalance(t$$4.fields[1], t$$4.fields[0], SetTreeModule$$$remove(comparer$$3, k$$4, t$$4.fields[2]));\n        }\n      }\n\n    default:\n      {\n        return t$$4;\n      }\n  }\n}\nexport function SetTreeModule$$$mem($comparer$$4$$35, $k$$5$$36, $t$$5$$37) {\n  SetTreeModule$$$mem: while (true) {\n    const comparer$$4 = $comparer$$4$$35,\n          k$$5 = $k$$5$$36,\n          t$$5 = $t$$5$$37;\n\n    switch (t$$5.tag) {\n      case 2:\n        {\n          return comparer$$4.Compare(k$$5, t$$5.fields[0]) === 0;\n        }\n\n      case 0:\n        {\n          return false;\n        }\n\n      default:\n        {\n          const c$$6 = comparer$$4.Compare(k$$5, t$$5.fields[0]) | 0;\n\n          if (c$$6 < 0) {\n            $comparer$$4$$35 = comparer$$4;\n            $k$$5$$36 = k$$5;\n            $t$$5$$37 = t$$5.fields[1];\n            continue SetTreeModule$$$mem;\n          } else if (c$$6 === 0) {\n            return true;\n          } else {\n            $comparer$$4$$35 = comparer$$4;\n            $k$$5$$36 = k$$5;\n            $t$$5$$37 = t$$5.fields[2];\n            continue SetTreeModule$$$mem;\n          }\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$iter($f$$38, $t$$6$$39) {\n  SetTreeModule$$$iter: while (true) {\n    const f = $f$$38,\n          t$$6 = $t$$6$$39;\n\n    switch (t$$6.tag) {\n      case 2:\n        {\n          f(t$$6.fields[0]);\n          break;\n        }\n\n      case 0:\n        {\n          void null;\n          break;\n        }\n\n      default:\n        {\n          SetTreeModule$$$iter(f, t$$6.fields[1]);\n          f(t$$6.fields[0]);\n          $f$$38 = f;\n          $t$$6$$39 = t$$6.fields[2];\n          continue SetTreeModule$$$iter;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$foldBack($f$$1$$40, $m$$1$$41, $x$$1$$42) {\n  SetTreeModule$$$foldBack: while (true) {\n    const f$$1 = $f$$1$$40,\n          m$$1 = $m$$1$$41,\n          x$$1 = $x$$1$$42;\n\n    switch (m$$1.tag) {\n      case 2:\n        {\n          return f$$1(m$$1.fields[0], x$$1);\n        }\n\n      case 0:\n        {\n          return x$$1;\n        }\n\n      default:\n        {\n          $f$$1$$40 = f$$1;\n          $m$$1$$41 = m$$1.fields[1];\n          $x$$1$$42 = f$$1(m$$1.fields[0], SetTreeModule$$$foldBack(f$$1, m$$1.fields[2], x$$1));\n          continue SetTreeModule$$$foldBack;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$fold($f$$2$$43, $x$$2$$44, $m$$2$$45) {\n  SetTreeModule$$$fold: while (true) {\n    const f$$2 = $f$$2$$43,\n          x$$2 = $x$$2$$44,\n          m$$2 = $m$$2$$45;\n\n    switch (m$$2.tag) {\n      case 2:\n        {\n          return f$$2(x$$2, m$$2.fields[0]);\n        }\n\n      case 0:\n        {\n          return x$$2;\n        }\n\n      default:\n        {\n          const x$$3 = SetTreeModule$$$fold(f$$2, x$$2, m$$2.fields[1]);\n          const x$$4 = f$$2(x$$3, m$$2.fields[0]);\n          $f$$2$$43 = f$$2;\n          $x$$2$$44 = x$$4;\n          $m$$2$$45 = m$$2.fields[2];\n          continue SetTreeModule$$$fold;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$forall($f$$3$$46, $m$$3$$47) {\n  SetTreeModule$$$forall: while (true) {\n    const f$$3 = $f$$3$$46,\n          m$$3 = $m$$3$$47;\n\n    switch (m$$3.tag) {\n      case 2:\n        {\n          return f$$3(m$$3.fields[0]);\n        }\n\n      case 0:\n        {\n          return true;\n        }\n\n      default:\n        {\n          if (f$$3(m$$3.fields[0]) ? SetTreeModule$$$forall(f$$3, m$$3.fields[1]) : false) {\n            $f$$3$$46 = f$$3;\n            $m$$3$$47 = m$$3.fields[2];\n            continue SetTreeModule$$$forall;\n          } else {\n            return false;\n          }\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$exists($f$$4$$48, $m$$4$$49) {\n  SetTreeModule$$$exists: while (true) {\n    const f$$4 = $f$$4$$48,\n          m$$4 = $m$$4$$49;\n\n    switch (m$$4.tag) {\n      case 2:\n        {\n          return f$$4(m$$4.fields[0]);\n        }\n\n      case 0:\n        {\n          return false;\n        }\n\n      default:\n        {\n          if (f$$4(m$$4.fields[0]) ? true : SetTreeModule$$$exists(f$$4, m$$4.fields[1])) {\n            return true;\n          } else {\n            $f$$4$$48 = f$$4;\n            $m$$4$$49 = m$$4.fields[2];\n            continue SetTreeModule$$$exists;\n          }\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$isEmpty(m$$5) {\n  if (m$$5.tag === 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function SetTreeModule$$$subset(comparer$$5, a, b) {\n  return SetTreeModule$$$forall(function (x$$5) {\n    return SetTreeModule$$$mem(comparer$$5, x$$5, b);\n  }, a);\n}\nexport function SetTreeModule$$$psubset(comparer$$6, a$$1, b$$1) {\n  if (SetTreeModule$$$forall(function (x$$6) {\n    return SetTreeModule$$$mem(comparer$$6, x$$6, b$$1);\n  }, a$$1)) {\n    return SetTreeModule$$$exists(function (x$$7) {\n      return !SetTreeModule$$$mem(comparer$$6, x$$7, a$$1);\n    }, b$$1);\n  } else {\n    return false;\n  }\n}\nexport function SetTreeModule$$$filterAux($comparer$$7$$57, $f$$5$$58, $s$$2$$59, $acc$$1$$60) {\n  SetTreeModule$$$filterAux: while (true) {\n    const comparer$$7 = $comparer$$7$$57,\n          f$$5 = $f$$5$$58,\n          s$$2 = $s$$2$$59,\n          acc$$1 = $acc$$1$$60;\n\n    switch (s$$2.tag) {\n      case 2:\n        {\n          if (f$$5(s$$2.fields[0])) {\n            return SetTreeModule$$$add(comparer$$7, s$$2.fields[0], acc$$1);\n          } else {\n            return acc$$1;\n          }\n        }\n\n      case 0:\n        {\n          return acc$$1;\n        }\n\n      default:\n        {\n          const acc$$2 = f$$5(s$$2.fields[0]) ? SetTreeModule$$$add(comparer$$7, s$$2.fields[0], acc$$1) : acc$$1;\n          $comparer$$7$$57 = comparer$$7;\n          $f$$5$$58 = f$$5;\n          $s$$2$$59 = s$$2.fields[1];\n          $acc$$1$$60 = SetTreeModule$$$filterAux(comparer$$7, f$$5, s$$2.fields[2], acc$$2);\n          continue SetTreeModule$$$filterAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$filter(comparer$$8, f$$6, s$$3) {\n  return SetTreeModule$$$filterAux(comparer$$8, f$$6, s$$3, new SetTree$00601(0, \"SetEmpty\"));\n}\nexport function SetTreeModule$$$diffAux($comparer$$9$$64, $m$$6$$65, $acc$$3$$66) {\n  SetTreeModule$$$diffAux: while (true) {\n    const comparer$$9 = $comparer$$9$$64,\n          m$$6 = $m$$6$$65,\n          acc$$3 = $acc$$3$$66;\n\n    switch (m$$6.tag) {\n      case 2:\n        {\n          return SetTreeModule$$$remove(comparer$$9, m$$6.fields[0], acc$$3);\n        }\n\n      case 0:\n        {\n          return acc$$3;\n        }\n\n      default:\n        {\n          $comparer$$9$$64 = comparer$$9;\n          $m$$6$$65 = m$$6.fields[1];\n          $acc$$3$$66 = SetTreeModule$$$diffAux(comparer$$9, m$$6.fields[2], SetTreeModule$$$remove(comparer$$9, m$$6.fields[0], acc$$3));\n          continue SetTreeModule$$$diffAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$diff(comparer$$10, a$$2, b$$2) {\n  return SetTreeModule$$$diffAux(comparer$$10, b$$2, a$$2);\n}\nexport function SetTreeModule$$$union(comparer$$11, t1$$4, t2$$4) {\n  var $target$$73, h1$$1, h2$$1, k1$$4, k2$$16, t11$$2, t12$$2, t21$$1, t22$$1, t$$7, t$$8, k1$$5, t2$$5, k2$$17, t1$$5;\n\n  if (t1$$4.tag === 0) {\n    $target$$73 = 1;\n    t$$7 = t2$$4;\n  } else if (t1$$4.tag === 2) {\n    if (t2$$4.tag === 0) {\n      $target$$73 = 2;\n      t$$8 = t1$$4;\n    } else if (t2$$4.tag === 2) {\n      $target$$73 = 3;\n      k1$$5 = t1$$4.fields[0];\n      t2$$5 = t2$$4;\n    } else {\n      $target$$73 = 3;\n      k1$$5 = t1$$4.fields[0];\n      t2$$5 = t2$$4;\n    }\n  } else if (t2$$4.tag === 0) {\n    $target$$73 = 2;\n    t$$8 = t1$$4;\n  } else if (t2$$4.tag === 2) {\n    $target$$73 = 4;\n    k2$$17 = t2$$4.fields[0];\n    t1$$5 = t1$$4;\n  } else {\n    $target$$73 = 0;\n    h1$$1 = t1$$4.fields[3];\n    h2$$1 = t2$$4.fields[3];\n    k1$$4 = t1$$4.fields[0];\n    k2$$16 = t2$$4.fields[0];\n    t11$$2 = t1$$4.fields[1];\n    t12$$2 = t1$$4.fields[2];\n    t21$$1 = t2$$4.fields[1];\n    t22$$1 = t2$$4.fields[2];\n  }\n\n  switch ($target$$73) {\n    case 0:\n      {\n        if (h1$$1 > h2$$1) {\n          const patternInput$$4 = SetTreeModule$$$split(comparer$$11, k1$$4, t2$$4);\n          return SetTreeModule$$$balance(comparer$$11, SetTreeModule$$$union(comparer$$11, t11$$2, patternInput$$4[0]), k1$$4, SetTreeModule$$$union(comparer$$11, t12$$2, patternInput$$4[2]));\n        } else {\n          const patternInput$$5 = SetTreeModule$$$split(comparer$$11, k2$$16, t1$$4);\n          return SetTreeModule$$$balance(comparer$$11, SetTreeModule$$$union(comparer$$11, t21$$1, patternInput$$5[0]), k2$$16, SetTreeModule$$$union(comparer$$11, t22$$1, patternInput$$5[2]));\n        }\n      }\n\n    case 1:\n      {\n        return t$$7;\n      }\n\n    case 2:\n      {\n        return t$$8;\n      }\n\n    case 3:\n      {\n        return SetTreeModule$$$add(comparer$$11, k1$$5, t2$$5);\n      }\n\n    case 4:\n      {\n        return SetTreeModule$$$add(comparer$$11, k2$$17, t1$$5);\n      }\n  }\n}\nexport function SetTreeModule$$$intersectionAux($comparer$$12$$74, $b$$3$$75, $m$$7$$76, $acc$$4$$77) {\n  SetTreeModule$$$intersectionAux: while (true) {\n    const comparer$$12 = $comparer$$12$$74,\n          b$$3 = $b$$3$$75,\n          m$$7 = $m$$7$$76,\n          acc$$4 = $acc$$4$$77;\n\n    switch (m$$7.tag) {\n      case 2:\n        {\n          if (SetTreeModule$$$mem(comparer$$12, m$$7.fields[0], b$$3)) {\n            return SetTreeModule$$$add(comparer$$12, m$$7.fields[0], acc$$4);\n          } else {\n            return acc$$4;\n          }\n        }\n\n      case 0:\n        {\n          return acc$$4;\n        }\n\n      default:\n        {\n          const acc$$5 = SetTreeModule$$$intersectionAux(comparer$$12, b$$3, m$$7.fields[2], acc$$4);\n          const acc$$6 = SetTreeModule$$$mem(comparer$$12, m$$7.fields[0], b$$3) ? SetTreeModule$$$add(comparer$$12, m$$7.fields[0], acc$$5) : acc$$5;\n          $comparer$$12$$74 = comparer$$12;\n          $b$$3$$75 = b$$3;\n          $m$$7$$76 = m$$7.fields[1];\n          $acc$$4$$77 = acc$$6;\n          continue SetTreeModule$$$intersectionAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$intersection(comparer$$13, a$$3, b$$4) {\n  return SetTreeModule$$$intersectionAux(comparer$$13, b$$4, a$$3, new SetTree$00601(0, \"SetEmpty\"));\n}\nexport function SetTreeModule$$$partition1(comparer$$14, f$$7, k$$16, acc1, acc2) {\n  if (f$$7(k$$16)) {\n    return [SetTreeModule$$$add(comparer$$14, k$$16, acc1), acc2];\n  } else {\n    return [acc1, SetTreeModule$$$add(comparer$$14, k$$16, acc2)];\n  }\n}\nexport function SetTreeModule$$$partitionAux($comparer$$15$$86, $f$$8$$87, $s$$4$$88, $acc_0$$89, $acc_1$$90) {\n  SetTreeModule$$$partitionAux: while (true) {\n    const comparer$$15 = $comparer$$15$$86,\n          f$$8 = $f$$8$$87,\n          s$$4 = $s$$4$$88,\n          acc_0 = $acc_0$$89,\n          acc_1 = $acc_1$$90;\n\n    switch (s$$4.tag) {\n      case 2:\n        {\n          return SetTreeModule$$$partition1(comparer$$15, f$$8, s$$4.fields[0], acc_0, acc_1);\n        }\n\n      case 0:\n        {\n          return [acc_0, acc_1];\n        }\n\n      default:\n        {\n          const acc$$8 = SetTreeModule$$$partitionAux(comparer$$15, f$$8, s$$4.fields[2], acc_0, acc_1);\n          const acc$$9 = SetTreeModule$$$partition1(comparer$$15, f$$8, s$$4.fields[0], acc$$8[0], acc$$8[1]);\n          $comparer$$15$$86 = comparer$$15;\n          $f$$8$$87 = f$$8;\n          $s$$4$$88 = s$$4.fields[1];\n          $acc_0$$89 = acc$$9[0];\n          $acc_1$$90 = acc$$9[1];\n          continue SetTreeModule$$$partitionAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$partition(comparer$$16, f$$9, s$$5) {\n  const seed = [new SetTree$00601(0, \"SetEmpty\"), new SetTree$00601(0, \"SetEmpty\")];\n  return SetTreeModule$$$partitionAux(comparer$$16, f$$9, s$$5, seed[0], seed[1]);\n}\nexport function SetTreeModule$$$$007CMatchSetNode$007CMatchSetEmpty$007C(s$$6) {\n  switch (s$$6.tag) {\n    case 2:\n      {\n        return new Choice(0, \"Choice1Of2\", [s$$6.fields[0], new SetTree$00601(0, \"SetEmpty\"), new SetTree$00601(0, \"SetEmpty\")]);\n      }\n\n    case 0:\n      {\n        return new Choice(1, \"Choice2Of2\", void null);\n      }\n\n    default:\n      {\n        return new Choice(0, \"Choice1Of2\", [s$$6.fields[0], s$$6.fields[1], s$$6.fields[2]]);\n      }\n  }\n}\nexport function SetTreeModule$$$minimumElementAux($s$$7$$95, $n$$1$$96) {\n  SetTreeModule$$$minimumElementAux: while (true) {\n    const s$$7 = $s$$7$$95,\n          n$$1 = $n$$1$$96;\n\n    switch (s$$7.tag) {\n      case 2:\n        {\n          return s$$7.fields[0];\n        }\n\n      case 0:\n        {\n          return n$$1;\n        }\n\n      default:\n        {\n          $s$$7$$95 = s$$7.fields[1];\n          $n$$1$$96 = s$$7.fields[0];\n          continue SetTreeModule$$$minimumElementAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$minimumElementOpt(s$$8) {\n  switch (s$$8.tag) {\n    case 2:\n      {\n        return some(s$$8.fields[0]);\n      }\n\n    case 0:\n      {\n        return undefined;\n      }\n\n    default:\n      {\n        return some(SetTreeModule$$$minimumElementAux(s$$8.fields[1], s$$8.fields[0]));\n      }\n  }\n}\nexport function SetTreeModule$$$maximumElementAux($s$$9$$98, $n$$2$$99) {\n  SetTreeModule$$$maximumElementAux: while (true) {\n    const s$$9 = $s$$9$$98,\n          n$$2 = $n$$2$$99;\n\n    switch (s$$9.tag) {\n      case 2:\n        {\n          return s$$9.fields[0];\n        }\n\n      case 0:\n        {\n          return n$$2;\n        }\n\n      default:\n        {\n          $s$$9$$98 = s$$9.fields[2];\n          $n$$2$$99 = s$$9.fields[0];\n          continue SetTreeModule$$$maximumElementAux;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$maximumElementOpt(s$$10) {\n  switch (s$$10.tag) {\n    case 2:\n      {\n        return some(s$$10.fields[0]);\n      }\n\n    case 0:\n      {\n        return undefined;\n      }\n\n    default:\n      {\n        return some(SetTreeModule$$$maximumElementAux(s$$10.fields[2], s$$10.fields[0]));\n      }\n  }\n}\nexport function SetTreeModule$$$minimumElement(s$$11) {\n  const matchValue$$4 = SetTreeModule$$$minimumElementOpt(s$$11);\n\n  if (matchValue$$4 == null) {\n    throw new Error(\"Set contains no elements\");\n  } else {\n    const k$$27 = value$$2(matchValue$$4);\n    return k$$27;\n  }\n}\nexport function SetTreeModule$$$maximumElement(s$$12) {\n  const matchValue$$5 = SetTreeModule$$$maximumElementOpt(s$$12);\n\n  if (matchValue$$5 == null) {\n    throw new Error(\"Set contains no elements\");\n  } else {\n    const k$$28 = value$$2(matchValue$$5);\n    return k$$28;\n  }\n}\nexport const SetTreeModule$002ESetIterator$00601 = declare(function Set_SetTreeModule_SetIterator(stack, started) {\n  this.stack = stack;\n  this.started = started;\n}, Record);\nexport function SetTreeModule$002ESetIterator$00601$reflection($gen$$103) {\n  return record_type(\"Set.SetTreeModule.SetIterator`1\", [$gen$$103], SetTreeModule$002ESetIterator$00601, () => [[\"stack\", list_type(SetTree$00601$reflection($gen$$103))], [\"started\", bool_type]]);\n}\nexport function SetTreeModule$$$collapseLHS($stack$$104) {\n  SetTreeModule$$$collapseLHS: while (true) {\n    const stack = $stack$$104;\n\n    if (stack.tail != null) {\n      if (stack.head.tag === 2) {\n        return stack;\n      } else if (stack.head.tag === 1) {\n        $stack$$104 = new List(stack.head.fields[1], new List(SetTreeModule$$$SetOne(stack.head.fields[0]), new List(stack.head.fields[2], stack.tail)));\n        continue SetTreeModule$$$collapseLHS;\n      } else {\n        $stack$$104 = stack.tail;\n        continue SetTreeModule$$$collapseLHS;\n      }\n    } else {\n      return new List();\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$mkIterator(s$$13) {\n  return new SetTreeModule$002ESetIterator$00601(SetTreeModule$$$collapseLHS(new List(s$$13, new List())), false);\n}\nexport function SetTreeModule$$$notStarted() {\n  throw new Error(\"Enumeration not started\");\n}\nexport function SetTreeModule$$$alreadyFinished() {\n  throw new Error(\"Enumeration already started\");\n}\nexport function SetTreeModule$$$current(i) {\n  if (i.started) {\n    const matchValue$$6 = i.stack;\n\n    if (matchValue$$6.tail == null) {\n      return SetTreeModule$$$alreadyFinished();\n    } else if (matchValue$$6.head.tag === 2) {\n      return matchValue$$6.head.fields[0];\n    } else {\n      throw new Error(\"Please report error: Set iterator, unexpected stack for current\");\n    }\n  } else {\n    return SetTreeModule$$$notStarted();\n  }\n}\nexport function SetTreeModule$$$moveNext(i$$1) {\n  if (i$$1.started) {\n    const matchValue$$7 = i$$1.stack;\n\n    if (matchValue$$7.tail == null) {\n      return false;\n    } else if (matchValue$$7.head.tag === 2) {\n      i$$1.stack = SetTreeModule$$$collapseLHS(matchValue$$7.tail);\n      return !(i$$1.stack.tail == null);\n    } else {\n      throw new Error(\"Please report error: Set iterator, unexpected stack for moveNext\");\n    }\n  } else {\n    i$$1.started = true;\n    return !(i$$1.stack.tail == null);\n  }\n}\nexport const SetTreeModule$002EmkIEnumerator$00601 = declare(function Set_SetTreeModule_mkIEnumerator(s$$14) {\n  const $this$$1 = this;\n  $this$$1.s = s$$14;\n  $this$$1.i = SetTreeModule$$$mkIterator($this$$1.s);\n  void null;\n});\nexport function SetTreeModule$002EmkIEnumerator$00601$reflection($gen$$108) {\n  return class_type(\"Set.SetTreeModule.mkIEnumerator`1\", [$gen$$108], SetTreeModule$002EmkIEnumerator$00601);\n}\nexport function SetTreeModule$002EmkIEnumerator$00601$$$$002Ector$$Z5B395D56(s$$14) {\n  return this instanceof SetTreeModule$002EmkIEnumerator$00601 ? SetTreeModule$002EmkIEnumerator$00601.call(this, s$$14) : new SetTreeModule$002EmkIEnumerator$00601(s$$14);\n}\nObject.defineProperty(SetTreeModule$002EmkIEnumerator$00601.prototype, \"Current\", {\n  \"get\": function () {\n    const __ = this;\n    return SetTreeModule$$$current(__.i);\n  }\n});\n\nSetTreeModule$002EmkIEnumerator$00601.prototype.MoveNext = function () {\n  const __$$1 = this;\n  return SetTreeModule$$$moveNext(__$$1.i);\n};\n\nSetTreeModule$002EmkIEnumerator$00601.prototype.Reset = function () {\n  const __$$2 = this;\n  __$$2.i = SetTreeModule$$$mkIterator(__$$2.s);\n};\n\nSetTreeModule$002EmkIEnumerator$00601.prototype.Dispose = function () {\n  void null;\n};\n\nexport function SetTreeModule$$$mkIEnumerator(s$$15) {\n  return SetTreeModule$002EmkIEnumerator$00601$$$$002Ector$$Z5B395D56(s$$15);\n}\nexport function SetTreeModule$$$toSeq(s$$16) {\n  const en = SetTreeModule$$$mkIEnumerator(s$$16);\n  return unfold(function generator(en$$1) {\n    if (en$$1.MoveNext()) {\n      return [en$$1.Current, en$$1];\n    } else {\n      return undefined;\n    }\n  }, en);\n}\nexport function SetTreeModule$$$compareStacks($comparer$$17$$112, $l1$$113, $l2$$114) {\n  SetTreeModule$$$compareStacks: while (true) {\n    const comparer$$17 = $comparer$$17$$112,\n          l1 = $l1$$113,\n          l2 = $l2$$114;\n    var $target$$115, t1$$6, t2$$6, n1k, n2k, t1$$7, t2$$7, n1k$$1, n2k$$1, n2r, t1$$8, t2$$8, emp, n1k$$2, n1r, n2k$$2, t1$$9, t2$$9, n1k$$3, n1r$$1, n2k$$3, n2r$$1, t1$$10, t2$$10, n1k$$4, t1$$11, n1k$$5, n1l, n1r$$2, t1$$12, n2k$$4, t2$$11, n2k$$5, n2l, n2r$$2, t2$$12;\n\n    if (l1.tail != null) {\n      if (l2.tail != null) {\n        if (l2.head.tag === 2) {\n          if (l1.head.tag === 2) {\n            $target$$115 = 4;\n            n1k = l1.head.fields[0];\n            n2k = l2.head.fields[0];\n            t1$$7 = l1.tail;\n            t2$$7 = l2.tail;\n          } else if (l1.head.tag === 1) {\n            if (l1.head.fields[1].tag === 0) {\n              $target$$115 = 6;\n              emp = l1.head.fields[1];\n              n1k$$2 = l1.head.fields[0];\n              n1r = l1.head.fields[2];\n              n2k$$2 = l2.head.fields[0];\n              t1$$9 = l1.tail;\n              t2$$9 = l2.tail;\n            } else {\n              $target$$115 = 9;\n              n1k$$5 = l1.head.fields[0];\n              n1l = l1.head.fields[1];\n              n1r$$2 = l1.head.fields[2];\n              t1$$12 = l1.tail;\n            }\n          } else {\n            $target$$115 = 10;\n            n2k$$4 = l2.head.fields[0];\n            t2$$11 = l2.tail;\n          }\n        } else if (l2.head.tag === 1) {\n          if (l2.head.fields[1].tag === 0) {\n            if (l1.head.tag === 2) {\n              $target$$115 = 5;\n              n1k$$1 = l1.head.fields[0];\n              n2k$$1 = l2.head.fields[0];\n              n2r = l2.head.fields[2];\n              t1$$8 = l1.tail;\n              t2$$8 = l2.tail;\n            } else if (l1.head.tag === 1) {\n              if (l1.head.fields[1].tag === 0) {\n                $target$$115 = 7;\n                n1k$$3 = l1.head.fields[0];\n                n1r$$1 = l1.head.fields[2];\n                n2k$$3 = l2.head.fields[0];\n                n2r$$1 = l2.head.fields[2];\n                t1$$10 = l1.tail;\n                t2$$10 = l2.tail;\n              } else {\n                $target$$115 = 9;\n                n1k$$5 = l1.head.fields[0];\n                n1l = l1.head.fields[1];\n                n1r$$2 = l1.head.fields[2];\n                t1$$12 = l1.tail;\n              }\n            } else {\n              $target$$115 = 11;\n              n2k$$5 = l2.head.fields[0];\n              n2l = l2.head.fields[1];\n              n2r$$2 = l2.head.fields[2];\n              t2$$12 = l2.tail;\n            }\n          } else if (l1.head.tag === 2) {\n            $target$$115 = 8;\n            n1k$$4 = l1.head.fields[0];\n            t1$$11 = l1.tail;\n          } else if (l1.head.tag === 1) {\n            $target$$115 = 9;\n            n1k$$5 = l1.head.fields[0];\n            n1l = l1.head.fields[1];\n            n1r$$2 = l1.head.fields[2];\n            t1$$12 = l1.tail;\n          } else {\n            $target$$115 = 11;\n            n2k$$5 = l2.head.fields[0];\n            n2l = l2.head.fields[1];\n            n2r$$2 = l2.head.fields[2];\n            t2$$12 = l2.tail;\n          }\n        } else if (l1.head.tag === 2) {\n          $target$$115 = 8;\n          n1k$$4 = l1.head.fields[0];\n          t1$$11 = l1.tail;\n        } else if (l1.head.tag === 1) {\n          $target$$115 = 9;\n          n1k$$5 = l1.head.fields[0];\n          n1l = l1.head.fields[1];\n          n1r$$2 = l1.head.fields[2];\n          t1$$12 = l1.tail;\n        } else {\n          $target$$115 = 3;\n          t1$$6 = l1.tail;\n          t2$$6 = l2.tail;\n        }\n      } else {\n        $target$$115 = 2;\n      }\n    } else if (l2.tail != null) {\n      $target$$115 = 1;\n    } else {\n      $target$$115 = 0;\n    }\n\n    switch ($target$$115) {\n      case 0:\n        {\n          return 0;\n        }\n\n      case 1:\n        {\n          return -1 | 0;\n        }\n\n      case 2:\n        {\n          return 1;\n        }\n\n      case 3:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = t1$$6;\n          $l2$$114 = t2$$6;\n          continue SetTreeModule$$$compareStacks;\n        }\n\n      case 4:\n        {\n          const c$$7 = comparer$$17.Compare(n1k, n2k) | 0;\n\n          if (c$$7 !== 0) {\n            return c$$7 | 0;\n          } else {\n            $comparer$$17$$112 = comparer$$17;\n            $l1$$113 = t1$$7;\n            $l2$$114 = t2$$7;\n            continue SetTreeModule$$$compareStacks;\n          }\n        }\n\n      case 5:\n        {\n          const c$$8 = comparer$$17.Compare(n1k$$1, n2k$$1) | 0;\n\n          if (c$$8 !== 0) {\n            return c$$8 | 0;\n          } else {\n            $comparer$$17$$112 = comparer$$17;\n            $l1$$113 = new List(new SetTree$00601(0, \"SetEmpty\"), t1$$8);\n            $l2$$114 = new List(n2r, t2$$8);\n            continue SetTreeModule$$$compareStacks;\n          }\n        }\n\n      case 6:\n        {\n          const c$$9 = comparer$$17.Compare(n1k$$2, n2k$$2) | 0;\n\n          if (c$$9 !== 0) {\n            return c$$9 | 0;\n          } else {\n            $comparer$$17$$112 = comparer$$17;\n            $l1$$113 = new List(n1r, t1$$9);\n            $l2$$114 = new List(emp, t2$$9);\n            continue SetTreeModule$$$compareStacks;\n          }\n        }\n\n      case 7:\n        {\n          const c$$10 = comparer$$17.Compare(n1k$$3, n2k$$3) | 0;\n\n          if (c$$10 !== 0) {\n            return c$$10 | 0;\n          } else {\n            $comparer$$17$$112 = comparer$$17;\n            $l1$$113 = new List(n1r$$1, t1$$10);\n            $l2$$114 = new List(n2r$$1, t2$$10);\n            continue SetTreeModule$$$compareStacks;\n          }\n        }\n\n      case 8:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = new List(new SetTree$00601(0, \"SetEmpty\"), new List(SetTreeModule$$$SetOne(n1k$$4), t1$$11));\n          $l2$$114 = l2;\n          continue SetTreeModule$$$compareStacks;\n        }\n\n      case 9:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = new List(n1l, new List(SetTreeModule$$$SetNode(n1k$$5, new SetTree$00601(0, \"SetEmpty\"), n1r$$2, 0), t1$$12));\n          $l2$$114 = l2;\n          continue SetTreeModule$$$compareStacks;\n        }\n\n      case 10:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = l1;\n          $l2$$114 = new List(new SetTree$00601(0, \"SetEmpty\"), new List(SetTreeModule$$$SetOne(n2k$$4), t2$$11));\n          continue SetTreeModule$$$compareStacks;\n        }\n\n      case 11:\n        {\n          $comparer$$17$$112 = comparer$$17;\n          $l1$$113 = l1;\n          $l2$$114 = new List(n2l, new List(SetTreeModule$$$SetNode(n2k$$5, new SetTree$00601(0, \"SetEmpty\"), n2r$$2, 0), t2$$12));\n          continue SetTreeModule$$$compareStacks;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$compare(comparer$$18, s1, s2) {\n  if (s1.tag === 0) {\n    if (s2.tag === 0) {\n      return 0;\n    } else {\n      return -1 | 0;\n    }\n  } else if (s2.tag === 0) {\n    return 1;\n  } else {\n    return SetTreeModule$$$compareStacks(comparer$$18, new List(s1, new List()), new List(s2, new List())) | 0;\n  }\n}\nexport function SetTreeModule$$$choose(s$$17) {\n  return SetTreeModule$$$minimumElement(s$$17);\n}\nexport function SetTreeModule$$$loop($m$$8$$120, $acc$$10$$121) {\n  SetTreeModule$$$loop: while (true) {\n    const m$$8 = $m$$8$$120,\n          acc$$10 = $acc$$10$$121;\n\n    switch (m$$8.tag) {\n      case 2:\n        {\n          return new List(m$$8.fields[0], acc$$10);\n        }\n\n      case 0:\n        {\n          return acc$$10;\n        }\n\n      default:\n        {\n          $m$$8$$120 = m$$8.fields[1];\n          $acc$$10$$121 = new List(m$$8.fields[0], SetTreeModule$$$loop(m$$8.fields[2], acc$$10));\n          continue SetTreeModule$$$loop;\n        }\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$toList(s$$18) {\n  return SetTreeModule$$$loop(s$$18, new List());\n}\nexport function SetTreeModule$$$copyToArray(s$$19, arr, i$$2) {\n  let j = i$$2 | 0;\n  SetTreeModule$$$iter(function (x$$8) {\n    arr[j] = x$$8;\n    j = j + 1;\n  }, s$$19);\n}\nexport function SetTreeModule$$$mkFromEnumerator($comparer$$19$$126, $acc$$11$$127, $e$$128) {\n  SetTreeModule$$$mkFromEnumerator: while (true) {\n    const comparer$$19 = $comparer$$19$$126,\n          acc$$11 = $acc$$11$$127,\n          e = $e$$128;\n\n    if (e.MoveNext()) {\n      $comparer$$19$$126 = comparer$$19;\n      $acc$$11$$127 = SetTreeModule$$$add(comparer$$19, e.Current, acc$$11);\n      $e$$128 = e;\n      continue SetTreeModule$$$mkFromEnumerator;\n    } else {\n      return acc$$11;\n    }\n\n    break;\n  }\n}\nexport function SetTreeModule$$$ofSeq(comparer$$20, c$$11) {\n  const ie = getEnumerator(c$$11);\n\n  try {\n    return SetTreeModule$$$mkFromEnumerator(comparer$$20, new SetTree$00601(0, \"SetEmpty\"), ie);\n  } finally {\n    if (isDisposable(ie)) {\n      ie.Dispose();\n    } else {\n      void null;\n    }\n  }\n}\nexport function SetTreeModule$$$ofArray(comparer$$21, arr$$1) {\n  let acc$$12 = new SetTree$00601(0, \"SetEmpty\");\n\n  for (let i$$3 = 0; i$$3 <= arr$$1.length - 1; i$$3++) {\n    acc$$12 = SetTreeModule$$$add(comparer$$21, arr$$1[i$$3], acc$$12);\n  }\n\n  return acc$$12;\n}\nexport const FSharpSet = declare(function Set_Set(comparer$$22, tree) {\n  const $this$$2 = this;\n  $this$$2.comparer = comparer$$22;\n  $this$$2.tree = tree;\n  void null;\n});\nexport function FSharpSet$reflection($gen$$133) {\n  return class_type(\"Set.FSharpSet\", [$gen$$133], FSharpSet);\n}\nexport function FSharpSet$$$$002Ector$$2528C5CB(comparer$$22, tree) {\n  return this instanceof FSharpSet ? FSharpSet.call(this, comparer$$22, tree) : new FSharpSet(comparer$$22, tree);\n}\nexport function FSharpSet$$get_Comparer(__$$4) {\n  return __$$4.comparer;\n}\nexport function FSharpSet$$get_Tree(__$$5) {\n  return __$$5.tree;\n}\nexport function FSharpSet$$Add$$2B595(s$$20, x$$9) {\n  return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$20), SetTreeModule$$$add(FSharpSet$$get_Comparer(s$$20), x$$9, FSharpSet$$get_Tree(s$$20)));\n}\nexport function FSharpSet$$Remove$$2B595(s$$21, x$$10) {\n  return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$21), SetTreeModule$$$remove(FSharpSet$$get_Comparer(s$$21), x$$10, FSharpSet$$get_Tree(s$$21)));\n}\nexport function FSharpSet$$get_Count(s$$22) {\n  return SetTreeModule$$$count(FSharpSet$$get_Tree(s$$22));\n}\nexport function FSharpSet$$Contains$$2B595(s$$23, x$$11) {\n  return SetTreeModule$$$mem(FSharpSet$$get_Comparer(s$$23), x$$11, FSharpSet$$get_Tree(s$$23));\n}\nexport function FSharpSet$$Iterate$$5028453F(s$$24, x$$12) {\n  SetTreeModule$$$iter(x$$12, FSharpSet$$get_Tree(s$$24));\n}\nexport function FSharpSet$$Fold(s$$25, f$$10, z) {\n  return SetTreeModule$$$fold(function (x$$13, z$$1) {\n    return f$$10(z$$1, x$$13);\n  }, z, FSharpSet$$get_Tree(s$$25));\n}\nexport function FSharpSet$$get_IsEmpty(s$$26) {\n  return SetTreeModule$$$isEmpty(FSharpSet$$get_Tree(s$$26));\n}\nexport function FSharpSet$$Partition$$Z1D55A0D7(s$$27, f$$11) {\n  const matchValue$$10 = FSharpSet$$get_Tree(s$$27);\n\n  if (matchValue$$10.tag === 0) {\n    return [s$$27, s$$27];\n  } else {\n    const patternInput$$6 = SetTreeModule$$$partition(FSharpSet$$get_Comparer(s$$27), f$$11, FSharpSet$$get_Tree(s$$27));\n    return [FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$27), patternInput$$6[0]), FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$27), patternInput$$6[1])];\n  }\n}\nexport function FSharpSet$$Filter$$Z1D55A0D7(s$$28, f$$12) {\n  const matchValue$$11 = FSharpSet$$get_Tree(s$$28);\n\n  if (matchValue$$11.tag === 0) {\n    return s$$28;\n  } else {\n    return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(s$$28), SetTreeModule$$$filter(FSharpSet$$get_Comparer(s$$28), f$$12, FSharpSet$$get_Tree(s$$28)));\n  }\n}\nexport function FSharpSet$$Map$$7597B8F7(s$$29, f$$13, comparer$$23) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$23, SetTreeModule$$$fold(function (acc$$13, k$$33) {\n    return SetTreeModule$$$add(comparer$$23, f$$13(k$$33), acc$$13);\n  }, new SetTree$00601(0, \"SetEmpty\"), FSharpSet$$get_Tree(s$$29)));\n}\nexport function FSharpSet$$Exists$$Z1D55A0D7(s$$30, f$$14) {\n  return SetTreeModule$$$exists(f$$14, FSharpSet$$get_Tree(s$$30));\n}\nexport function FSharpSet$$ForAll$$Z1D55A0D7(s$$31, f$$15) {\n  return SetTreeModule$$$forall(f$$15, FSharpSet$$get_Tree(s$$31));\n}\nexport function FSharpSet$$$op_Subtraction(a$$4, b$$5) {\n  const matchValue$$12 = FSharpSet$$get_Tree(a$$4);\n\n  if (matchValue$$12.tag === 0) {\n    return a$$4;\n  } else {\n    const matchValue$$13 = FSharpSet$$get_Tree(b$$5);\n\n    if (matchValue$$13.tag === 0) {\n      return a$$4;\n    } else {\n      return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(a$$4), SetTreeModule$$$diff(FSharpSet$$get_Comparer(a$$4), FSharpSet$$get_Tree(a$$4), FSharpSet$$get_Tree(b$$5)));\n    }\n  }\n}\nexport function FSharpSet$$$op_Addition(a$$5, b$$6) {\n  const matchValue$$14 = FSharpSet$$get_Tree(b$$6);\n\n  if (matchValue$$14.tag === 0) {\n    return a$$5;\n  } else {\n    const matchValue$$15 = FSharpSet$$get_Tree(a$$5);\n\n    if (matchValue$$15.tag === 0) {\n      return b$$6;\n    } else {\n      return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(a$$5), SetTreeModule$$$union(FSharpSet$$get_Comparer(a$$5), FSharpSet$$get_Tree(a$$5), FSharpSet$$get_Tree(b$$6)));\n    }\n  }\n}\nexport function FSharpSet$$$Intersection$$Z3BE9BFE0(a$$6, b$$7) {\n  const matchValue$$16 = FSharpSet$$get_Tree(b$$7);\n\n  if (matchValue$$16.tag === 0) {\n    return b$$7;\n  } else {\n    const matchValue$$17 = FSharpSet$$get_Tree(a$$6);\n\n    if (matchValue$$17.tag === 0) {\n      return a$$6;\n    } else {\n      return FSharpSet$$$$002Ector$$2528C5CB(FSharpSet$$get_Comparer(a$$6), SetTreeModule$$$intersection(FSharpSet$$get_Comparer(a$$6), FSharpSet$$get_Tree(a$$6), FSharpSet$$get_Tree(b$$7)));\n    }\n  }\n}\nexport function FSharpSet$$$IntersectionMany$$Z15B59630(sets) {\n  return reduce(FSharpSet$$$Intersection$$Z3BE9BFE0, sets);\n}\nexport function FSharpSet$$$Equality$$Z3BE9BFE0(a$$7, b$$8) {\n  return SetTreeModule$$$compare(FSharpSet$$get_Comparer(a$$7), FSharpSet$$get_Tree(a$$7), FSharpSet$$get_Tree(b$$8)) === 0;\n}\nexport function FSharpSet$$$Compare$$Z3BE9BFE0(a$$8, b$$9) {\n  return SetTreeModule$$$compare(FSharpSet$$get_Comparer(a$$8), FSharpSet$$get_Tree(a$$8), FSharpSet$$get_Tree(b$$9));\n}\nexport function FSharpSet$$get_Choose(x$$14) {\n  return SetTreeModule$$$choose(FSharpSet$$get_Tree(x$$14));\n}\nexport function FSharpSet$$get_MinimumElement(x$$15) {\n  return SetTreeModule$$$minimumElement(FSharpSet$$get_Tree(x$$15));\n}\nexport function FSharpSet$$get_MaximumElement(x$$16) {\n  return SetTreeModule$$$maximumElement(FSharpSet$$get_Tree(x$$16));\n}\nexport function FSharpSet$$IsSubsetOf$$6A20B1FF(x$$17, y) {\n  return SetTreeModule$$$subset(FSharpSet$$get_Comparer(x$$17), FSharpSet$$get_Tree(x$$17), FSharpSet$$get_Tree(y));\n}\nexport function FSharpSet$$IsSupersetOf$$6A20B1FF(x$$18, y$$1) {\n  return SetTreeModule$$$subset(FSharpSet$$get_Comparer(x$$18), FSharpSet$$get_Tree(y$$1), FSharpSet$$get_Tree(x$$18));\n}\nexport function FSharpSet$$IsProperSubsetOf$$6A20B1FF(x$$19, y$$2) {\n  return SetTreeModule$$$psubset(FSharpSet$$get_Comparer(x$$19), FSharpSet$$get_Tree(x$$19), FSharpSet$$get_Tree(y$$2));\n}\nexport function FSharpSet$$IsProperSupersetOf$$6A20B1FF(x$$20, y$$3) {\n  return SetTreeModule$$$psubset(FSharpSet$$get_Comparer(x$$20), FSharpSet$$get_Tree(y$$3), FSharpSet$$get_Tree(x$$20));\n}\n\nFSharpSet.prototype.toString = function () {\n  var strings;\n  const this$ = this;\n  return \"set [\" + (strings = map$$1(function (x$$21) {\n    let copyOfStruct = x$$21;\n    return String(copyOfStruct);\n  }, this$), (join(\"; \", strings))) + \"]\";\n};\n\nFSharpSet.prototype.GetHashCode = function () {\n  const this$$$1 = this;\n  let res = 0;\n  const e$$1 = SetTreeModule$$$mkIEnumerator(FSharpSet$$get_Tree(this$$$1));\n\n  while (e$$1.MoveNext()) {\n    const x$$22 = res | 0;\n    const y$$4 = structuralHash(e$$1.Current) | 0;\n    res = (x$$22 << 1) + y$$4 + 631;\n  }\n\n  return Math.abs(res) | 0;\n};\n\nFSharpSet.prototype.Equals = function (that) {\n  const this$$$2 = this;\n  return SetTreeModule$$$compare(FSharpSet$$get_Comparer(this$$$2), FSharpSet$$get_Tree(this$$$2), FSharpSet$$get_Tree(that)) === 0;\n};\n\nFSharpSet.prototype.CompareTo = function (that$$1) {\n  const this$$$3 = this;\n  return SetTreeModule$$$compare(FSharpSet$$get_Comparer(this$$$3), FSharpSet$$get_Tree(this$$$3), FSharpSet$$get_Tree(that$$1)) | 0;\n};\n\nFSharpSet.prototype[Symbol.iterator] = function () {\n  const s$$32 = this;\n  return toIterator(SetTreeModule$$$mkIEnumerator(FSharpSet$$get_Tree(s$$32)));\n};\n\nexport function isEmpty(s$$33) {\n  return FSharpSet$$get_IsEmpty(s$$33);\n}\nexport function contains(x$$23, s$$34) {\n  return FSharpSet$$Contains$$2B595(s$$34, x$$23);\n}\nexport function add(x$$24, s$$35) {\n  return FSharpSet$$Add$$2B595(s$$35, x$$24);\n}\nexport function singleton(x$$25, comparer$$24) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$24, new SetTree$00601(2, \"SetOne\", x$$25));\n}\nexport function remove(x$$26, s$$36) {\n  return FSharpSet$$Remove$$2B595(s$$36, x$$26);\n}\nexport function union(s1$$2, s2$$2) {\n  return FSharpSet$$$op_Addition(s1$$2, s2$$2);\n}\nexport function unionMany(sets$$1, comparer$$25) {\n  return fold$$1(FSharpSet$$$op_Addition, FSharpSet$$$$002Ector$$2528C5CB(comparer$$25, new SetTree$00601(0, \"SetEmpty\")), sets$$1);\n}\nexport function intersect(s1$$3, s2$$3) {\n  return FSharpSet$$$Intersection$$Z3BE9BFE0(s1$$3, s2$$3);\n}\nexport function intersectMany(sets$$2) {\n  return FSharpSet$$$IntersectionMany$$Z15B59630(sets$$2);\n}\nexport function iterate(f$$16, s$$37) {\n  FSharpSet$$Iterate$$5028453F(s$$37, f$$16);\n}\nexport function empty(comparer$$26) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$26, new SetTree$00601(0, \"SetEmpty\"));\n}\nexport function forAll(f$$17, s$$38) {\n  return FSharpSet$$ForAll$$Z1D55A0D7(s$$38, f$$17);\n}\nexport function exists(f$$18, s$$39) {\n  return FSharpSet$$Exists$$Z1D55A0D7(s$$39, f$$18);\n}\nexport function filter(f$$19, s$$40) {\n  return FSharpSet$$Filter$$Z1D55A0D7(s$$40, f$$19);\n}\nexport function partition(f$$20, s$$41) {\n  return FSharpSet$$Partition$$Z1D55A0D7(s$$41, f$$20);\n}\nexport function fold(f$$21, z$$2, s$$42) {\n  return SetTreeModule$$$fold(f$$21, z$$2, FSharpSet$$get_Tree(s$$42));\n}\nexport function foldBack(f$$22, s$$43, z$$3) {\n  return SetTreeModule$$$foldBack(f$$22, FSharpSet$$get_Tree(s$$43), z$$3);\n}\nexport function map(f$$23, s$$44, comparer$$27) {\n  return FSharpSet$$Map$$7597B8F7(s$$44, f$$23, comparer$$27);\n}\nexport function count(s$$45) {\n  return FSharpSet$$get_Count(s$$45);\n}\nexport function minimumElement(s$$46) {\n  return FSharpSet$$get_MinimumElement(s$$46);\n}\nexport function maximumElement(s$$47) {\n  return FSharpSet$$get_MaximumElement(s$$47);\n}\nexport function ofList(li, comparer$$28) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$28, SetTreeModule$$$ofSeq(comparer$$28, li));\n}\nexport function ofArray(arr$$2, comparer$$29) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$29, SetTreeModule$$$ofArray(comparer$$29, arr$$2));\n}\nexport function toList(s$$48) {\n  return SetTreeModule$$$toList(FSharpSet$$get_Tree(s$$48));\n}\nexport function toArray(s$$49, cons) {\n  const n$$3 = count(s$$49) | 0;\n  const res$$1 = new cons(n$$3);\n  SetTreeModule$$$copyToArray(FSharpSet$$get_Tree(s$$49), res$$1, 0);\n  return res$$1;\n}\nexport function toSeq(s$$50) {\n  return SetTreeModule$$$toSeq(FSharpSet$$get_Tree(s$$50));\n}\nexport function ofSeq(elements, comparer$$30) {\n  return FSharpSet$$$$002Ector$$2528C5CB(comparer$$30, SetTreeModule$$$ofSeq(comparer$$30, elements));\n}\nexport function difference(x$$28, y$$6) {\n  return FSharpSet$$$op_Subtraction(x$$28, y$$6);\n}\nexport function isSubset(x$$29, y$$7) {\n  return FSharpSet$$IsSubsetOf$$6A20B1FF(x$$29, y$$7);\n}\nexport function isSuperset(x$$30, y$$8) {\n  return FSharpSet$$IsSupersetOf$$6A20B1FF(x$$30, y$$8);\n}\nexport function isProperSubset(x$$31, y$$9) {\n  return FSharpSet$$IsProperSubsetOf$$6A20B1FF(x$$31, y$$9);\n}\nexport function isProperSuperset(x$$32, y$$10) {\n  return FSharpSet$$IsProperSupersetOf$$6A20B1FF(x$$32, y$$10);\n}\nexport function minElement(s$$51) {\n  return FSharpSet$$get_MinimumElement(s$$51);\n}\nexport function maxElement(s$$52) {\n  return FSharpSet$$get_MaximumElement(s$$52);\n}\nexport function createMutable(source, comparer$$31) {\n  const set = MutableSet$002400601$0024$0024$0024$0024002Ector$0024$0024Z6150332D(source, comparer$$31);\n  return set;\n}\nexport function distinct(xs, comparer$$32) {\n  return delay(function () {\n    const set$$1 = MutableSet$002400601$0024$0024$0024$0024002Ector$0024$0024Z6150332D(empty$$1(), comparer$$32);\n    return collect(function (x$$33) {\n      return MutableSet$002400601$0024$0024Add$0024$00242B595(set$$1, x$$33) ? singleton$$1(x$$33) : empty$$1();\n    }, xs);\n  });\n}\nexport function distinctBy(projection, xs$$1, comparer$$33) {\n  return delay(function () {\n    const set$$2 = MutableSet$002400601$0024$0024$0024$0024002Ector$0024$0024Z6150332D(empty$$1(), comparer$$33);\n    return collect(function (x$$34) {\n      return MutableSet$002400601$0024$0024Add$0024$00242B595(set$$2, projection(x$$34)) ? singleton$$1(x$$34) : empty$$1();\n    }, xs$$1);\n  });\n}\nexport function unionWith(s1$$4, s2$$4) {\n  return fold$$1(function folder(acc$$14, x$$35) {\n    return acc$$14.add(x$$35);\n  }, s1$$4, s2$$4);\n}\nexport function intersectWith(s1$$5, s2$$5, comparer$$34) {\n  const s2$$6 = ofSeq(s2$$5, comparer$$34);\n  iterate$$1(function (x$$36) {\n    if (!FSharpSet$$Contains$$2B595(s2$$6, x$$36)) {\n      const value = s1$$5.delete(x$$36);\n      void value;\n    } else {\n      void null;\n    }\n  }, s1$$5);\n}\nexport function exceptWith(s1$$6, s2$$7) {\n  iterate$$1(function (x$$37) {\n    const value$$1 = s1$$6.delete(x$$37);\n    void value$$1;\n  }, s2$$7);\n}\nexport function isSubsetOf(s1$$7, s2$$8, comparer$$35) {\n  return isSubset(ofSeq(s1$$7, comparer$$35), ofSeq(s2$$8, comparer$$35));\n}\nexport function isSupersetOf(s1$$8, s2$$9, comparer$$36) {\n  return isSuperset(ofSeq(s1$$8, comparer$$36), ofSeq(s2$$9, comparer$$36));\n}\nexport function isProperSubsetOf(s1$$9, s2$$10, comparer$$37) {\n  return isProperSubset(ofSeq(s1$$9, comparer$$37), ofSeq(s2$$10, comparer$$37));\n}\nexport function isProperSupersetOf(s1$$10, s2$$11, comparer$$38) {\n  return isProperSuperset(ofSeq(s1$$10, comparer$$38), ofSeq(s2$$11, comparer$$38));\n}","import { defaultArg, value as value$$15, some } from \"./Option.js\";\nimport { min as min$$1, compare, addToDict, addToSet, getItemFromDict, tryGetValue, max as max$$1, comparePrimitives } from \"./Util.js\";\nimport { createMutable } from \"./Map.js\";\nimport { createMutable as createMutable$$1 } from \"./Set.js\";\nimport { List } from \"./Types.js\";\nimport { iterate as iterate$$1 } from \"./Seq.js\";\nconst indexNotFoundMsg = \"An index satisfying the predicate was not found in the collection.\";\nexport function append(array1, array2, cons) {\n  if (ArrayBuffer.isView(array1)) {\n    const len1 = array1.length | 0;\n    const len2 = array2.length | 0;\n    const newArray = new cons(len1 + len2);\n\n    for (let i = 0; i <= len1 - 1; i++) {\n      newArray[i] = array1[i];\n    }\n\n    for (let i$$1 = 0; i$$1 <= len2 - 1; i$$1++) {\n      newArray[i$$1 + len1] = array2[i$$1];\n    }\n\n    return newArray;\n  } else {\n    return array1.concat(array2);\n  }\n}\nexport function filter(predicate, array) {\n  return array.filter(predicate);\n}\nexport function fill(target, targetIndex, count, value) {\n  target.fill(value, targetIndex, targetIndex + count);\n  return target;\n}\nexport function getSubArray(array$$3, start$$1, count$$2) {\n  return array$$3.slice(start$$1, start$$1 + count$$2);\n}\nexport function last(array$$5) {\n  if (array$$5.length === 0) {\n    throw new Error(\"The input array was empty\\\\nParameter name: array\");\n  } else {\n    void null;\n  }\n\n  return array$$5[array$$5.length - 1];\n}\nexport function tryLast(array$$6) {\n  if (array$$6.length === 0) {\n    return undefined;\n  } else {\n    return some(array$$6[array$$6.length - 1]);\n  }\n}\nexport function mapIndexed(f, source, cons$$1) {\n  if (ArrayBuffer.isView(source)) {\n    const len = source.length | 0;\n    const target$$1 = new cons$$1(len);\n\n    for (let i$$2 = 0; i$$2 <= len - 1; i$$2++) {\n      target$$1[i$$2] = f(i$$2, source[i$$2]);\n    }\n\n    return target$$1;\n  } else {\n    return source.map(function (delegateArg0, delegateArg1) {\n      return f(delegateArg1, delegateArg0);\n    });\n  }\n}\nexport function map(f$$1, source$$1, cons$$2) {\n  if (ArrayBuffer.isView(source$$1)) {\n    const len$$1 = source$$1.length | 0;\n    const target$$2 = new cons$$2(len$$1);\n\n    for (let i$$4 = 0; i$$4 <= len$$1 - 1; i$$4++) {\n      target$$2[i$$4] = f$$1(source$$1[i$$4]);\n    }\n\n    return target$$2;\n  } else {\n    return source$$1.map(function mapping$$1(x$$1) {\n      return f$$1(x$$1);\n    });\n  }\n}\nexport function mapIndexed2(f$$2, source1, source2, cons$$3) {\n  if (source1.length !== source2.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  const result = new cons$$3(source1.length);\n\n  for (let i$$5 = 0; i$$5 <= source1.length - 1; i$$5++) {\n    result[i$$5] = f$$2(i$$5, source1[i$$5], source2[i$$5]);\n  }\n\n  return result;\n}\nexport function map2(f$$3, source1$$1, source2$$1, cons$$4) {\n  if (source1$$1.length !== source2$$1.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  const result$$1 = new cons$$4(source1$$1.length);\n\n  for (let i$$6 = 0; i$$6 <= source1$$1.length - 1; i$$6++) {\n    result$$1[i$$6] = f$$3(source1$$1[i$$6], source2$$1[i$$6]);\n  }\n\n  return result$$1;\n}\nexport function mapIndexed3(f$$4, source1$$2, source2$$2, source3, cons$$5) {\n  if (source1$$2.length !== source2$$2.length ? true : source2$$2.length !== source3.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  const result$$2 = new cons$$5(source1$$2.length);\n\n  for (let i$$7 = 0; i$$7 <= source1$$2.length - 1; i$$7++) {\n    result$$2[i$$7] = f$$4(i$$7, source1$$2[i$$7], source2$$2[i$$7], source3[i$$7]);\n  }\n\n  return result$$2;\n}\nexport function map3(f$$5, source1$$3, source2$$3, source3$$1, cons$$6) {\n  if (source1$$3.length !== source2$$3.length ? true : source2$$3.length !== source3$$1.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  const result$$3 = new cons$$6(source1$$3.length);\n\n  for (let i$$8 = 0; i$$8 <= source1$$3.length - 1; i$$8++) {\n    result$$3[i$$8] = f$$5(source1$$3[i$$8], source2$$3[i$$8], source3$$1[i$$8]);\n  }\n\n  return result$$3;\n}\nexport function mapFold(mapping$$2, state, array$$9, cons$$7) {\n  const matchValue = array$$9.length | 0;\n\n  if (matchValue === 0) {\n    return [[], state];\n  } else {\n    let acc = state;\n    const res = new cons$$7(matchValue);\n\n    for (let i$$9 = 0; i$$9 <= array$$9.length - 1; i$$9++) {\n      const patternInput = mapping$$2(acc, array$$9[i$$9]);\n      res[i$$9] = patternInput[0];\n      acc = patternInput[1];\n    }\n\n    return [res, acc];\n  }\n}\nexport function mapFoldBack(mapping$$3, array$$10, state$$1, cons$$8) {\n  const matchValue$$1 = array$$10.length | 0;\n\n  if (matchValue$$1 === 0) {\n    return [[], state$$1];\n  } else {\n    let acc$$1 = state$$1;\n    const res$$1 = new cons$$8(matchValue$$1);\n\n    for (let i$$10 = array$$10.length - 1; i$$10 >= 0; i$$10--) {\n      const patternInput$$1 = mapping$$3(array$$10[i$$10], acc$$1);\n      res$$1[i$$10] = patternInput$$1[0];\n      acc$$1 = patternInput$$1[1];\n    }\n\n    return [res$$1, acc$$1];\n  }\n}\nexport function indexed(source$$2) {\n  const len$$4 = source$$2.length | 0;\n  const target$$3 = new Array(len$$4);\n\n  for (let i$$11 = 0; i$$11 <= len$$4 - 1; i$$11++) {\n    target$$3[i$$11] = [i$$11, source$$2[i$$11]];\n  }\n\n  return target$$3;\n}\nexport function truncate(count$$4, array$$11) {\n  const count$$5 = max$$1(comparePrimitives, 0, count$$4) | 0;\n  return array$$11.slice(0, 0 + count$$5);\n}\nexport function concat(arrays, cons$$9) {\n  var arr$$4;\n  const arrays$$1 = Array.isArray(arrays) ? arrays : Array.from(arrays);\n  const matchValue$$2 = arrays$$1.length | 0;\n\n  switch (matchValue$$2) {\n    case 0:\n      {\n        return new cons$$9(0);\n      }\n\n    case 1:\n      {\n        return arrays$$1[0];\n      }\n\n    default:\n      {\n        if (arr$$4 = arrays$$1[0], ArrayBuffer.isView(arr$$4)) {\n          let totalIdx = 0;\n          let totalLength = 0;\n\n          for (let idx = 0; idx <= arrays$$1.length - 1; idx++) {\n            const arr$$5 = arrays$$1[idx];\n            totalLength = totalLength + arr$$5.length;\n          }\n\n          const result$$4 = new cons$$9(totalLength);\n\n          for (let idx$$1 = 0; idx$$1 <= arrays$$1.length - 1; idx$$1++) {\n            const arr$$6 = arrays$$1[idx$$1];\n\n            for (let j = 0; j <= arr$$6.length - 1; j++) {\n              result$$4[totalIdx] = arr$$6[j];\n              totalIdx = totalIdx + 1;\n            }\n          }\n\n          return result$$4;\n        } else {\n          return arrays$$1[0].concat(...arrays$$1.slice(1));\n        }\n      }\n  }\n}\nexport function collect(mapping$$4, array$$14, cons$$10) {\n  const mapped = map(mapping$$4, array$$14, Array);\n  return concat(mapped, cons$$10);\n}\nexport function countBy(projection, array$$15, eq) {\n  const dict = createMutable([], eq);\n  const keys = [];\n\n  for (let idx$$2 = 0; idx$$2 <= array$$15.length - 1; idx$$2++) {\n    const value$$2 = array$$15[idx$$2];\n    const key = projection(value$$2);\n    const matchValue$$3 = tryGetValue(dict, key, 0);\n\n    if (matchValue$$3[0]) {\n      dict.set(key, matchValue$$3[1] + 1);\n    } else {\n      dict.set(key, 1);\n      const value$$3 = keys.push(key);\n      void value$$3;\n    }\n  }\n\n  const result$$5 = map(function (key$$1) {\n    return [key$$1, getItemFromDict(dict, key$$1)];\n  }, keys, Array);\n  return result$$5;\n}\nexport function distinctBy(projection$$1, array$$17, eq$$1) {\n  const hashSet = createMutable$$1([], eq$$1);\n  return filter(function predicate$$2($arg$$3) {\n    const arg00 = projection$$1($arg$$3);\n    return addToSet(arg00, hashSet);\n  }, array$$17);\n}\nexport function distinct(array$$19, eq$$2) {\n  return distinctBy(function (x$$2) {\n    return x$$2;\n  }, array$$19, eq$$2);\n}\nexport function where(predicate$$3, array$$20) {\n  return array$$20.filter(predicate$$3);\n}\nexport function contains(value$$4, array$$22, eq$$3) {\n  const loop = function loop($i$$12$$79) {\n    loop: while (true) {\n      const i$$12 = $i$$12$$79;\n\n      if (i$$12 >= array$$22.length) {\n        return false;\n      } else if (eq$$3.Equals(value$$4, array$$22[i$$12])) {\n        return true;\n      } else {\n        $i$$12$$79 = i$$12 + 1;\n        continue loop;\n      }\n\n      break;\n    }\n  };\n\n  return loop(0);\n}\nexport function except(itemsToExclude, array$$23, eq$$4) {\n  if (array$$23.length === 0) {\n    return array$$23;\n  } else {\n    const cached = createMutable$$1(itemsToExclude, eq$$4);\n    return array$$23.filter(function predicate$$5(arg00$$1) {\n      return addToSet(arg00$$1, cached);\n    });\n  }\n}\nexport function groupBy(projection$$2, array$$26, cons$$11, eq$$5) {\n  const dict$$1 = createMutable([], eq$$5);\n  const keys$$1 = [];\n\n  for (let idx$$3 = 0; idx$$3 <= array$$26.length - 1; idx$$3++) {\n    const v = array$$26[idx$$3];\n    const key$$2 = projection$$2(v);\n    const matchValue$$4 = tryGetValue(dict$$1, key$$2, null);\n\n    if (matchValue$$4[0]) {\n      dict$$1.set(key$$2, new List(v, matchValue$$4[1]));\n    } else {\n      addToDict(dict$$1, key$$2, new List(v, new List()));\n      const value$$5 = keys$$1.push(key$$2);\n      void value$$5;\n    }\n  }\n\n  const result$$6 = map(function (key$$3) {\n    var array$$28;\n    return [key$$3, (array$$28 = cons$$11.from(getItemFromDict(dict$$1, key$$3)), (array$$28.reverse()))];\n  }, keys$$1, Array);\n  return result$$6;\n}\nexport function empty(cons$$12) {\n  return new cons$$12(0);\n}\nexport function singleton(value$$6, cons$$14) {\n  const ar = new cons$$14(1);\n  ar[0] = value$$6;\n  return ar;\n}\nexport function initialize(count$$8, initializer, cons$$15) {\n  if (count$$8 < 0) {\n    throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n  } else {\n    void null;\n  }\n\n  const result$$7 = new cons$$15(count$$8);\n\n  for (let i$$13 = 0; i$$13 <= count$$8 - 1; i$$13++) {\n    result$$7[i$$13] = initializer(i$$13);\n  }\n\n  return result$$7;\n}\nexport function pairwise(array$$30) {\n  if (array$$30.length < 2) {\n    return [];\n  } else {\n    const count$$9 = array$$30.length - 1 | 0;\n    const result$$8 = new Array(count$$9);\n\n    for (let i$$14 = 0; i$$14 <= count$$9 - 1; i$$14++) {\n      result$$8[i$$14] = [array$$30[i$$14], array$$30[i$$14 + 1]];\n    }\n\n    return result$$8;\n  }\n}\nexport function replicate(count$$10, initial, cons$$16) {\n  if (count$$10 < 0) {\n    throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n  } else {\n    void null;\n  }\n\n  const result$$9 = new cons$$16(count$$10);\n\n  for (let i$$15 = 0; i$$15 <= result$$9.length - 1; i$$15++) {\n    result$$9[i$$15] = initial;\n  }\n\n  return result$$9;\n}\nexport function copy(array$$31, cons$$17) {\n  return array$$31.slice();\n}\nexport function reverse(array$$33, cons$$18) {\n  const array$$35 = array$$33.slice();\n  return array$$35.reverse();\n}\nexport function scan(folder, state$$2, array$$37, cons$$19) {\n  const res$$2 = new cons$$19(array$$37.length + 1);\n  res$$2[0] = state$$2;\n\n  for (let i$$16 = 0; i$$16 <= array$$37.length - 1; i$$16++) {\n    res$$2[i$$16 + 1] = folder(res$$2[i$$16], array$$37[i$$16]);\n  }\n\n  return res$$2;\n}\nexport function scanBack(folder$$1, array$$38, state$$3, cons$$20) {\n  const res$$3 = new cons$$20(array$$38.length + 1);\n  res$$3[array$$38.length] = state$$3;\n\n  for (let i$$17 = array$$38.length - 1; i$$17 >= 0; i$$17--) {\n    res$$3[i$$17] = folder$$1(array$$38[i$$17], res$$3[i$$17 + 1]);\n  }\n\n  return res$$3;\n}\nexport function skip(count$$11, array$$39, cons$$21) {\n  if (count$$11 > array$$39.length) {\n    throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n  } else {\n    void null;\n  }\n\n  if (count$$11 === array$$39.length) {\n    return new cons$$21(0);\n  } else {\n    const count$$12 = (count$$11 < 0 ? 0 : count$$11) | 0;\n    return array$$39.slice(count$$12);\n  }\n}\nexport function skipWhile(predicate$$7, array$$41, cons$$23) {\n  let count$$14 = 0;\n\n  while (count$$14 < array$$41.length ? predicate$$7(array$$41[count$$14]) : false) {\n    count$$14 = count$$14 + 1;\n  }\n\n  if (count$$14 === array$$41.length) {\n    return new cons$$23(0);\n  } else {\n    const count$$15 = count$$14 | 0;\n    return array$$41.slice(count$$15);\n  }\n}\nexport function take(count$$16, array$$43, cons$$25) {\n  if (count$$16 < 0) {\n    throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n  } else {\n    void null;\n  }\n\n  if (count$$16 > array$$43.length) {\n    throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n  } else {\n    void null;\n  }\n\n  if (count$$16 === 0) {\n    return new cons$$25(0);\n  } else {\n    return array$$43.slice(0, 0 + count$$16);\n  }\n}\nexport function takeWhile(predicate$$8, array$$45, cons$$27) {\n  let count$$18 = 0;\n\n  while (count$$18 < array$$45.length ? predicate$$8(array$$45[count$$18]) : false) {\n    count$$18 = count$$18 + 1;\n  }\n\n  if (count$$18 === 0) {\n    return new cons$$27(0);\n  } else {\n    const count$$19 = count$$18 | 0;\n    return array$$45.slice(0, 0 + count$$19);\n  }\n}\nexport function addInPlace(x$$3, array$$47) {\n  const value$$7 = array$$47.push(x$$3);\n  void value$$7;\n}\nexport function addRangeInPlace(range, array$$49) {\n  iterate$$1(function (x$$4) {\n    const value$$8 = array$$49.push(x$$4);\n    void value$$8;\n  }, range);\n}\nexport function removeInPlace(item$$5, array$$51) {\n  const i$$18 = array$$51.indexOf(item$$5);\n\n  if (i$$18 > -1) {\n    const value$$9 = array$$51.splice(i$$18, 1);\n    void value$$9;\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function removeAllInPlace(predicate$$9, array$$54) {\n  const countRemoveAll = function countRemoveAll(count$$20) {\n    const i$$19 = array$$54.findIndex(predicate$$9);\n\n    if (i$$19 > -1) {\n      const value$$10 = array$$54.splice(i$$19, 1);\n      void value$$10;\n      return countRemoveAll(count$$20) + 1 | 0;\n    } else {\n      return count$$20 | 0;\n    }\n  };\n\n  return countRemoveAll(0) | 0;\n}\nexport function copyTo(source$$3, sourceIndex, target$$4, targetIndex$$1, count$$21) {\n  const diff = targetIndex$$1 - sourceIndex | 0;\n\n  for (let i$$20 = sourceIndex; i$$20 <= sourceIndex + count$$21 - 1; i$$20++) {\n    target$$4[i$$20 + diff] = source$$3[i$$20];\n  }\n}\nexport function partition(f$$6, source$$4, cons$$29) {\n  const len$$7 = source$$4.length | 0;\n  const res1 = new cons$$29(len$$7);\n  const res2 = new cons$$29(len$$7);\n  let iTrue = 0;\n  let iFalse = 0;\n\n  for (let i$$21 = 0; i$$21 <= len$$7 - 1; i$$21++) {\n    if (f$$6(source$$4[i$$21])) {\n      res1[iTrue] = source$$4[i$$21];\n      iTrue = iTrue + 1;\n    } else {\n      res2[iFalse] = source$$4[i$$21];\n      iFalse = iFalse + 1;\n    }\n  }\n\n  return [(truncate(iTrue, res1)), (truncate(iFalse, res2))];\n}\nexport function find(predicate$$11, array$$59) {\n  const matchValue$$5 = array$$59.find(predicate$$11);\n\n  if (matchValue$$5 == null) {\n    throw new Error(indexNotFoundMsg);\n  } else {\n    const res$$4 = value$$15(matchValue$$5);\n    return res$$4;\n  }\n}\nexport function tryFind(predicate$$13, array$$61) {\n  return array$$61.find(predicate$$13);\n}\nexport function findIndex(predicate$$15, array$$63) {\n  const matchValue$$6 = array$$63.findIndex(predicate$$15);\n\n  if (matchValue$$6 > -1) {\n    return matchValue$$6 | 0;\n  } else {\n    throw new Error(indexNotFoundMsg);\n  }\n}\nexport function tryFindIndex(predicate$$17, array$$65) {\n  const matchValue$$7 = array$$65.findIndex(predicate$$17);\n\n  if (matchValue$$7 > -1) {\n    return matchValue$$7;\n  } else {\n    return undefined;\n  }\n}\nexport function pick(chooser, array$$67) {\n  const loop$$1 = function loop$$1($i$$22$$149) {\n    loop$$1: while (true) {\n      const i$$22 = $i$$22$$149;\n\n      if (i$$22 >= array$$67.length) {\n        throw new Error(indexNotFoundMsg);\n      } else {\n        const matchValue$$8 = chooser(array$$67[i$$22]);\n\n        if (matchValue$$8 != null) {\n          const res$$5 = value$$15(matchValue$$8);\n          return res$$5;\n        } else {\n          $i$$22$$149 = i$$22 + 1;\n          continue loop$$1;\n        }\n      }\n\n      break;\n    }\n  };\n\n  return loop$$1(0);\n}\nexport function tryPick(chooser$$1, array$$68) {\n  const loop$$2 = function loop$$2($i$$23$$152) {\n    loop$$2: while (true) {\n      const i$$23 = $i$$23$$152;\n\n      if (i$$23 >= array$$68.length) {\n        return undefined;\n      } else {\n        const matchValue$$9 = chooser$$1(array$$68[i$$23]);\n\n        if (matchValue$$9 == null) {\n          $i$$23$$152 = i$$23 + 1;\n          continue loop$$2;\n        } else {\n          return matchValue$$9;\n        }\n      }\n\n      break;\n    }\n  };\n\n  return loop$$2(0);\n}\nexport function findBack(predicate$$19, array$$69) {\n  const loop$$3 = function loop$$3($i$$24$$155) {\n    loop$$3: while (true) {\n      const i$$24 = $i$$24$$155;\n\n      if (i$$24 < 0) {\n        throw new Error(indexNotFoundMsg);\n      } else if (predicate$$19(array$$69[i$$24])) {\n        return array$$69[i$$24];\n      } else {\n        $i$$24$$155 = i$$24 - 1;\n        continue loop$$3;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$3(array$$69.length - 1);\n}\nexport function tryFindBack(predicate$$20, array$$70) {\n  const loop$$4 = function loop$$4($i$$25$$158) {\n    loop$$4: while (true) {\n      const i$$25 = $i$$25$$158;\n\n      if (i$$25 < 0) {\n        return undefined;\n      } else if (predicate$$20(array$$70[i$$25])) {\n        return some(array$$70[i$$25]);\n      } else {\n        $i$$25$$158 = i$$25 - 1;\n        continue loop$$4;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$4(array$$70.length - 1);\n}\nexport function findLastIndex(predicate$$21, array$$71) {\n  const loop$$5 = function loop$$5($i$$26$$161) {\n    loop$$5: while (true) {\n      const i$$26 = $i$$26$$161;\n\n      if (i$$26 < 0) {\n        return -1 | 0;\n      } else if (predicate$$21(array$$71[i$$26])) {\n        return i$$26 | 0;\n      } else {\n        $i$$26$$161 = i$$26 - 1;\n        continue loop$$5;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$5(array$$71.length - 1) | 0;\n}\nexport function findIndexBack(predicate$$22, array$$72) {\n  const loop$$6 = function loop$$6($i$$27$$164) {\n    loop$$6: while (true) {\n      const i$$27 = $i$$27$$164;\n\n      if (i$$27 < 0) {\n        throw new Error(indexNotFoundMsg);\n      } else if (predicate$$22(array$$72[i$$27])) {\n        return i$$27 | 0;\n      } else {\n        $i$$27$$164 = i$$27 - 1;\n        continue loop$$6;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$6(array$$72.length - 1) | 0;\n}\nexport function tryFindIndexBack(predicate$$23, array$$73) {\n  const loop$$7 = function loop$$7($i$$28$$167) {\n    loop$$7: while (true) {\n      const i$$28 = $i$$28$$167;\n\n      if (i$$28 < 0) {\n        return undefined;\n      } else if (predicate$$23(array$$73[i$$28])) {\n        return i$$28;\n      } else {\n        $i$$28$$167 = i$$28 - 1;\n        continue loop$$7;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$7(array$$73.length - 1);\n}\nexport function choose(chooser$$2, array$$74, cons$$30) {\n  const arr$$7 = array$$74.filter(function f$$7(x$$5) {\n    const option = chooser$$2(x$$5);\n    return option != null;\n  });\n  return map(function g(x$$6) {\n    const option$$1 = chooser$$2(x$$6);\n    return value$$15(option$$1);\n  }, arr$$7, cons$$30);\n}\nexport function foldIndexed(folder$$2, state$$4, array$$76) {\n  return array$$76.reduce(function (delegateArg0$$1, delegateArg1$$1, delegateArg2) {\n    return folder$$2(delegateArg2, delegateArg0$$1, delegateArg1$$1);\n  }, state$$4);\n}\nexport function fold(folder$$4, state$$6, array$$78) {\n  return array$$78.reduce(function (delegateArg0$$2, delegateArg1$$2) {\n    return folder$$4(delegateArg0$$2, delegateArg1$$2);\n  }, state$$6);\n}\nexport function iterate(action, array$$80) {\n  for (let i$$30 = 0; i$$30 <= array$$80.length - 1; i$$30++) {\n    action(array$$80[i$$30]);\n  }\n}\nexport function iterateIndexed(action$$1, array$$81) {\n  for (let i$$31 = 0; i$$31 <= array$$81.length - 1; i$$31++) {\n    action$$1(i$$31, array$$81[i$$31]);\n  }\n}\nexport function iterate2(action$$2, array1$$2, array2$$2) {\n  if (array1$$2.length !== array2$$2.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  for (let i$$32 = 0; i$$32 <= array1$$2.length - 1; i$$32++) {\n    action$$2(array1$$2[i$$32], array2$$2[i$$32]);\n  }\n}\nexport function iterateIndexed2(action$$3, array1$$3, array2$$3) {\n  if (array1$$3.length !== array2$$3.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  for (let i$$33 = 0; i$$33 <= array1$$3.length - 1; i$$33++) {\n    action$$3(i$$33, array1$$3[i$$33], array2$$3[i$$33]);\n  }\n}\nexport function isEmpty(array$$82) {\n  return array$$82.length === 0;\n}\nexport function forAll(predicate$$25, array$$83) {\n  return array$$83.every(predicate$$25);\n}\nexport function permute(f$$8, array$$85) {\n  const size = array$$85.length | 0;\n  const res$$7 = array$$85.slice();\n  const checkFlags = new Int32Array(size);\n  iterateIndexed(function (i$$34, x$$9) {\n    const j$$1 = f$$8(i$$34) | 0;\n\n    if (j$$1 < 0 ? true : j$$1 >= size) {\n      throw new Error(\"Not a valid permutation\");\n    } else {\n      void null;\n    }\n\n    res$$7[j$$1] = x$$9;\n    checkFlags[j$$1] = 1;\n  }, array$$85);\n  let isValid;\n  isValid = checkFlags.every(function predicate$$27(y) {\n    return 1 === y;\n  });\n\n  if (!isValid) {\n    throw new Error(\"Not a valid permutation\");\n  } else {\n    void null;\n  }\n\n  return res$$7;\n}\nexport function setSlice(target$$5, lower, upper, source$$5) {\n  const lower$$1 = defaultArg(lower, 0) | 0;\n  const upper$$1 = defaultArg(upper, 0) | 0;\n  const length = (upper$$1 > 0 ? upper$$1 : target$$5.length - 1) - lower$$1 | 0;\n\n  for (let i$$35 = 0; i$$35 <= length; i$$35++) {\n    target$$5[i$$35 + lower$$1] = source$$5[i$$35];\n  }\n}\nexport function sortInPlaceBy(projection$$3, xs, comparer) {\n  xs.sort(function (x$$11, y$$1) {\n    return comparer.Compare(projection$$3(x$$11), projection$$3(y$$1));\n  });\n}\nexport function sortInPlace(xs$$1, comparer$$1) {\n  xs$$1.sort(function (x$$12, y$$2) {\n    return comparer$$1.Compare(x$$12, y$$2);\n  });\n}\nexport function sort(xs$$2, comparer$$2) {\n  const xs$$3 = xs$$2.slice();\n  xs$$3.sort(function comparer$$3(x$$13, y$$3) {\n    return comparer$$2.Compare(x$$13, y$$3);\n  });\n  return xs$$3;\n}\nexport function sortBy(projection$$4, xs$$4, comparer$$4) {\n  const xs$$5 = xs$$4.slice();\n  xs$$5.sort(function comparer$$5(x$$14, y$$4) {\n    return comparer$$4.Compare(projection$$4(x$$14), projection$$4(y$$4));\n  });\n  return xs$$5;\n}\nexport function sortDescending(xs$$6, comparer$$6) {\n  const xs$$7 = xs$$6.slice();\n  xs$$7.sort(function comparer$$7(x$$15, y$$5) {\n    return comparer$$6.Compare(x$$15, y$$5) * -1;\n  });\n  return xs$$7;\n}\nexport function sortByDescending(projection$$5, xs$$8, comparer$$8) {\n  const xs$$9 = xs$$8.slice();\n  xs$$9.sort(function comparer$$9(x$$16, y$$6) {\n    return comparer$$8.Compare(projection$$5(x$$16), projection$$5(y$$6)) * -1;\n  });\n  return xs$$9;\n}\nexport function sortWith(comparer$$10, xs$$10) {\n  const xs$$11 = xs$$10.slice();\n  xs$$11.sort(comparer$$10);\n  return xs$$11;\n}\nexport function unfold(generator, state$$8) {\n  const res$$8 = [];\n\n  const loop$$8 = function loop$$8($state$$9$$226) {\n    loop$$8: while (true) {\n      const state$$9 = $state$$9$$226;\n      const matchValue$$10 = generator(state$$9);\n\n      if (matchValue$$10 != null) {\n        const x$$17 = matchValue$$10[0];\n        const s$$2 = matchValue$$10[1];\n        const value$$11 = res$$8.push(x$$17);\n        void value$$11;\n        $state$$9$$226 = s$$2;\n        continue loop$$8;\n      } else {\n        void null;\n      }\n\n      break;\n    }\n  };\n\n  loop$$8(state$$8);\n  return res$$8;\n}\nexport function unzip(array$$95) {\n  const len$$8 = array$$95.length | 0;\n  const res1$$1 = new Array(len$$8);\n  const res2$$1 = new Array(len$$8);\n  iterateIndexed(function (i$$36, tupledArg) {\n    res1$$1[i$$36] = tupledArg[0];\n    res2$$1[i$$36] = tupledArg[1];\n  }, array$$95);\n  return [res1$$1, res2$$1];\n}\nexport function unzip3(array$$96) {\n  const len$$11 = array$$96.length | 0;\n  const res1$$2 = new Array(len$$11);\n  const res2$$2 = new Array(len$$11);\n  const res3 = new Array(len$$11);\n  iterateIndexed(function (i$$37, tupledArg$$1) {\n    res1$$2[i$$37] = tupledArg$$1[0];\n    res2$$2[i$$37] = tupledArg$$1[1];\n    res3[i$$37] = tupledArg$$1[2];\n  }, array$$96);\n  return [res1$$2, res2$$2, res3];\n}\nexport function zip(array1$$4, array2$$4) {\n  if (array1$$4.length !== array2$$4.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  let result$$10;\n  const len$$15 = array1$$4.length | 0;\n  result$$10 = new Array(len$$15);\n\n  for (let i$$38 = 0; i$$38 <= array1$$4.length - 1; i$$38++) {\n    result$$10[i$$38] = [array1$$4[i$$38], array2$$4[i$$38]];\n  }\n\n  return result$$10;\n}\nexport function zip3(array1$$5, array2$$5, array3) {\n  if (array1$$5.length !== array2$$5.length ? true : array2$$5.length !== array3.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  let result$$11;\n  const len$$16 = array1$$5.length | 0;\n  result$$11 = new Array(len$$16);\n\n  for (let i$$39 = 0; i$$39 <= array1$$5.length - 1; i$$39++) {\n    result$$11[i$$39] = [array1$$5[i$$39], array2$$5[i$$39], array3[i$$39]];\n  }\n\n  return result$$11;\n}\nexport function chunkBySize(chunkSize, array$$97) {\n  if (chunkSize < 1) {\n    throw new Error(\"The input must be positive.\\\\nParameter name: size\");\n  } else {\n    void null;\n  }\n\n  if (array$$97.length === 0) {\n    return [[]];\n  } else {\n    const result$$12 = [];\n\n    for (let x$$18 = 0; x$$18 <= ~~Math.ceil(array$$97.length / chunkSize) - 1; x$$18++) {\n      const start$$8 = x$$18 * chunkSize | 0;\n      const slice = array$$97.slice(start$$8, start$$8 + chunkSize);\n      const value$$12 = result$$12.push(slice);\n      void value$$12;\n    }\n\n    return result$$12;\n  }\n}\nexport function splitAt(index$$4, array$$100) {\n  if (index$$4 < 0) {\n    throw new Error(\"The input must be non-negative\\\\nParameter name: index\");\n  } else {\n    void null;\n  }\n\n  if (index$$4 > array$$100.length) {\n    throw new Error(\"The input sequence has an insufficient number of elements.\\\\nParameter name: index\");\n  } else {\n    void null;\n  }\n\n  return [array$$100.slice(0, 0 + index$$4), array$$100.slice(index$$4)];\n}\nexport function compareWith(comparer$$12, array1$$6, array2$$6) {\n  if (array1$$6 == null) {\n    if (array2$$6 == null) {\n      return 0;\n    } else {\n      return -1 | 0;\n    }\n  } else if (array2$$6 == null) {\n    return 1;\n  } else {\n    let i$$40 = 0;\n    let result$$13 = 0;\n    const length1 = array1$$6.length | 0;\n    const length2 = array2$$6.length | 0;\n\n    if (length1 > length2) {\n      return 1;\n    } else if (length1 < length2) {\n      return -1 | 0;\n    } else {\n      while (i$$40 < length1 ? result$$13 === 0 : false) {\n        result$$13 = comparer$$12(array1$$6[i$$40], array2$$6[i$$40]);\n        i$$40 = i$$40 + 1;\n      }\n\n      return result$$13 | 0;\n    }\n  }\n}\nexport function equalsWith(comparer$$13, array1$$7, array2$$7) {\n  return compareWith(compare, array1$$7, array2$$7) === 0;\n}\nexport function exactlyOne(array$$103) {\n  if (array$$103.length === 1) {\n    return array$$103[0];\n  } else if (array$$103.length === 0) {\n    throw new Error(\"The input sequence was empty\\\\nParameter name: array\");\n  } else {\n    throw new Error(\"Input array too long\\\\nParameter name: array\");\n  }\n}\nexport function head(array$$104) {\n  if (array$$104.length === 0) {\n    throw new Error(\"The input array was empty\\\\nParameter name: array\");\n  } else {\n    return array$$104[0];\n  }\n}\nexport function tryHead(array$$105) {\n  if (array$$105.length === 0) {\n    return undefined;\n  } else {\n    return some(array$$105[0]);\n  }\n}\nexport function tail(array$$106) {\n  if (array$$106.length === 0) {\n    throw new Error(\"Not enough elements\\\\nParameter name: array\");\n  } else {\n    void null;\n  }\n\n  return array$$106.slice(1);\n}\nexport function item(index$$5, array$$108) {\n  return array$$108[index$$5];\n}\nexport function tryItem(index$$6, array$$109) {\n  if (index$$6 < 0 ? true : index$$6 >= array$$109.length) {\n    return undefined;\n  } else {\n    return some(array$$109[index$$6]);\n  }\n}\nexport function foldBackIndexed(folder$$6, array$$110, state$$10) {\n  return array$$110.reduceRight(function (delegateArg0$$3, delegateArg1$$3, delegateArg2$$1) {\n    return folder$$6(delegateArg2$$1, delegateArg1$$3, delegateArg0$$3);\n  }, state$$10);\n}\nexport function foldBack(folder$$8, array$$112, state$$12) {\n  return array$$112.reduceRight(function (delegateArg0$$4, delegateArg1$$4) {\n    return folder$$8(delegateArg1$$4, delegateArg0$$4);\n  }, state$$12);\n}\nexport function foldIndexed2(folder$$10, state$$14, array1$$8, array2$$8) {\n  let acc$$6 = state$$14;\n\n  if (array1$$8.length !== array2$$8.length) {\n    throw new Error(\"Arrays have different lengths\");\n  } else {\n    void null;\n  }\n\n  for (let i$$42 = 0; i$$42 <= array1$$8.length - 1; i$$42++) {\n    acc$$6 = folder$$10(i$$42, acc$$6, array1$$8[i$$42], array2$$8[i$$42]);\n  }\n\n  return acc$$6;\n}\nexport function fold2(folder$$11, state$$15, array1$$9, array2$$9) {\n  return foldIndexed2(function (_arg1, acc$$7, x$$21, y$$7) {\n    return folder$$11(acc$$7, x$$21, y$$7);\n  }, state$$15, array1$$9, array2$$9);\n}\nexport function foldBackIndexed2(folder$$12, array1$$10, array2$$10, state$$16) {\n  let acc$$8 = state$$16;\n\n  if (array1$$10.length !== array2$$10.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  const size$$1 = array1$$10.length | 0;\n\n  for (let i$$43 = 1; i$$43 <= size$$1; i$$43++) {\n    acc$$8 = folder$$12(i$$43 - 1, array1$$10[size$$1 - i$$43], array2$$10[size$$1 - i$$43], acc$$8);\n  }\n\n  return acc$$8;\n}\nexport function foldBack2(f$$9, array1$$11, array2$$11, state$$17) {\n  return foldBackIndexed2(function (_arg1$$1, x$$22, y$$8, acc$$9) {\n    return f$$9(x$$22, y$$8, acc$$9);\n  }, array1$$11, array2$$11, state$$17);\n}\nexport function reduce(reduction, array$$114) {\n  if (array$$114.length === 0) {\n    throw new Error(\"The input array was empty\");\n  } else {\n    void null;\n  }\n\n  return array$$114.reduce(reduction);\n}\nexport function reduceBack(reduction$$2, array$$116) {\n  if (array$$116.length === 0) {\n    throw new Error(\"The input array was empty\");\n  } else {\n    void null;\n  }\n\n  return array$$116.reduceRight(reduction$$2);\n}\nexport function forAll2(predicate$$29, array1$$12, array2$$12) {\n  return fold2(function (acc$$10, x$$23, y$$9) {\n    return acc$$10 ? predicate$$29(x$$23, y$$9) : false;\n  }, true, array1$$12, array2$$12);\n}\nexport function existsOffset($predicate$$30$$281, $array$$118$$282, $index$$7$$283) {\n  existsOffset: while (true) {\n    const predicate$$30 = $predicate$$30$$281,\n          array$$118 = $array$$118$$282,\n          index$$7 = $index$$7$$283;\n\n    if (index$$7 === array$$118.length) {\n      return false;\n    } else if (predicate$$30(array$$118[index$$7])) {\n      return true;\n    } else {\n      $predicate$$30$$281 = predicate$$30;\n      $array$$118$$282 = array$$118;\n      $index$$7$$283 = index$$7 + 1;\n      continue existsOffset;\n    }\n\n    break;\n  }\n}\nexport function exists(predicate$$31, array$$119) {\n  return existsOffset(predicate$$31, array$$119, 0);\n}\nexport function existsOffset2($predicate$$32$$286, $array1$$13$$287, $array2$$13$$288, $index$$8$$289) {\n  existsOffset2: while (true) {\n    const predicate$$32 = $predicate$$32$$286,\n          array1$$13 = $array1$$13$$287,\n          array2$$13 = $array2$$13$$288,\n          index$$8 = $index$$8$$289;\n\n    if (index$$8 === array1$$13.length) {\n      return false;\n    } else if (predicate$$32(array1$$13[index$$8], array2$$13[index$$8])) {\n      return true;\n    } else {\n      $predicate$$32$$286 = predicate$$32;\n      $array1$$13$$287 = array1$$13;\n      $array2$$13$$288 = array2$$13;\n      $index$$8$$289 = index$$8 + 1;\n      continue existsOffset2;\n    }\n\n    break;\n  }\n}\nexport function exists2(predicate$$33, array1$$14, array2$$14) {\n  if (array1$$14.length !== array2$$14.length) {\n    throw new Error(\"Arrays had different lengths\");\n  } else {\n    void null;\n  }\n\n  return existsOffset2(predicate$$33, array1$$14, array2$$14, 0);\n}\nexport function sum(array$$120, adder) {\n  let acc$$11 = adder.GetZero();\n\n  for (let i$$44 = 0; i$$44 <= array$$120.length - 1; i$$44++) {\n    acc$$11 = adder.Add(acc$$11, array$$120[i$$44]);\n  }\n\n  return acc$$11;\n}\nexport function sumBy(projection$$6, array$$121, adder$$1) {\n  let acc$$12 = adder$$1.GetZero();\n\n  for (let i$$45 = 0; i$$45 <= array$$121.length - 1; i$$45++) {\n    acc$$12 = adder$$1.Add(acc$$12, projection$$6(array$$121[i$$45]));\n  }\n\n  return acc$$12;\n}\nexport function maxBy(projection$$7, xs$$12, comparer$$14) {\n  return reduce(function (x$$24, y$$10) {\n    return comparer$$14.Compare(projection$$7(y$$10), projection$$7(x$$24)) > 0 ? y$$10 : x$$24;\n  }, xs$$12);\n}\nexport function max(xs$$13, comparer$$15) {\n  return reduce(function (x$$25, y$$11) {\n    return comparer$$15.Compare(y$$11, x$$25) > 0 ? y$$11 : x$$25;\n  }, xs$$13);\n}\nexport function minBy(projection$$8, xs$$14, comparer$$16) {\n  return reduce(function (x$$26, y$$12) {\n    return comparer$$16.Compare(projection$$8(y$$12), projection$$8(x$$26)) > 0 ? x$$26 : y$$12;\n  }, xs$$14);\n}\nexport function min(xs$$15, comparer$$17) {\n  return reduce(function (x$$27, y$$13) {\n    return comparer$$17.Compare(y$$13, x$$27) > 0 ? x$$27 : y$$13;\n  }, xs$$15);\n}\nexport function average(array$$122, averager) {\n  if (array$$122.length === 0) {\n    throw new Error(\"The input array was empty\\\\nParameter name: array\");\n  } else {\n    void null;\n  }\n\n  let total = averager.GetZero();\n\n  for (let i$$46 = 0; i$$46 <= array$$122.length - 1; i$$46++) {\n    total = averager.Add(total, array$$122[i$$46]);\n  }\n\n  return averager.DivideByInt(total, array$$122.length);\n}\nexport function averageBy(projection$$9, array$$123, averager$$1) {\n  if (array$$123.length === 0) {\n    throw new Error(\"The input array was empty\\\\nParameter name: array\");\n  } else {\n    void null;\n  }\n\n  let total$$1 = averager$$1.GetZero();\n\n  for (let i$$47 = 0; i$$47 <= array$$123.length - 1; i$$47++) {\n    total$$1 = averager$$1.Add(total$$1, projection$$9(array$$123[i$$47]));\n  }\n\n  return averager$$1.DivideByInt(total$$1, array$$123.length);\n}\nexport function ofSeq(source$$6, cons$$31) {\n  return cons$$31.from(source$$6);\n}\nexport function ofList(source$$7, cons$$32) {\n  return cons$$32.from(source$$7);\n}\nexport function toList(source$$8) {\n  const len$$17 = source$$8.length | 0;\n  let target$$6 = new List();\n\n  for (let i$$48 = len$$17 - 1; i$$48 >= 0; i$$48--) {\n    target$$6 = new List(source$$8[i$$48], target$$6);\n  }\n\n  return target$$6;\n}\nexport function windowed(windowSize, source$$9) {\n  if (windowSize <= 0) {\n    throw new Error(\"windowSize must be positive\");\n  } else {\n    void null;\n  }\n\n  let res$$9;\n  const len$$18 = max$$1(comparePrimitives, 0, source$$9.length - windowSize) | 0;\n  res$$9 = new Array(len$$18);\n\n  for (let i$$49 = windowSize; i$$49 <= source$$9.length; i$$49++) {\n    res$$9[i$$49 - windowSize] = source$$9.slice(i$$49 - windowSize, i$$49 - 1 + 1);\n  }\n\n  return res$$9;\n}\nexport function splitInto(chunks, array$$124) {\n  if (chunks < 1) {\n    throw new Error(\"The input must be positive.\\\\nParameter name: chunks\");\n  } else {\n    void null;\n  }\n\n  if (array$$124.length === 0) {\n    return [[]];\n  } else {\n    const result$$14 = [];\n    const chunks$$1 = min$$1(comparePrimitives, chunks, array$$124.length) | 0;\n    const minChunkSize = ~~(array$$124.length / chunks$$1) | 0;\n    const chunksWithExtraItem = array$$124.length % chunks$$1 | 0;\n\n    for (let i$$50 = 0; i$$50 <= chunks$$1 - 1; i$$50++) {\n      const chunkSize$$1 = (i$$50 < chunksWithExtraItem ? minChunkSize + 1 : minChunkSize) | 0;\n      const start$$11 = i$$50 * minChunkSize + min$$1(comparePrimitives, chunksWithExtraItem, i$$50) | 0;\n      const slice$$1 = array$$124.slice(start$$11, start$$11 + chunkSize$$1);\n      const value$$13 = result$$14.push(slice$$1);\n      void value$$13;\n    }\n\n    return result$$14;\n  }\n}\nexport function transpose(arrays$$2, cons$$33) {\n  var value$$14;\n  const arrays$$3 = Array.isArray(arrays$$2) ? arrays$$2 : Array.from(arrays$$2);\n  const len$$20 = arrays$$3.length | 0;\n\n  if (len$$20 === 0) {\n    return new Array(0);\n  } else {\n    const lenInner = arrays$$3[0].length | 0;\n\n    if (value$$14 = (forAll(function predicate$$34(a) {\n      return a.length === lenInner;\n    }, arrays$$3)), (!value$$14)) {\n      throw new Error(\"Arrays had different lengths\");\n    } else {\n      void null;\n    }\n\n    const result$$15 = new Array(lenInner);\n\n    for (let i$$51 = 0; i$$51 <= lenInner - 1; i$$51++) {\n      result$$15[i$$51] = new cons$$33(len$$20);\n\n      for (let j$$2 = 0; j$$2 <= len$$20 - 1; j$$2++) {\n        result$$15[i$$51][j$$2] = arrays$$3[j$$2][i$$51];\n      }\n    }\n\n    return result$$15;\n  }\n}","import { List, declare, Record } from \"../Types.js\";\nimport { record_type, array_type, int32_type } from \"../Reflection.js\";\nimport { op_LeftShift, op_BitwiseAnd, op_Addition, compare, op_Subtraction, op_Division, equals, toInt, op_Modulus, op_Multiply, fromInteger, fromBits } from \"../Long.js\";\nimport { ofList, copy, initialize, map, fill } from \"../Array.js\";\nimport { int32ToString } from \"../Util.js\";\nimport { isNullOrEmpty, join } from \"../String.js\";\nexport const BigNat = declare(function BigInt_BigNat(bound, digits) {\n  this.bound = bound | 0;\n  this.digits = digits;\n}, Record);\nexport function BigNat$reflection() {\n  return record_type(\"BigInt.BigNat\", [], BigNat, () => [[\"bound\", int32_type], [\"digits\", array_type(int32_type)]]);\n}\nexport function BigNatModule$002EFFT$$$pow32($x$$1, $n$$2) {\n  BigNatModule$002EFFT$$$pow32: while (true) {\n    const x = $x$$1,\n          n = $n$$2;\n\n    if (n === 0) {\n      return 1;\n    } else if (n % 2 === 0) {\n      $x$$1 = x * x;\n      $n$$2 = ~~(n / 2);\n      continue BigNatModule$002EFFT$$$pow32;\n    } else {\n      return x * BigNatModule$002EFFT$$$pow32(x * x, ~~(n / 2)) | 0;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$002EFFT$$$leastBounding2Power(b) {\n  const findBounding2Power = function findBounding2Power($b$$1$$4, $tp$$5, $i$$6) {\n    findBounding2Power: while (true) {\n      const b$$1 = $b$$1$$4,\n            tp = $tp$$5,\n            i = $i$$6;\n\n      if (b$$1 <= tp) {\n        return [tp, i];\n      } else {\n        $b$$1$$4 = b$$1;\n        $tp$$5 = tp * 2;\n        $i$$6 = i + 1;\n        continue findBounding2Power;\n      }\n\n      break;\n    }\n  };\n\n  return findBounding2Power(b, 1, 0);\n}\nexport const BigNatModule$002EFFT$$$p = fromBits(2013265921, 0, false);\nconst BigNatModule$002EFFT$$$patternInput$004075 = [27, 15, 31, 440564289];\nexport const BigNatModule$002EFFT$$$w = BigNatModule$002EFFT$$$patternInput$004075[3];\nexport const BigNatModule$002EFFT$$$m = BigNatModule$002EFFT$$$patternInput$004075[1];\nexport const BigNatModule$002EFFT$$$k = BigNatModule$002EFFT$$$patternInput$004075[0];\nexport const BigNatModule$002EFFT$$$g = BigNatModule$002EFFT$$$patternInput$004075[2];\nexport const BigNatModule$002EFFT$$$primeP = BigNatModule$002EFFT$$$p;\nexport const BigNatModule$002EFFT$$$maxBitsInsideFp = 30;\nexport const BigNatModule$002EFFT$002EFp$$$p = 2013265921;\nexport const BigNatModule$002EFFT$002EFp$$$p64 = fromBits(2013265921, 0, true);\nexport function BigNatModule$002EFFT$002EFp$$$toInt(x$$1) {\n  return ~~x$$1;\n}\nexport function BigNatModule$002EFFT$002EFp$$$ofInt32(x$$2) {\n  return x$$2 >>> 0;\n}\nexport const BigNatModule$002EFFT$002EFp$$$mzero = 0;\nexport const BigNatModule$002EFFT$002EFp$$$mone = 1;\nexport const BigNatModule$002EFFT$002EFp$$$mtwo = 2;\nexport function BigNatModule$002EFFT$002EFp$$$mpow($x$$3$$9, $n$$1$$10) {\n  BigNatModule$002EFFT$002EFp$$$mpow: while (true) {\n    const x$$3 = $x$$3$$9,\n          n$$1 = $n$$1$$10;\n\n    if (n$$1 === 0) {\n      return BigNatModule$002EFFT$002EFp$$$mone;\n    } else if (n$$1 % 2 === 0) {\n      $x$$3$$9 = toInt(op_Modulus(op_Multiply(fromInteger(x$$3, true, 6), fromInteger(x$$3, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n      $n$$1$$10 = ~~(n$$1 / 2);\n      continue BigNatModule$002EFFT$002EFp$$$mpow;\n    } else {\n      const y$$2 = BigNatModule$002EFFT$002EFp$$$mpow(toInt(op_Modulus(op_Multiply(fromInteger(x$$3, true, 6), fromInteger(x$$3, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0, ~~(n$$1 / 2));\n      return toInt(op_Modulus(op_Multiply(fromInteger(x$$3, true, 6), fromInteger(y$$2, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$002EFFT$002EFp$$$mpowL($x$$7$$11, $n$$2$$12) {\n  BigNatModule$002EFFT$002EFp$$$mpowL: while (true) {\n    const x$$7 = $x$$7$$11,\n          n$$2 = $n$$2$$12;\n\n    if (equals(n$$2, fromBits(0, 0, false))) {\n      return BigNatModule$002EFFT$002EFp$$$mone;\n    } else if (equals(op_Modulus(n$$2, fromBits(2, 0, false)), fromBits(0, 0, false))) {\n      $x$$7$$11 = toInt(op_Modulus(op_Multiply(fromInteger(x$$7, true, 6), fromInteger(x$$7, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n      $n$$2$$12 = op_Division(n$$2, fromBits(2, 0, false));\n      continue BigNatModule$002EFFT$002EFp$$$mpowL;\n    } else {\n      const y$$5 = BigNatModule$002EFFT$002EFp$$$mpowL(toInt(op_Modulus(op_Multiply(fromInteger(x$$7, true, 6), fromInteger(x$$7, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0, op_Division(n$$2, fromBits(2, 0, false)));\n      return toInt(op_Modulus(op_Multiply(fromInteger(x$$7, true, 6), fromInteger(y$$5, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$002EFFT$002EFp$$$m2PowNthRoot(n$$3) {\n  return BigNatModule$002EFFT$002EFp$$$mpow(BigNatModule$002EFFT$$$w >>> 0, BigNatModule$002EFFT$$$pow32(2, BigNatModule$002EFFT$$$k - n$$3));\n}\nexport function BigNatModule$002EFFT$002EFp$$$minv(x$$11) {\n  return BigNatModule$002EFFT$002EFp$$$mpowL(x$$11, op_Subtraction(BigNatModule$002EFFT$$$primeP, fromBits(2, 0, false)));\n}\nexport function BigNatModule$002EFFT$$$computeFFT(lambda, mu, n$$4, w, u, res, offset) {\n  if (n$$4 === 1) {\n    res[offset] = u[mu];\n  } else {\n    const halfN = ~~(n$$4 / 2) | 0;\n    const ww = toInt(op_Modulus(op_Multiply(fromInteger(w, true, 6), fromInteger(w, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n    const offsetHalfN = offset + halfN | 0;\n    BigNatModule$002EFFT$$$computeFFT(lambda * 2, mu, halfN, ww, u, res, offset);\n    BigNatModule$002EFFT$$$computeFFT(lambda * 2, lambda + mu, halfN, ww, u, res, offsetHalfN);\n    let wj = BigNatModule$002EFFT$002EFp$$$mone;\n\n    for (let j = 0; j <= halfN - 1; j++) {\n      const even = res[offset + j];\n      const odd = res[offsetHalfN + j];\n      let y$$8;\n      const x$$13 = wj;\n      y$$8 = toInt(op_Modulus(op_Multiply(fromInteger(x$$13, true, 6), fromInteger(odd, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n      res[offset + j] = (even + y$$8) % BigNatModule$002EFFT$002EFp$$$p;\n      let y$$10;\n      const x$$15 = wj;\n      y$$10 = toInt(op_Modulus(op_Multiply(fromInteger(x$$15, true, 6), fromInteger(odd, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n      res[offsetHalfN + j] = (even + BigNatModule$002EFFT$002EFp$$$p - y$$10) % BigNatModule$002EFFT$002EFp$$$p;\n      const y$$11 = wj;\n      wj = toInt(op_Modulus(op_Multiply(fromInteger(w, true, 6), fromInteger(y$$11, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n    }\n  }\n}\nexport function BigNatModule$002EFFT$$$computFftInPlace(n$$5, w$$1, u$$1) {\n  const res$$1 = fill(new Uint32Array(n$$5), 0, n$$5, BigNatModule$002EFFT$002EFp$$$mzero);\n  BigNatModule$002EFFT$$$computeFFT(1, 0, n$$5, w$$1, u$$1, res$$1, 0);\n  return res$$1;\n}\nexport function BigNatModule$002EFFT$$$computeInverseFftInPlace(n$$6, w$$2, uT) {\n  const bigKInv = BigNatModule$002EFFT$002EFp$$$minv(n$$6 >>> 0);\n  return map(function (y$$12) {\n    return toInt(op_Modulus(op_Multiply(fromInteger(bigKInv, true, 6), fromInteger(y$$12, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n  }, BigNatModule$002EFFT$$$computFftInPlace(n$$6, BigNatModule$002EFFT$002EFp$$$minv(w$$2), uT), Uint32Array);\n}\nexport const BigNatModule$002EFFT$$$maxTwoPower = 29;\nexport const BigNatModule$002EFFT$$$twoPowerTable = initialize(BigNatModule$002EFFT$$$maxTwoPower - 1, function (i$$1) {\n  return BigNatModule$002EFFT$$$pow32(2, i$$1);\n}, Int32Array);\nexport function BigNatModule$002EFFT$$$computeFftPaddedPolynomialProduct(bigK, k, u$$2, v) {\n  const w$$3 = BigNatModule$002EFFT$002EFp$$$m2PowNthRoot(k);\n  const uT$$1 = BigNatModule$002EFFT$$$computFftInPlace(bigK, w$$3, u$$2);\n  const vT = BigNatModule$002EFFT$$$computFftInPlace(bigK, w$$3, v);\n  const rT = initialize(bigK, function (i$$2) {\n    const x$$19 = uT$$1[i$$2];\n    const y$$14 = vT[i$$2];\n    return toInt(op_Modulus(op_Multiply(fromInteger(x$$19, true, 6), fromInteger(y$$14, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n  }, Uint32Array);\n  const r = BigNatModule$002EFFT$$$computeInverseFftInPlace(bigK, w$$3, rT);\n  return r;\n}\nexport function BigNatModule$002EFFT$$$padTo(n$$8, u$$3) {\n  const uBound = u$$3.length | 0;\n  return initialize(n$$8, function (i$$3) {\n    return i$$3 < uBound ? BigNatModule$002EFFT$002EFp$$$ofInt32(u$$3[i$$3]) : BigNatModule$002EFFT$002EFp$$$mzero;\n  }, Uint32Array);\n}\nexport function BigNatModule$002EFFT$$$computeFftPolynomialProduct(degu, u$$4, degv, v$$1) {\n  const deguv = degu + degv | 0;\n  const bound = deguv + 1 | 0;\n  const patternInput = BigNatModule$002EFFT$$$leastBounding2Power(bound);\n  const w$$4 = BigNatModule$002EFFT$002EFp$$$m2PowNthRoot(patternInput[1]);\n  const u$$5 = BigNatModule$002EFFT$$$padTo(patternInput[0], u$$4);\n  const v$$2 = BigNatModule$002EFFT$$$padTo(patternInput[0], v$$1);\n  const uT$$2 = BigNatModule$002EFFT$$$computFftInPlace(patternInput[0], w$$4, u$$5);\n  const vT$$1 = BigNatModule$002EFFT$$$computFftInPlace(patternInput[0], w$$4, v$$2);\n  const rT$$1 = initialize(patternInput[0], function (i$$4) {\n    const x$$20 = uT$$2[i$$4];\n    const y$$15 = vT$$1[i$$4];\n    return toInt(op_Modulus(op_Multiply(fromInteger(x$$20, true, 6), fromInteger(y$$15, true, 6)), BigNatModule$002EFFT$002EFp$$$p64)) >>> 0;\n  }, Uint32Array);\n  const r$$1 = BigNatModule$002EFFT$$$computeInverseFftInPlace(patternInput[0], w$$4, rT$$1);\n  return map(BigNatModule$002EFFT$002EFp$$$toInt, r$$1, Int32Array);\n}\nexport const BigNatModule$002EFFT$$$mzero = BigNatModule$002EFFT$002EFp$$$mzero;\nexport const BigNatModule$002EFFT$$$mone = BigNatModule$002EFFT$002EFp$$$mone;\nexport const BigNatModule$002EFFT$$$maxFp = (BigNatModule$002EFFT$002EFp$$$p + BigNatModule$002EFFT$002EFp$$$p - BigNatModule$002EFFT$$$mone) % BigNatModule$002EFFT$002EFp$$$p;\nexport function BigNatModule$$$bound(n$$10) {\n  return n$$10.bound;\n}\nexport function BigNatModule$$$setBound(n$$11, v$$3) {\n  n$$11.bound = v$$3;\n}\nexport function BigNatModule$$$coeff(n$$12, i$$5) {\n  return n$$12.digits[i$$5];\n}\nexport function BigNatModule$$$coeff64(n$$13, i$$6) {\n  return fromInteger(BigNatModule$$$coeff(n$$13, i$$6), false, 2);\n}\nexport function BigNatModule$$$setCoeff(n$$14, i$$7, v$$4) {\n  n$$14.digits[i$$7] = v$$4;\n}\nexport function BigNatModule$$$pow64($x$$23$$48, $n$$15$$49) {\n  BigNatModule$$$pow64: while (true) {\n    const x$$23 = $x$$23$$48,\n          n$$15 = $n$$15$$49;\n\n    if (n$$15 === 0) {\n      return fromBits(1, 0, false);\n    } else if (n$$15 % 2 === 0) {\n      $x$$23$$48 = op_Multiply(x$$23, x$$23);\n      $n$$15$$49 = ~~(n$$15 / 2);\n      continue BigNatModule$$$pow64;\n    } else {\n      return op_Multiply(x$$23, BigNatModule$$$pow64(op_Multiply(x$$23, x$$23), ~~(n$$15 / 2)));\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$$$pow32($x$$24$$50, $n$$16$$51) {\n  BigNatModule$$$pow32: while (true) {\n    const x$$24 = $x$$24$$50,\n          n$$16 = $n$$16$$51;\n\n    if (n$$16 === 0) {\n      return 1;\n    } else if (n$$16 % 2 === 0) {\n      $x$$24$$50 = x$$24 * x$$24;\n      $n$$16$$51 = ~~(n$$16 / 2);\n      continue BigNatModule$$$pow32;\n    } else {\n      return x$$24 * BigNatModule$$$pow32(x$$24 * x$$24, ~~(n$$16 / 2)) | 0;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$$$hash(n$$17) {\n  let res$$2 = 0;\n\n  for (let i$$8 = 0; i$$8 <= n$$17.bound - 1; i$$8++) {\n    res$$2 = n$$17.digits[i$$8] + (res$$2 << 3);\n  }\n\n  return res$$2 | 0;\n}\nexport function BigNatModule$$$maxInt(a, b$$2) {\n  if (a < b$$2) {\n    return b$$2 | 0;\n  } else {\n    return a | 0;\n  }\n}\nexport function BigNatModule$$$minInt(a$$1, b$$3) {\n  if (a$$1 < b$$3) {\n    return a$$1 | 0;\n  } else {\n    return b$$3 | 0;\n  }\n}\nexport const BigNatModule$$$baseBits = 24;\nexport const BigNatModule$$$baseN = 16777216;\nexport const BigNatModule$$$baseMask = 16777215;\nexport const BigNatModule$$$baseNi64 = fromBits(16777216, 0, false);\nexport const BigNatModule$$$baseMaski64 = fromBits(16777215, 0, false);\nexport const BigNatModule$$$baseMaskU = fromBits(16777215, 0, true);\nexport const BigNatModule$$$baseMask32A = 16777215;\nexport const BigNatModule$$$baseMask32B = 255;\nexport const BigNatModule$$$baseShift32B = 24;\nexport const BigNatModule$$$baseMask64A = 16777215;\nexport const BigNatModule$$$baseMask64B = 16777215;\nexport const BigNatModule$$$baseMask64C = 65535;\nexport const BigNatModule$$$baseShift64B = 24;\nexport const BigNatModule$$$baseShift64C = 48;\nexport function BigNatModule$$$divbase(x$$25) {\n  return ~~(x$$25 >>> 0 >>> BigNatModule$$$baseBits);\n}\nexport function BigNatModule$$$modbase(x$$26) {\n  return x$$26 & BigNatModule$$$baseMask;\n}\nexport function BigNatModule$$$createN(b$$4) {\n  return new BigNat(b$$4, new Int32Array(b$$4));\n}\nexport function BigNatModule$$$copyN(x$$27) {\n  return new BigNat(x$$27.bound, copy(x$$27.digits, Int32Array));\n}\nexport function BigNatModule$$$normN(n$$18) {\n  const findLeastBound = function findLeastBound($na$$62, $i$$9$$63) {\n    findLeastBound: while (true) {\n      const na = $na$$62,\n            i$$9 = $i$$9$$63;\n\n      if (i$$9 === -1 ? true : na[i$$9] !== 0) {\n        return i$$9 + 1 | 0;\n      } else {\n        $na$$62 = na;\n        $i$$9$$63 = i$$9 - 1;\n        continue findLeastBound;\n      }\n\n      break;\n    }\n  };\n\n  const bound$$1 = findLeastBound(n$$18.digits, n$$18.bound - 1) | 0;\n  n$$18.bound = bound$$1;\n  return n$$18;\n}\nexport const BigNatModule$$$boundInt = 2;\nexport const BigNatModule$$$boundInt64 = 3;\nexport const BigNatModule$$$boundBase = 1;\nexport function BigNatModule$$$embed(x$$28) {\n  const x$$29 = (x$$28 < 0 ? 0 : x$$28) | 0;\n\n  if (x$$29 < BigNatModule$$$baseN) {\n    const r$$2 = BigNatModule$$$createN(1);\n    r$$2.digits[0] = x$$29;\n    return BigNatModule$$$normN(r$$2);\n  } else {\n    const r$$3 = BigNatModule$$$createN(BigNatModule$$$boundInt);\n\n    for (let i$$10 = 0; i$$10 <= BigNatModule$$$boundInt - 1; i$$10++) {\n      r$$3.digits[i$$10] = ~~(x$$29 / BigNatModule$$$pow32(BigNatModule$$$baseN, i$$10)) % BigNatModule$$$baseN;\n    }\n\n    return BigNatModule$$$normN(r$$3);\n  }\n}\nexport function BigNatModule$$$embed64(x$$30) {\n  const x$$31 = compare(x$$30, fromBits(0, 0, false)) < 0 ? fromBits(0, 0, false) : x$$30;\n  const r$$4 = BigNatModule$$$createN(BigNatModule$$$boundInt64);\n\n  for (let i$$11 = 0; i$$11 <= BigNatModule$$$boundInt64 - 1; i$$11++) {\n    r$$4.digits[i$$11] = ~~toInt(op_Modulus(op_Division(x$$31, BigNatModule$$$pow64(BigNatModule$$$baseNi64, i$$11)), BigNatModule$$$baseNi64));\n  }\n\n  return BigNatModule$$$normN(r$$4);\n}\nexport function BigNatModule$$$eval32(n$$19) {\n  if (n$$19.bound === 1) {\n    return n$$19.digits[0] | 0;\n  } else {\n    let acc = 0;\n\n    for (let i$$12 = n$$19.bound - 1; i$$12 >= 0; i$$12--) {\n      acc = n$$19.digits[i$$12] + BigNatModule$$$baseN * acc;\n    }\n\n    return acc | 0;\n  }\n}\nexport function BigNatModule$$$eval64(n$$20) {\n  if (n$$20.bound === 1) {\n    return fromInteger(n$$20.digits[0], false, 2);\n  } else {\n    let acc$$1 = fromBits(0, 0, false);\n\n    for (let i$$13 = n$$20.bound - 1; i$$13 >= 0; i$$13--) {\n      acc$$1 = op_Addition(fromInteger(n$$20.digits[i$$13], false, 2), op_Multiply(BigNatModule$$$baseNi64, acc$$1));\n    }\n\n    return acc$$1;\n  }\n}\nexport const BigNatModule$$$one = BigNatModule$$$embed(1);\nexport const BigNatModule$$$zero = BigNatModule$$$embed(0);\nexport function BigNatModule$$$restrictTo(d, n$$21) {\n  return new BigNat(BigNatModule$$$minInt(d, n$$21.bound), n$$21.digits);\n}\nexport function BigNatModule$$$shiftUp(d$$1, n$$22) {\n  const m = BigNatModule$$$createN(n$$22.bound + d$$1);\n\n  for (let i$$14 = 0; i$$14 <= n$$22.bound - 1; i$$14++) {\n    m.digits[i$$14 + d$$1] = n$$22.digits[i$$14];\n  }\n\n  return m;\n}\nexport function BigNatModule$$$shiftDown(d$$2, n$$23) {\n  if (n$$23.bound - d$$2 <= 0) {\n    return BigNatModule$$$zero;\n  } else {\n    const m$$1 = BigNatModule$$$createN(n$$23.bound - d$$2);\n\n    for (let i$$15 = 0; i$$15 <= m$$1.bound - 1; i$$15++) {\n      m$$1.digits[i$$15] = n$$23.digits[i$$15 + d$$2];\n    }\n\n    return m$$1;\n  }\n}\nexport function BigNatModule$$$degree(n$$24) {\n  return n$$24.bound - 1;\n}\nexport function BigNatModule$$$addP($i$$16$$75, $n$$25$$76, $c$$77, $p$$78, $q$$79, $r$$5$$80) {\n  BigNatModule$$$addP: while (true) {\n    const i$$16 = $i$$16$$75,\n          n$$25 = $n$$25$$76,\n          c = $c$$77,\n          p = $p$$78,\n          q = $q$$79,\n          r$$5 = $r$$5$$80;\n\n    if (i$$16 < n$$25) {\n      const x$$32 = (i$$16 < p.bound ? p.digits[i$$16] : 0) + (i$$16 < q.bound ? q.digits[i$$16] : 0) + c | 0;\n      r$$5.digits[i$$16] = BigNatModule$$$modbase(x$$32);\n      const c$$1 = BigNatModule$$$divbase(x$$32) | 0;\n      $i$$16$$75 = i$$16 + 1;\n      $n$$25$$76 = n$$25;\n      $c$$77 = c$$1;\n      $p$$78 = p;\n      $q$$79 = q;\n      $r$$5$$80 = r$$5;\n      continue BigNatModule$$$addP;\n    } else {\n      void null;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$$$add(p$$1, q$$1) {\n  const rbound = 1 + BigNatModule$$$maxInt(p$$1.bound, q$$1.bound) | 0;\n  const r$$6 = BigNatModule$$$createN(rbound);\n  BigNatModule$$$addP(0, rbound, 0, p$$1, q$$1, r$$6);\n  return BigNatModule$$$normN(r$$6);\n}\nexport function BigNatModule$$$subP($i$$19$$83, $n$$26$$84, $c$$2$$85, $p$$2$$86, $q$$2$$87, $r$$7$$88) {\n  BigNatModule$$$subP: while (true) {\n    const i$$19 = $i$$19$$83,\n          n$$26 = $n$$26$$84,\n          c$$2 = $c$$2$$85,\n          p$$2 = $p$$2$$86,\n          q$$2 = $q$$2$$87,\n          r$$7 = $r$$7$$88;\n\n    if (i$$19 < n$$26) {\n      const x$$33 = (i$$19 < p$$2.bound ? p$$2.digits[i$$19] : 0) - (i$$19 < q$$2.bound ? q$$2.digits[i$$19] : 0) + c$$2 | 0;\n\n      if (x$$33 > 0) {\n        r$$7.digits[i$$19] = BigNatModule$$$modbase(x$$33);\n        const c$$3 = BigNatModule$$$divbase(x$$33) | 0;\n        $i$$19$$83 = i$$19 + 1;\n        $n$$26$$84 = n$$26;\n        $c$$2$$85 = c$$3;\n        $p$$2$$86 = p$$2;\n        $q$$2$$87 = q$$2;\n        $r$$7$$88 = r$$7;\n        continue BigNatModule$$$subP;\n      } else {\n        const x$$34 = x$$33 + BigNatModule$$$baseN | 0;\n        r$$7.digits[i$$19] = BigNatModule$$$modbase(x$$34);\n        const c$$4 = BigNatModule$$$divbase(x$$34) - 1 | 0;\n        $i$$19$$83 = i$$19 + 1;\n        $n$$26$$84 = n$$26;\n        $c$$2$$85 = c$$4;\n        $p$$2$$86 = p$$2;\n        $q$$2$$87 = q$$2;\n        $r$$7$$88 = r$$7;\n        continue BigNatModule$$$subP;\n      }\n    } else {\n      const underflow = c$$2 !== 0;\n      return underflow;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$$$sub(p$$3, q$$3) {\n  const rbound$$1 = BigNatModule$$$maxInt(p$$3.bound, q$$3.bound) | 0;\n  const r$$8 = BigNatModule$$$createN(rbound$$1);\n  const underflow$$1 = BigNatModule$$$subP(0, rbound$$1, 0, p$$3, q$$3, r$$8);\n\n  if (underflow$$1) {\n    return BigNatModule$$$embed(0);\n  } else {\n    return BigNatModule$$$normN(r$$8);\n  }\n}\nexport function BigNatModule$$$isZero(p$$4) {\n  return p$$4.bound === 0;\n}\nexport function BigNatModule$$$IsZero(p$$5) {\n  return BigNatModule$$$isZero(p$$5);\n}\nexport function BigNatModule$$$isOne(p$$6) {\n  if (p$$6.bound === 1) {\n    return p$$6.digits[0] === 1;\n  } else {\n    return false;\n  }\n}\nexport function BigNatModule$$$equal(p$$7, q$$4) {\n  if (p$$7.bound === q$$4.bound) {\n    const check = function check($pa$$96, $qa$$97, $i$$22$$98) {\n      check: while (true) {\n        const pa = $pa$$96,\n              qa = $qa$$97,\n              i$$22 = $i$$22$$98;\n\n        if (i$$22 === -1) {\n          return true;\n        } else if (pa[i$$22] === qa[i$$22]) {\n          $pa$$96 = pa;\n          $qa$$97 = qa;\n          $i$$22$$98 = i$$22 - 1;\n          continue check;\n        } else {\n          return false;\n        }\n\n        break;\n      }\n    };\n\n    return check(p$$7.digits, q$$4.digits, p$$7.bound - 1);\n  } else {\n    return false;\n  }\n}\nexport function BigNatModule$$$shiftCompare(p$$8, pn, q$$5, qn) {\n  if (p$$8.bound + pn < q$$5.bound + qn) {\n    return -1 | 0;\n  } else if (p$$8.bound + pn > q$$5.bound + pn) {\n    return 1;\n  } else {\n    const check$$1 = function check$$1($pa$$1$$103, $qa$$1$$104, $i$$23$$105) {\n      check$$1: while (true) {\n        const pa$$1 = $pa$$1$$103,\n              qa$$1 = $qa$$1$$104,\n              i$$23 = $i$$23$$105;\n\n        if (i$$23 === -1) {\n          return 0;\n        } else {\n          const pai = (i$$23 < pn ? 0 : pa$$1[i$$23 - pn]) | 0;\n          const qai = (i$$23 < qn ? 0 : qa$$1[i$$23 - qn]) | 0;\n\n          if (pai === qai) {\n            $pa$$1$$103 = pa$$1;\n            $qa$$1$$104 = qa$$1;\n            $i$$23$$105 = i$$23 - 1;\n            continue check$$1;\n          } else if (pai < qai) {\n            return -1 | 0;\n          } else {\n            return 1;\n          }\n        }\n\n        break;\n      }\n    };\n\n    return check$$1(p$$8.digits, q$$5.digits, p$$8.bound + pn - 1) | 0;\n  }\n}\nexport function BigNatModule$$$compare(p$$9, q$$6) {\n  if (p$$9.bound < q$$6.bound) {\n    return -1 | 0;\n  } else if (p$$9.bound > q$$6.bound) {\n    return 1;\n  } else {\n    const check$$2 = function check$$2($pa$$2$$108, $qa$$2$$109, $i$$24$$110) {\n      check$$2: while (true) {\n        const pa$$2 = $pa$$2$$108,\n              qa$$2 = $qa$$2$$109,\n              i$$24 = $i$$24$$110;\n\n        if (i$$24 === -1) {\n          return 0;\n        } else if (pa$$2[i$$24] === qa$$2[i$$24]) {\n          $pa$$2$$108 = pa$$2;\n          $qa$$2$$109 = qa$$2;\n          $i$$24$$110 = i$$24 - 1;\n          continue check$$2;\n        } else if (pa$$2[i$$24] < qa$$2[i$$24]) {\n          return -1 | 0;\n        } else {\n          return 1;\n        }\n\n        break;\n      }\n    };\n\n    return check$$2(p$$9.digits, q$$6.digits, p$$9.bound - 1) | 0;\n  }\n}\nexport function BigNatModule$$$lt(p$$10, q$$7) {\n  return BigNatModule$$$compare(p$$10, q$$7) === -1;\n}\nexport function BigNatModule$$$gt(p$$11, q$$8) {\n  return BigNatModule$$$compare(p$$11, q$$8) === 1;\n}\nexport function BigNatModule$$$lte(p$$12, q$$9) {\n  return BigNatModule$$$compare(p$$12, q$$9) !== 1;\n}\nexport function BigNatModule$$$gte(p$$13, q$$10) {\n  return BigNatModule$$$compare(p$$13, q$$10) !== -1;\n}\nexport function BigNatModule$$$min(a$$2, b$$5) {\n  if (BigNatModule$$$lt(a$$2, b$$5)) {\n    return a$$2;\n  } else {\n    return b$$5;\n  }\n}\nexport function BigNatModule$$$max(a$$3, b$$6) {\n  if (BigNatModule$$$lt(a$$3, b$$6)) {\n    return b$$6;\n  } else {\n    return a$$3;\n  }\n}\nexport function BigNatModule$$$contributeArr($a$$4$$123, $i$$25$$124, $c$$5$$125) {\n  BigNatModule$$$contributeArr: while (true) {\n    const a$$4 = $a$$4$$123,\n          i$$25 = $i$$25$$124,\n          c$$5 = $c$$5$$125;\n    const x$$35 = op_Addition(fromInteger(a$$4[i$$25], false, 2), c$$5);\n    const c$$6 = op_Division(x$$35, BigNatModule$$$baseNi64);\n    let x$$38;\n    const value = op_BitwiseAnd(x$$35, BigNatModule$$$baseMaski64);\n    x$$38 = ~~toInt(value);\n    a$$4[i$$25] = x$$38;\n\n    if (compare(c$$6, fromBits(0, 0, false)) > 0) {\n      $a$$4$$123 = a$$4;\n      $i$$25$$124 = i$$25 + 1;\n      $c$$5$$125 = c$$6;\n      continue BigNatModule$$$contributeArr;\n    } else {\n      void null;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$$$scale(k$$2, p$$14) {\n  const rbound$$2 = p$$14.bound + BigNatModule$$$boundInt | 0;\n  const r$$9 = BigNatModule$$$createN(rbound$$2);\n  const k$$3 = fromInteger(k$$2, false, 2);\n\n  for (let i$$26 = 0; i$$26 <= p$$14.bound - 1; i$$26++) {\n    const kpi = op_Multiply(k$$3, fromInteger(p$$14.digits[i$$26], false, 2));\n    BigNatModule$$$contributeArr(r$$9.digits, i$$26, kpi);\n  }\n\n  return BigNatModule$$$normN(r$$9);\n}\nexport function BigNatModule$$$mulSchoolBookBothSmall(p$$15, q$$11) {\n  var value$$1;\n  const r$$11 = BigNatModule$$$createN(2);\n  const rak = op_Multiply(fromInteger(p$$15, false, 2), fromInteger(q$$11, false, 2));\n  BigNatModule$$$setCoeff(r$$11, 0, (value$$1 = op_BitwiseAnd(rak, BigNatModule$$$baseMaski64), (~~toInt(value$$1))));\n  BigNatModule$$$setCoeff(r$$11, 1, ~~toInt(op_Division(rak, BigNatModule$$$baseNi64)));\n  return BigNatModule$$$normN(r$$11);\n}\nexport function BigNatModule$$$mulSchoolBookCarry($r$$12$$130, $c$$8$$131, $k$$4$$132) {\n  var value$$2;\n\n  BigNatModule$$$mulSchoolBookCarry: while (true) {\n    const r$$12 = $r$$12$$130,\n          c$$8 = $c$$8$$131,\n          k$$4 = $k$$4$$132;\n\n    if (compare(c$$8, fromBits(0, 0, false)) > 0) {\n      const rak$$1 = op_Addition(BigNatModule$$$coeff64(r$$12, k$$4), c$$8);\n      BigNatModule$$$setCoeff(r$$12, k$$4, (value$$2 = op_BitwiseAnd(rak$$1, BigNatModule$$$baseMaski64), (~~toInt(value$$2))));\n      $r$$12$$130 = r$$12;\n      $c$$8$$131 = op_Division(rak$$1, BigNatModule$$$baseNi64);\n      $k$$4$$132 = k$$4 + 1;\n      continue BigNatModule$$$mulSchoolBookCarry;\n    } else {\n      void null;\n    }\n\n    break;\n  }\n}\nexport function BigNatModule$$$mulSchoolBookOneSmall(p$$16, q$$12) {\n  var value$$3;\n  const bp = BigNatModule$$$bound(p$$16) | 0;\n  const rbound$$3 = bp + 1 | 0;\n  const r$$13 = BigNatModule$$$createN(rbound$$3);\n  const q$$13 = fromInteger(q$$12, false, 2);\n  let c$$9 = fromBits(0, 0, false);\n\n  for (let i$$28 = 0; i$$28 <= bp - 1; i$$28++) {\n    const rak$$2 = op_Addition(op_Addition(c$$9, BigNatModule$$$coeff64(r$$13, i$$28)), op_Multiply(BigNatModule$$$coeff64(p$$16, i$$28), q$$13));\n    BigNatModule$$$setCoeff(r$$13, i$$28, (value$$3 = op_BitwiseAnd(rak$$2, BigNatModule$$$baseMaski64), (~~toInt(value$$3))));\n    c$$9 = op_Division(rak$$2, BigNatModule$$$baseNi64);\n  }\n\n  BigNatModule$$$mulSchoolBookCarry(r$$13, c$$9, bp);\n  return BigNatModule$$$normN(r$$13);\n}\nexport function BigNatModule$$$mulSchoolBookNeitherSmall(p$$17, q$$14) {\n  var value$$4;\n  const rbound$$4 = p$$17.bound + q$$14.bound | 0;\n  const r$$14 = BigNatModule$$$createN(rbound$$4);\n\n  for (let i$$29 = 0; i$$29 <= p$$17.bound - 1; i$$29++) {\n    const pai$$1 = fromInteger(p$$17.digits[i$$29], false, 2);\n    let c$$10 = fromBits(0, 0, false);\n    let k$$5 = i$$29 | 0;\n\n    for (let j$$1 = 0; j$$1 <= q$$14.bound - 1; j$$1++) {\n      const qaj = fromInteger(q$$14.digits[j$$1], false, 2);\n      const rak$$3 = op_Addition(op_Addition(fromInteger(r$$14.digits[k$$5], false, 2), c$$10), op_Multiply(pai$$1, qaj));\n      r$$14.digits[k$$5] = (value$$4 = op_BitwiseAnd(rak$$3, BigNatModule$$$baseMaski64), (~~toInt(value$$4)));\n      c$$10 = op_Division(rak$$3, BigNatModule$$$baseNi64);\n      k$$5 = k$$5 + 1;\n    }\n\n    BigNatModule$$$mulSchoolBookCarry(r$$14, c$$10, k$$5);\n  }\n\n  return BigNatModule$$$normN(r$$14);\n}\nexport function BigNatModule$$$mulSchoolBook(p$$18, q$$15) {\n  const pSmall = BigNatModule$$$bound(p$$18) === 1;\n  const qSmall = BigNatModule$$$bound(q$$15) === 1;\n\n  if (pSmall ? qSmall : false) {\n    return BigNatModule$$$mulSchoolBookBothSmall(BigNatModule$$$coeff(p$$18, 0), BigNatModule$$$coeff(q$$15, 0));\n  } else if (pSmall) {\n    return BigNatModule$$$mulSchoolBookOneSmall(q$$15, BigNatModule$$$coeff(p$$18, 0));\n  } else if (qSmall) {\n    return BigNatModule$$$mulSchoolBookOneSmall(p$$18, BigNatModule$$$coeff(q$$15, 0));\n  } else {\n    return BigNatModule$$$mulSchoolBookNeitherSmall(p$$18, q$$15);\n  }\n}\nexport const BigNatModule$002Eencoding = declare(function BigInt_BigNatModule_encoding(bigL, twoToBigL, k, bigK, bigN, split, splits) {\n  this.bigL = bigL | 0;\n  this.twoToBigL = twoToBigL | 0;\n  this.k = k | 0;\n  this.bigK = bigK | 0;\n  this.bigN = bigN | 0;\n  this.split = split | 0;\n  this.splits = splits;\n}, Record);\nexport function BigNatModule$002Eencoding$reflection() {\n  return record_type(\"BigInt.BigNatModule.encoding\", [], BigNatModule$002Eencoding, () => [[\"bigL\", int32_type], [\"twoToBigL\", int32_type], [\"k\", int32_type], [\"bigK\", int32_type], [\"bigN\", int32_type], [\"split\", int32_type], [\"splits\", array_type(int32_type)]]);\n}\nexport function BigNatModule$$$mkEncoding(bigL, k$$6, bigK$$2, bigN) {\n  return new BigNatModule$002Eencoding(bigL, BigNatModule$$$pow32(2, bigL), k$$6, bigK$$2, bigN, ~~(BigNatModule$$$baseBits / bigL), initialize(~~(BigNatModule$$$baseBits / bigL), function (i$$30) {\n    return BigNatModule$$$pow32(2, bigL * i$$30);\n  }, Int32Array));\n}\nexport const BigNatModule$$$table = [BigNatModule$$$mkEncoding(1, 28, 268435456, 268435456), BigNatModule$$$mkEncoding(2, 26, 67108864, 134217728), BigNatModule$$$mkEncoding(3, 24, 16777216, 50331648), BigNatModule$$$mkEncoding(4, 22, 4194304, 16777216), BigNatModule$$$mkEncoding(5, 20, 1048576, 5242880), BigNatModule$$$mkEncoding(6, 18, 262144, 1572864), BigNatModule$$$mkEncoding(7, 16, 65536, 458752), BigNatModule$$$mkEncoding(8, 14, 16384, 131072), BigNatModule$$$mkEncoding(9, 12, 4096, 36864), BigNatModule$$$mkEncoding(10, 10, 1024, 10240), BigNatModule$$$mkEncoding(11, 8, 256, 2816), BigNatModule$$$mkEncoding(12, 6, 64, 768), BigNatModule$$$mkEncoding(13, 4, 16, 208)];\nexport function BigNatModule$$$calculateTableTow(bigL$$1) {\n  const k$$7 = BigNatModule$002EFFT$$$maxBitsInsideFp - 2 * bigL$$1 | 0;\n  const bigK$$3 = BigNatModule$$$pow64(fromBits(2, 0, false), k$$7);\n  const N = op_Multiply(bigK$$3, fromInteger(bigL$$1, false, 2));\n  return [bigL$$1, k$$7, bigK$$3, N];\n}\nexport function BigNatModule$$$encodingGivenResultBits(bitsRes) {\n  const selectFrom = function selectFrom($i$$31$$145) {\n    selectFrom: while (true) {\n      const i$$31 = $i$$31$$145;\n\n      if (i$$31 + 1 < BigNatModule$$$table.length ? bitsRes < BigNatModule$$$table[i$$31 + 1].bigN : false) {\n        $i$$31$$145 = i$$31 + 1;\n        continue selectFrom;\n      } else {\n        return BigNatModule$$$table[i$$31];\n      }\n\n      break;\n    }\n  };\n\n  if (bitsRes >= BigNatModule$$$table[0].bigN) {\n    throw new Error(\"Product is huge, around 268435456 bits, beyond quickmul\");\n  } else {\n    return selectFrom(0);\n  }\n}\nexport const BigNatModule$$$bitmask = initialize(BigNatModule$$$baseBits, function (i$$32) {\n  return BigNatModule$$$pow32(2, i$$32) - 1;\n}, Int32Array);\nexport const BigNatModule$$$twopowers = initialize(BigNatModule$$$baseBits, function (i$$33) {\n  return BigNatModule$$$pow32(2, i$$33);\n}, Int32Array);\nexport const BigNatModule$$$twopowersI64 = initialize(BigNatModule$$$baseBits, function (i$$34) {\n  return BigNatModule$$$pow64(fromBits(2, 0, false), i$$34);\n}, Array);\nexport function BigNatModule$$$wordBits(word) {\n  const hi = function hi($k$$8$$147) {\n    hi: while (true) {\n      const k$$8 = $k$$8$$147;\n\n      if (k$$8 === 0) {\n        return 0;\n      } else if ((word & BigNatModule$$$twopowers[k$$8 - 1]) !== 0) {\n        return k$$8 | 0;\n      } else {\n        $k$$8$$147 = k$$8 - 1;\n        continue hi;\n      }\n\n      break;\n    }\n  };\n\n  return hi(BigNatModule$$$baseBits) | 0;\n}\nexport function BigNatModule$$$bits(u$$6) {\n  if (u$$6.bound === 0) {\n    return 0;\n  } else {\n    return BigNatModule$$$degree(u$$6) * BigNatModule$$$baseBits + BigNatModule$$$wordBits(u$$6.digits[BigNatModule$$$degree(u$$6)]) | 0;\n  }\n}\nexport function BigNatModule$$$extractBits(n$$27, enc, bi) {\n  const bj = bi + enc.bigL - 1 | 0;\n  const biw = ~~(bi / BigNatModule$$$baseBits) | 0;\n  const bjw = ~~(bj / BigNatModule$$$baseBits) | 0;\n\n  if (biw !== bjw) {\n    const x$$47 = (biw < n$$27.bound ? n$$27.digits[biw] : 0) | 0;\n    const y$$17 = (bjw < n$$27.bound ? n$$27.digits[bjw] : 0) | 0;\n    const xbit = bi % BigNatModule$$$baseBits | 0;\n    const nxbits = BigNatModule$$$baseBits - xbit | 0;\n    const x$$48 = x$$47 >> xbit | 0;\n    const y$$18 = y$$17 << nxbits | 0;\n    const x$$49 = x$$48 | y$$18 | 0;\n    const x$$50 = x$$49 & BigNatModule$$$bitmask[enc.bigL] | 0;\n    return x$$50 | 0;\n  } else {\n    const x$$51 = (biw < n$$27.bound ? n$$27.digits[biw] : 0) | 0;\n    const xbit$$1 = bi % BigNatModule$$$baseBits | 0;\n    const x$$52 = x$$51 >> xbit$$1 | 0;\n    const x$$53 = x$$52 & BigNatModule$$$bitmask[enc.bigL] | 0;\n    return x$$53 | 0;\n  }\n}\nexport function BigNatModule$$$encodePoly(enc$$1, n$$28) {\n  const poly = fill(new Uint32Array(enc$$1.bigK), 0, enc$$1.bigK, BigNatModule$002EFFT$002EFp$$$ofInt32(0));\n  const biMax = n$$28.bound * BigNatModule$$$baseBits | 0;\n\n  const encoder = function encoder($i$$38$$154, $bi$$1$$155) {\n    encoder: while (true) {\n      const i$$38 = $i$$38$$154,\n            bi$$1 = $bi$$1$$155;\n\n      if (i$$38 === enc$$1.bigK ? true : bi$$1 > biMax) {\n        void null;\n      } else {\n        const pi = BigNatModule$$$extractBits(n$$28, enc$$1, bi$$1) | 0;\n        poly[i$$38] = BigNatModule$002EFFT$002EFp$$$ofInt32(pi);\n        const i$$39 = i$$38 + 1 | 0;\n        const bi$$2 = bi$$1 + enc$$1.bigL | 0;\n        $i$$38$$154 = i$$39;\n        $bi$$1$$155 = bi$$2;\n        continue encoder;\n      }\n\n      break;\n    }\n  };\n\n  encoder(0, 0);\n  return poly;\n}\nexport function BigNatModule$$$decodeResultBits(enc$$2, poly$$1) {\n  let n$$29 = 0;\n\n  for (let i$$40 = 0; i$$40 <= poly$$1.length - 1; i$$40++) {\n    if (poly$$1[i$$40] !== BigNatModule$002EFFT$$$mzero) {\n      n$$29 = i$$40;\n    } else {\n      void null;\n    }\n  }\n\n  const rbits = BigNatModule$002EFFT$$$maxBitsInsideFp + enc$$2.bigL * n$$29 + 1 | 0;\n  return rbits + 1 | 0;\n}\nexport function BigNatModule$$$decodePoly(enc$$3, poly$$2) {\n  const rbound$$5 = ~~(BigNatModule$$$decodeResultBits(enc$$3, poly$$2) / BigNatModule$$$baseBits) + 1 | 0;\n  const r$$15 = BigNatModule$$$createN(rbound$$5);\n\n  const evaluate = function evaluate($i$$41$$160, $j$$2$$161, $d$$3$$162) {\n    evaluate: while (true) {\n      const i$$41 = $i$$41$$160,\n            j$$2 = $j$$2$$161,\n            d$$3 = $d$$3$$162;\n\n      if (i$$41 === enc$$3.bigK) {\n        void null;\n      } else {\n        if (j$$2 >= rbound$$5) {\n          void null;\n        } else {\n          const x$$54 = op_Multiply(fromInteger(BigNatModule$002EFFT$002EFp$$$toInt(poly$$2[i$$41]), false, 2), BigNatModule$$$twopowersI64[d$$3]);\n          BigNatModule$$$contributeArr(r$$15.digits, j$$2, x$$54);\n        }\n\n        const i$$43 = i$$41 + 1 | 0;\n        const d$$4 = d$$3 + enc$$3.bigL | 0;\n        const patternInput$$1 = d$$4 >= BigNatModule$$$baseBits ? [j$$2 + 1, d$$4 - BigNatModule$$$baseBits] : [j$$2, d$$4];\n        $i$$41$$160 = i$$43;\n        $j$$2$$161 = patternInput$$1[0];\n        $d$$3$$162 = patternInput$$1[1];\n        continue evaluate;\n      }\n\n      break;\n    }\n  };\n\n  evaluate(0, 0, 0);\n  return BigNatModule$$$normN(r$$15);\n}\nexport function BigNatModule$$$quickMulUsingFft(u$$7, v$$5) {\n  const bitsRes$$1 = BigNatModule$$$bits(u$$7) + BigNatModule$$$bits(v$$5) | 0;\n  const enc$$4 = BigNatModule$$$encodingGivenResultBits(bitsRes$$1);\n  const upoly = BigNatModule$$$encodePoly(enc$$4, u$$7);\n  const vpoly = BigNatModule$$$encodePoly(enc$$4, v$$5);\n  const rpoly = BigNatModule$002EFFT$$$computeFftPaddedPolynomialProduct(enc$$4.bigK, enc$$4.k, upoly, vpoly);\n  const r$$17 = BigNatModule$$$decodePoly(enc$$4, rpoly);\n  return BigNatModule$$$normN(r$$17);\n}\nexport const BigNatModule$$$minDigitsKaratsuba = 16;\nexport function BigNatModule$$$recMulKaratsuba(mul, p$$19, q$$16) {\n  const bp$$1 = p$$19.bound | 0;\n  const bq = q$$16.bound | 0;\n  const bmax = BigNatModule$$$maxInt(bp$$1, bq) | 0;\n\n  if (bmax > BigNatModule$$$minDigitsKaratsuba) {\n    const k$$9 = ~~(bmax / 2) | 0;\n    const a0 = BigNatModule$$$restrictTo(k$$9, p$$19);\n    const a1 = BigNatModule$$$shiftDown(k$$9, p$$19);\n    const b0 = BigNatModule$$$restrictTo(k$$9, q$$16);\n    const b1 = BigNatModule$$$shiftDown(k$$9, q$$16);\n    const q0 = mul(a0, b0);\n    const q1 = mul(BigNatModule$$$add(a0, a1), BigNatModule$$$add(b0, b1));\n    const q2 = mul(a1, b1);\n    const p1 = BigNatModule$$$sub(q1, BigNatModule$$$add(q0, q2));\n    const r$$18 = BigNatModule$$$add(q0, BigNatModule$$$shiftUp(k$$9, BigNatModule$$$add(p1, BigNatModule$$$shiftUp(k$$9, q2))));\n    return r$$18;\n  } else {\n    return BigNatModule$$$mulSchoolBook(p$$19, q$$16);\n  }\n}\nexport function BigNatModule$$$mulKaratsuba(x$$55, y$$19) {\n  return BigNatModule$$$recMulKaratsuba(BigNatModule$$$mulKaratsuba, x$$55, y$$19);\n}\nexport const BigNatModule$$$productDigitsUpperSchoolBook = ~~(64000 / BigNatModule$$$baseBits);\nexport const BigNatModule$$$singleDigitForceSchoolBook = ~~(32000 / BigNatModule$$$baseBits);\nexport const BigNatModule$$$productDigitsUpperFft = ~~(BigNatModule$$$table[0].bigN / BigNatModule$$$baseBits);\nexport function BigNatModule$$$mul(p$$20, q$$17) {\n  return BigNatModule$$$mulSchoolBook(p$$20, q$$17);\n}\nexport function BigNatModule$$$scaleSubInPlace(x$$57, f, a$$5, n$$30) {\n  const patternInput$$2 = [x$$57.digits, BigNatModule$$$degree(x$$57)];\n  const patternInput$$3 = [a$$5.digits, BigNatModule$$$degree(a$$5)];\n  const f$$1 = fromInteger(f, false, 2);\n  let j$$4 = 0;\n  let z$$7 = op_Multiply(f$$1, fromInteger(patternInput$$3[0][0], false, 2));\n\n  while (compare(z$$7, fromBits(0, 0, false)) > 0 ? true : j$$4 < patternInput$$3[1]) {\n    if (j$$4 > patternInput$$2[1]) {\n      throw new Error(\"scaleSubInPlace: pre-condition did not apply, result would be -ve\");\n    } else {\n      void null;\n    }\n\n    let zLo;\n    let value$$6;\n    const x$$59 = z$$7;\n    const value$$5 = op_BitwiseAnd(x$$59, BigNatModule$$$baseMaski64);\n    value$$6 = ~~toInt(value$$5);\n    zLo = value$$6;\n    let zHi;\n    const x$$60 = z$$7;\n    zHi = op_Division(x$$60, BigNatModule$$$baseNi64);\n\n    if (zLo <= patternInput$$2[0][j$$4 + n$$30]) {\n      patternInput$$2[0][j$$4 + n$$30] = patternInput$$2[0][j$$4 + n$$30] - zLo;\n    } else {\n      patternInput$$2[0][j$$4 + n$$30] = patternInput$$2[0][j$$4 + n$$30] + (BigNatModule$$$baseN - zLo);\n      zHi = op_Addition(zHi, fromBits(1, 0, false));\n    }\n\n    if (j$$4 < patternInput$$3[1]) {\n      z$$7 = op_Addition(zHi, op_Multiply(f$$1, fromInteger(patternInput$$3[0][j$$4 + 1], false, 2)));\n    } else {\n      z$$7 = zHi;\n    }\n\n    j$$4 = j$$4 + 1;\n  }\n\n  void BigNatModule$$$normN(x$$57);\n}\nexport function BigNatModule$$$scaleSub(x$$61, f$$2, a$$7, n$$31) {\n  const freshx = BigNatModule$$$add(x$$61, BigNatModule$$$zero);\n  BigNatModule$$$scaleSubInPlace(freshx, f$$2, a$$7, n$$31);\n  return BigNatModule$$$normN(freshx);\n}\nexport function BigNatModule$$$scaleAddInPlace(x$$62, f$$3, a$$8, n$$32) {\n  const patternInput$$4 = [x$$62.digits, BigNatModule$$$degree(x$$62)];\n  const patternInput$$5 = [a$$8.digits, BigNatModule$$$degree(a$$8)];\n  const f$$4 = fromInteger(f$$3, false, 2);\n  let j$$5 = 0;\n  let z$$8 = op_Multiply(f$$4, fromInteger(patternInput$$5[0][0], false, 2));\n\n  while (compare(z$$8, fromBits(0, 0, false)) > 0 ? true : j$$5 < patternInput$$5[1]) {\n    if (j$$5 > patternInput$$4[1]) {\n      throw new Error(\"scaleSubInPlace: pre-condition did not apply, result would be -ve\");\n    } else {\n      void null;\n    }\n\n    let zLo$$1;\n    let value$$8;\n    const x$$64 = z$$8;\n    const value$$7 = op_BitwiseAnd(x$$64, BigNatModule$$$baseMaski64);\n    value$$8 = ~~toInt(value$$7);\n    zLo$$1 = value$$8;\n    let zHi$$1;\n    const x$$65 = z$$8;\n    zHi$$1 = op_Division(x$$65, BigNatModule$$$baseNi64);\n\n    if (zLo$$1 < BigNatModule$$$baseN - patternInput$$4[0][j$$5 + n$$32]) {\n      patternInput$$4[0][j$$5 + n$$32] = patternInput$$4[0][j$$5 + n$$32] + zLo$$1;\n    } else {\n      patternInput$$4[0][j$$5 + n$$32] = zLo$$1 - (BigNatModule$$$baseN - patternInput$$4[0][j$$5 + n$$32]);\n      zHi$$1 = op_Addition(zHi$$1, fromBits(1, 0, false));\n    }\n\n    if (j$$5 < patternInput$$5[1]) {\n      z$$8 = op_Addition(zHi$$1, op_Multiply(f$$4, fromInteger(patternInput$$5[0][j$$5 + 1], false, 2)));\n    } else {\n      z$$8 = zHi$$1;\n    }\n\n    j$$5 = j$$5 + 1;\n  }\n\n  void BigNatModule$$$normN(x$$62);\n}\nexport function BigNatModule$$$scaleAdd(x$$66, f$$5, a$$10, n$$33) {\n  const freshx$$1 = BigNatModule$$$add(x$$66, BigNatModule$$$zero);\n  BigNatModule$$$scaleAddInPlace(freshx$$1, f$$5, a$$10, n$$33);\n  return BigNatModule$$$normN(freshx$$1);\n}\nexport function BigNatModule$$$removeFactor(x$$67, a$$11, n$$34) {\n  const patternInput$$6 = [BigNatModule$$$degree(a$$11), BigNatModule$$$degree(x$$67)];\n\n  if (patternInput$$6[1] < patternInput$$6[0] + n$$34) {\n    return 0;\n  } else {\n    let f$$6;\n\n    if (patternInput$$6[0] === 0) {\n      if (patternInput$$6[1] === n$$34) {\n        f$$6 = ~~(x$$67.digits[n$$34] / a$$11.digits[0]);\n      } else {\n        const f64 = op_Division(op_Addition(op_Multiply(fromInteger(x$$67.digits[patternInput$$6[1]], false, 2), BigNatModule$$$baseNi64), fromInteger(x$$67.digits[patternInput$$6[1] - 1], false, 2)), fromInteger(a$$11.digits[0], false, 2));\n        f$$6 = ~~toInt(f64);\n      }\n    } else if (patternInput$$6[1] === patternInput$$6[0] + n$$34) {\n      f$$6 = ~~(x$$67.digits[patternInput$$6[1]] / (a$$11.digits[patternInput$$6[0]] + 1));\n    } else {\n      const f64$$1 = op_Division(op_Addition(op_Multiply(fromInteger(x$$67.digits[patternInput$$6[1]], false, 2), BigNatModule$$$baseNi64), fromInteger(x$$67.digits[patternInput$$6[1] - 1], false, 2)), op_Addition(fromInteger(a$$11.digits[patternInput$$6[0]], false, 2), fromBits(1, 0, false)));\n      f$$6 = ~~toInt(f64$$1);\n    }\n\n    if (f$$6 === 0) {\n      const lte = BigNatModule$$$shiftCompare(a$$11, n$$34, x$$67, 0) !== 1;\n\n      if (lte) {\n        return 1;\n      } else {\n        return 0;\n      }\n    } else {\n      return f$$6 | 0;\n    }\n  }\n}\nexport function BigNatModule$$$divmod(b$$7, a$$12) {\n  if (BigNatModule$$$isZero(a$$12)) {\n    throw new Error();\n  } else if (BigNatModule$$$degree(b$$7) < BigNatModule$$$degree(a$$12)) {\n    return [BigNatModule$$$zero, b$$7];\n  } else {\n    const x$$68 = BigNatModule$$$copyN(b$$7);\n    const d$$6 = BigNatModule$$$createN(BigNatModule$$$degree(b$$7) - BigNatModule$$$degree(a$$12) + 1 + 1);\n    let p$$21 = BigNatModule$$$degree(b$$7) | 0;\n    const m$$2 = BigNatModule$$$degree(a$$12) | 0;\n    let n$$35 = p$$21 - m$$2 | 0;\n\n    const Invariant = function Invariant(tupledArg) {\n      void null;\n    };\n\n    let finished = false;\n\n    while (!finished) {\n      Invariant([d$$6, x$$68, n$$35, p$$21]);\n      const f$$7 = BigNatModule$$$removeFactor(x$$68, a$$12, n$$35) | 0;\n\n      if (f$$7 > 0) {\n        BigNatModule$$$scaleSubInPlace(x$$68, f$$7, a$$12, n$$35);\n        BigNatModule$$$scaleAddInPlace(d$$6, f$$7, BigNatModule$$$one, n$$35);\n        Invariant([d$$6, x$$68, n$$35, p$$21]);\n      } else {\n        finished = f$$7 === 0 ? n$$35 === 0 : false;\n\n        if (!finished) {\n          if (p$$21 === m$$2 + n$$35) {\n            Invariant([d$$6, x$$68, n$$35 - 1, p$$21]);\n            n$$35 = n$$35 - 1;\n          } else {\n            Invariant([d$$6, x$$68, n$$35 - 1, p$$21 - 1]);\n            n$$35 = n$$35 - 1;\n            p$$21 = p$$21 - 1;\n          }\n        } else {\n          void null;\n        }\n      }\n    }\n\n    return [BigNatModule$$$normN(d$$6), BigNatModule$$$normN(x$$68)];\n  }\n}\nexport function BigNatModule$$$div(b$$8, a$$13) {\n  return BigNatModule$$$divmod(b$$8, a$$13)[0];\n}\nexport function BigNatModule$$$rem(b$$9, a$$14) {\n  return BigNatModule$$$divmod(b$$9, a$$14)[1];\n}\nexport function BigNatModule$$$bitAnd(a$$15, b$$10) {\n  const rbound$$6 = BigNatModule$$$minInt(a$$15.bound, b$$10.bound) | 0;\n  const r$$19 = BigNatModule$$$createN(rbound$$6);\n\n  for (let i$$44 = 0; i$$44 <= r$$19.bound - 1; i$$44++) {\n    r$$19.digits[i$$44] = a$$15.digits[i$$44] & b$$10.digits[i$$44];\n  }\n\n  return BigNatModule$$$normN(r$$19);\n}\nexport function BigNatModule$$$bitOr(a$$16, b$$11) {\n  const rbound$$7 = BigNatModule$$$maxInt(a$$16.bound, b$$11.bound) | 0;\n  const r$$20 = BigNatModule$$$createN(rbound$$7);\n\n  for (let i$$45 = 0; i$$45 <= a$$16.bound - 1; i$$45++) {\n    r$$20.digits[i$$45] = r$$20.digits[i$$45] | a$$16.digits[i$$45];\n  }\n\n  for (let i$$46 = 0; i$$46 <= b$$11.bound - 1; i$$46++) {\n    r$$20.digits[i$$46] = r$$20.digits[i$$46] | b$$11.digits[i$$46];\n  }\n\n  return BigNatModule$$$normN(r$$20);\n}\nexport function BigNatModule$$$bitXor(a$$17, b$$12) {\n  const rbound$$8 = BigNatModule$$$maxInt(a$$17.bound, b$$12.bound) | 0;\n  const r$$21 = BigNatModule$$$createN(rbound$$8);\n\n  for (let i$$47 = 0; i$$47 <= a$$17.bound - 1; i$$47++) {\n    r$$21.digits[i$$47] = r$$21.digits[i$$47] ^ a$$17.digits[i$$47];\n  }\n\n  for (let i$$48 = 0; i$$48 <= b$$12.bound - 1; i$$48++) {\n    r$$21.digits[i$$48] = r$$21.digits[i$$48] ^ b$$12.digits[i$$48];\n  }\n\n  return BigNatModule$$$normN(r$$21);\n}\nexport function BigNatModule$$$hcf(a$$18, b$$13) {\n  const hcfloop = function hcfloop($a$$19$$206, $b$$14$$207) {\n    hcfloop: while (true) {\n      const a$$19 = $a$$19$$206,\n            b$$14 = $b$$14$$207;\n\n      if (BigNatModule$$$equal(BigNatModule$$$zero, a$$19)) {\n        return b$$14;\n      } else {\n        const patternInput$$8 = BigNatModule$$$divmod(b$$14, a$$19);\n        $a$$19$$206 = patternInput$$8[1];\n        $b$$14$$207 = a$$19;\n        continue hcfloop;\n      }\n\n      break;\n    }\n  };\n\n  if (BigNatModule$$$lt(a$$18, b$$13)) {\n    return hcfloop(a$$18, b$$13);\n  } else {\n    return hcfloop(b$$13, a$$18);\n  }\n}\nexport const BigNatModule$$$two = BigNatModule$$$embed(2);\nexport function BigNatModule$$$powi(x$$69, n$$36) {\n  const power = function power($acc$$2$$210, $x$$70$$211, $n$$37$$212) {\n    power: while (true) {\n      const acc$$2 = $acc$$2$$210,\n            x$$70 = $x$$70$$211,\n            n$$37 = $n$$37$$212;\n\n      if (n$$37 === 0) {\n        return acc$$2;\n      } else if (n$$37 % 2 === 0) {\n        $acc$$2$$210 = acc$$2;\n        $x$$70$$211 = BigNatModule$$$mul(x$$70, x$$70);\n        $n$$37$$212 = ~~(n$$37 / 2);\n        continue power;\n      } else {\n        $acc$$2$$210 = BigNatModule$$$mul(x$$70, acc$$2);\n        $x$$70$$211 = BigNatModule$$$mul(x$$70, x$$70);\n        $n$$37$$212 = ~~(n$$37 / 2);\n        continue power;\n      }\n\n      break;\n    }\n  };\n\n  return power(BigNatModule$$$one, x$$69, n$$36);\n}\nexport function BigNatModule$$$pow(x$$71, n$$38) {\n  const power$$1 = function power$$1($acc$$3$$215, $x$$72$$216, $n$$39$$217) {\n    power$$1: while (true) {\n      const acc$$3 = $acc$$3$$215,\n            x$$72 = $x$$72$$216,\n            n$$39 = $n$$39$$217;\n\n      if (BigNatModule$$$isZero(n$$39)) {\n        return acc$$3;\n      } else {\n        const patternInput$$9 = BigNatModule$$$divmod(n$$39, BigNatModule$$$two);\n\n        if (BigNatModule$$$isZero(patternInput$$9[1])) {\n          $acc$$3$$215 = acc$$3;\n          $x$$72$$216 = BigNatModule$$$mul(x$$72, x$$72);\n          $n$$39$$217 = patternInput$$9[0];\n          continue power$$1;\n        } else {\n          $acc$$3$$215 = BigNatModule$$$mul(x$$72, acc$$3);\n          $x$$72$$216 = BigNatModule$$$mul(x$$72, x$$72);\n          $n$$39$$217 = patternInput$$9[0];\n          continue power$$1;\n        }\n      }\n\n      break;\n    }\n  };\n\n  return power$$1(BigNatModule$$$one, x$$71, n$$38);\n}\nexport function BigNatModule$$$toFloat(n$$40) {\n  const basef = BigNatModule$$$baseN;\n\n  const evalFloat = function evalFloat($acc$$4$$219, $k$$10$$220, $i$$49$$221) {\n    evalFloat: while (true) {\n      const acc$$4 = $acc$$4$$219,\n            k$$10 = $k$$10$$220,\n            i$$49 = $i$$49$$221;\n\n      if (i$$49 === n$$40.bound) {\n        return acc$$4;\n      } else {\n        $acc$$4$$219 = acc$$4 + k$$10 * n$$40.digits[i$$49];\n        $k$$10$$220 = k$$10 * basef;\n        $i$$49$$221 = i$$49 + 1;\n        continue evalFloat;\n      }\n\n      break;\n    }\n  };\n\n  return evalFloat(0, 1, 0);\n}\nexport function BigNatModule$$$ofInt32(n$$41) {\n  return BigNatModule$$$embed(n$$41);\n}\nexport function BigNatModule$$$ofInt64(n$$42) {\n  return BigNatModule$$$embed64(n$$42);\n}\nexport function BigNatModule$$$toUInt32(n$$43) {\n  const matchValue = n$$43.bound | 0;\n\n  switch (matchValue) {\n    case 0:\n      {\n        return 0;\n      }\n\n    case 1:\n      {\n        const value$$9 = n$$43.digits[0] | 0;\n        return value$$9 >>> 0;\n      }\n\n    case 2:\n      {\n        const patternInput$$10 = [n$$43.digits[0], n$$43.digits[1]];\n\n        if (patternInput$$10[1] > BigNatModule$$$baseMask32B) {\n          throw new Error();\n        } else {\n          void null;\n        }\n\n        return ((patternInput$$10[0] & BigNatModule$$$baseMask32A) >>> 0) + ((patternInput$$10[1] & BigNatModule$$$baseMask32B) >>> 0 << BigNatModule$$$baseShift32B >>> 0);\n      }\n\n    default:\n      {\n        throw new Error();\n      }\n  }\n}\nexport function BigNatModule$$$toUInt64(n$$44) {\n  const matchValue$$1 = n$$44.bound | 0;\n\n  switch (matchValue$$1) {\n    case 0:\n      {\n        return fromBits(0, 0, true);\n      }\n\n    case 1:\n      {\n        const value$$10 = n$$44.digits[0] | 0;\n        return fromInteger(value$$10, true, 2);\n      }\n\n    case 2:\n      {\n        const patternInput$$11 = [n$$44.digits[0], n$$44.digits[1]];\n        return op_Addition(fromInteger(patternInput$$11[0] & BigNatModule$$$baseMask64A, true, 2), op_LeftShift(fromInteger(patternInput$$11[1] & BigNatModule$$$baseMask64B, true, 2), BigNatModule$$$baseShift64B));\n      }\n\n    case 3:\n      {\n        const patternInput$$12 = [n$$44.digits[0], n$$44.digits[1], n$$44.digits[2]];\n\n        if (patternInput$$12[2] > BigNatModule$$$baseMask64C) {\n          throw new Error();\n        } else {\n          void null;\n        }\n\n        return op_Addition(op_Addition(fromInteger(patternInput$$12[0] & BigNatModule$$$baseMask64A, true, 2), op_LeftShift(fromInteger(patternInput$$12[1] & BigNatModule$$$baseMask64B, true, 2), BigNatModule$$$baseShift64B)), op_LeftShift(fromInteger(patternInput$$12[2] & BigNatModule$$$baseMask64C, true, 2), BigNatModule$$$baseShift64C));\n      }\n\n    default:\n      {\n        throw new Error();\n      }\n  }\n}\nexport function BigNatModule$$$toString(n$$45) {\n  const degn = BigNatModule$$$degree(n$$45) | 0;\n\n  const route = function route($prior$$227, $k$$11$$228, $ten2k$$229) {\n    route: while (true) {\n      const prior = $prior$$227,\n            k$$11 = $k$$11$$228,\n            ten2k = $ten2k$$229;\n\n      if (BigNatModule$$$degree(ten2k) > degn) {\n        return new List([k$$11, ten2k], prior);\n      } else {\n        $prior$$227 = new List([k$$11, ten2k], prior);\n        $k$$11$$228 = k$$11 + 1;\n        $ten2k$$229 = BigNatModule$$$mul(ten2k, ten2k);\n        continue route;\n      }\n\n      break;\n    }\n  };\n\n  const kten2ks = route(new List(), 0, BigNatModule$$$embed(10));\n\n  const collect = function collect(isLeading, digits, n$$46, _arg1$$1) {\n    if (_arg1$$1.tail != null) {\n      const patternInput$$13 = BigNatModule$$$divmod(n$$46, _arg1$$1.head[1]);\n\n      if (isLeading ? BigNatModule$$$isZero(patternInput$$13[0]) : false) {\n        const digits$$1 = collect(isLeading, digits, patternInput$$13[1], _arg1$$1.tail);\n        return digits$$1;\n      } else {\n        const digits$$2 = collect(false, digits, patternInput$$13[1], _arg1$$1.tail);\n        const digits$$3 = collect(isLeading, digits$$2, patternInput$$13[0], _arg1$$1.tail);\n        return digits$$3;\n      }\n    } else {\n      const n$$47 = BigNatModule$$$eval32(n$$46) | 0;\n\n      if (isLeading ? n$$47 === 0 : false) {\n        return digits;\n      } else {\n        return new List(int32ToString(n$$47), digits);\n      }\n    }\n  };\n\n  const digits$$4 = collect(true, new List(), n$$45, kten2ks);\n\n  if (digits$$4.tail == null) {\n    return \"0\";\n  } else {\n    let arg00;\n    arg00 = ofList(digits$$4, Array);\n    return join(\"\", arg00);\n  }\n}\nexport function BigNatModule$$$ofString(str) {\n  const len = str.length | 0;\n\n  if (isNullOrEmpty(str)) {\n    throw new Error(\"empty string\\\\nParameter name: str\");\n  } else {\n    void null;\n  }\n\n  const ten = BigNatModule$$$embed(10);\n\n  const build = function build($acc$$5$$235, $i$$50$$236) {\n    build: while (true) {\n      const acc$$5 = $acc$$5$$235,\n            i$$50 = $i$$50$$236;\n\n      if (i$$50 === len) {\n        return acc$$5;\n      } else {\n        const c$$12 = str[i$$50];\n        const d$$7 = c$$12.charCodeAt(0) - \"0\".charCodeAt(0) | 0;\n\n        if (0 <= d$$7 ? d$$7 <= 9 : false) {\n          $acc$$5$$235 = BigNatModule$$$add(BigNatModule$$$mul(ten, acc$$5), BigNatModule$$$embed(d$$7));\n          $i$$50$$236 = i$$50 + 1;\n          continue build;\n        } else {\n          throw new Error();\n        }\n      }\n\n      break;\n    }\n  };\n\n  return build(BigNatModule$$$embed(0), 0);\n}\nexport function BigNatModule$$$isSmall(n$$48) {\n  return n$$48.bound <= 1;\n}\nexport function BigNatModule$$$getSmall(n$$49) {\n  if (0 < n$$49.bound) {\n    return n$$49.digits[0] | 0;\n  } else {\n    return 0;\n  }\n}\nexport function BigNatModule$$$factorial(n$$50) {\n  const productR = function productR(a$$20, b$$15) {\n    if (BigNatModule$$$equal(a$$20, b$$15)) {\n      return a$$20;\n    } else {\n      const m$$3 = BigNatModule$$$div(BigNatModule$$$add(a$$20, b$$15), BigNatModule$$$ofInt32(2));\n      return BigNatModule$$$mul(productR(a$$20, m$$3), productR(BigNatModule$$$add(m$$3, BigNatModule$$$one), b$$15));\n    }\n  };\n\n  return productR(BigNatModule$$$one, n$$50);\n}","import { declare, Record } from \"../Types.js\";\nimport { class_type } from \"../Reflection.js\";\nimport { BigNatModule$$$factorial as BigNatModule$0024$0024$0024factorial, BigNatModule$$$ofString as BigNatModule$0024$0024$0024ofString, BigNatModule$$$toFloat as BigNatModule$0024$0024$0024toFloat, BigNatModule$$$toUInt64 as BigNatModule$0024$0024$0024toUInt64, BigNatModule$$$toUInt32 as BigNatModule$0024$0024$0024toUInt32, BigNatModule$$$pow as BigNatModule$0024$0024$0024pow, BigNatModule$$$rem as BigNatModule$0024$0024$0024rem, BigNatModule$$$two as BigNatModule$0024$0024$0024two, BigNatModule$$$lte as BigNatModule$0024$0024$0024lte, BigNatModule$$$hcf as BigNatModule$0024$0024$0024hcf, BigNatModule$$$bitXor as BigNatModule$0024$0024$0024bitXor, BigNatModule$$$bitOr as BigNatModule$0024$0024$0024bitOr, BigNatModule$$$bitAnd as BigNatModule$0024$0024$0024bitAnd, BigNatModule$$$divmod as BigNatModule$0024$0024$0024divmod, BigNatModule$$$mul as BigNatModule$0024$0024$0024mul, BigNatModule$$$isOne as BigNatModule$0024$0024$0024isOne, BigNatModule$$$sub as BigNatModule$0024$0024$0024sub, BigNatModule$$$gte as BigNatModule$0024$0024$0024gte, BigNatModule$$$scale as BigNatModule$0024$0024$0024scale, BigNatModule$$$add as BigNatModule$0024$0024$0024add, BigNatModule$$$one as BigNatModule$0024$0024$0024one, BigNatModule$$$ofInt64 as BigNatModule$0024$0024$0024ofInt64, BigNatModule$$$toString as BigNatModule$0024$0024$0024toString, BigNatModule$$$hash as BigNatModule$0024$0024$0024hash, BigNatModule$$$gt as BigNatModule$0024$0024$0024gt, BigNatModule$$$lt as BigNatModule$0024$0024$0024lt, BigNatModule$$$isZero as BigNatModule$0024$0024$0024isZero, BigNatModule$$$equal as BigNatModule$0024$0024$0024equal, BigNatModule$$$getSmall as BigNatModule$0024$0024$0024getSmall, BigNatModule$$$isSmall as BigNatModule$0024$0024$0024isSmall, BigNatModule$$$ofInt32 as BigNatModule$0024$0024$0024ofInt32 } from \"./n\";\nimport { initialize } from \"../Array.js\";\nimport { op_Addition, op_Multiply, fromValue, equals, compare, fromBits, op_UnaryNegation, fromInteger } from \"../Long.js\";\nimport { op_UnaryNegation_Int32 } from \"../Int32.js\";\nimport Decimal from \"../Decimal.js\";\nexport const BigInteger = declare(function BigInt_BigInteger(signInt, v) {\n  const $this$$1 = this;\n  void null;\n  $this$$1.signInt = signInt;\n  $this$$1.v = v;\n  void null;\n}, Record);\nexport function BigInteger$reflection() {\n  return class_type(\"BigInt.BigInteger\", undefined, BigInteger);\n}\nexport function BigInteger$$$$002Ector$$Z2BE94A1(signInt, v) {\n  return this instanceof BigInteger ? BigInteger.call(this, signInt, v) : new BigInteger(signInt, v);\n}\n\n(function BigInteger$$$$002Ecctor() {\n  BigInteger.smallLim = 4096;\n  BigInteger.smallPosTab = initialize(BigInteger.smallLim, BigNatModule$0024$0024$0024ofInt32, Array);\n  BigInteger.one = BigInteger$$$$002Ector$$Z524259A4(1);\n  BigInteger.two = BigInteger$$$$002Ector$$Z524259A4(2);\n  BigInteger.zero = BigInteger$$$$002Ector$$Z524259A4(0);\n  void null;\n})();\n\nexport function BigInteger$$$nat$$Z67CCE57D(n$$1) {\n  if (BigNatModule$0024$0024$0024isSmall(n$$1) ? BigNatModule$0024$0024$0024getSmall(n$$1) < BigInteger.smallLim : false) {\n    return BigInteger.smallPosTab[BigNatModule$0024$0024$0024getSmall(n$$1)];\n  } else {\n    return n$$1;\n  }\n}\nexport function BigInteger$$$create$$Z2BE94A1(s, n$$2) {\n  return BigInteger$$$$002Ector$$Z2BE94A1(s, BigInteger$$$nat$$Z67CCE57D(n$$2));\n}\nexport function BigInteger$$$posn$$Z67CCE57D(n$$3) {\n  return BigInteger$$$$002Ector$$Z2BE94A1(1, BigInteger$$$nat$$Z67CCE57D(n$$3));\n}\nexport function BigInteger$$$negn$$Z67CCE57D(n$$4) {\n  return BigInteger$$$$002Ector$$Z2BE94A1(-1, BigInteger$$$nat$$Z67CCE57D(n$$4));\n}\nexport function BigInteger$$get_Sign(x) {\n  if (BigInteger$$get_IsZero(x)) {\n    return 0;\n  } else {\n    return x.signInt | 0;\n  }\n}\nexport function BigInteger$$get_SignInt(x$$1) {\n  return x$$1.signInt;\n}\nexport function BigInteger$$get_V(x$$2) {\n  return x$$2.v;\n}\nexport function BigInteger$$$op_Equality$$56F059C0(x$$3, y) {\n  const matchValue = [BigInteger$$get_SignInt(x$$3), BigInteger$$get_SignInt(y)];\n  var $target$$12;\n\n  if (matchValue[0] === -1) {\n    if (matchValue[1] === -1) {\n      $target$$12 = 1;\n    } else if (matchValue[1] === 0) {\n      $target$$12 = 8;\n    } else if (matchValue[1] === 1) {\n      $target$$12 = 3;\n    } else {\n      $target$$12 = 9;\n    }\n  } else if (matchValue[0] === 0) {\n    if (matchValue[1] === -1) {\n      $target$$12 = 6;\n    } else if (matchValue[1] === 0) {\n      $target$$12 = 4;\n    } else if (matchValue[1] === 1) {\n      $target$$12 = 5;\n    } else {\n      $target$$12 = 9;\n    }\n  } else if (matchValue[0] === 1) {\n    if (matchValue[1] === -1) {\n      $target$$12 = 2;\n    } else if (matchValue[1] === 0) {\n      $target$$12 = 7;\n    } else if (matchValue[1] === 1) {\n      $target$$12 = 0;\n    } else {\n      $target$$12 = 9;\n    }\n  } else {\n    $target$$12 = 9;\n  }\n\n  switch ($target$$12) {\n    case 0:\n      {\n        return BigNatModule$0024$0024$0024equal(BigInteger$$get_V(x$$3), BigInteger$$get_V(y));\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024equal(BigInteger$$get_V(x$$3), BigInteger$$get_V(y));\n      }\n\n    case 2:\n      {\n        if (BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$3))) {\n          return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y));\n        } else {\n          return false;\n        }\n      }\n\n    case 3:\n      {\n        if (BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$3))) {\n          return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y));\n        } else {\n          return false;\n        }\n      }\n\n    case 4:\n      {\n        return true;\n      }\n\n    case 5:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y));\n      }\n\n    case 6:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y));\n      }\n\n    case 7:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$3));\n      }\n\n    case 8:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$3));\n      }\n\n    case 9:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\");\n      }\n  }\n}\nexport function BigInteger$$$op_Inequality$$56F059C0(x$$4, y$$1) {\n  return !BigInteger$$$op_Equality$$56F059C0(x$$4, y$$1);\n}\nexport function BigInteger$$$op_LessThan$$56F059C0(x$$5, y$$2) {\n  const matchValue$$1 = [BigInteger$$get_SignInt(x$$5), BigInteger$$get_SignInt(y$$2)];\n  var $target$$17;\n\n  if (matchValue$$1[0] === -1) {\n    if (matchValue$$1[1] === -1) {\n      $target$$17 = 1;\n    } else if (matchValue$$1[1] === 0) {\n      $target$$17 = 8;\n    } else if (matchValue$$1[1] === 1) {\n      $target$$17 = 3;\n    } else {\n      $target$$17 = 9;\n    }\n  } else if (matchValue$$1[0] === 0) {\n    if (matchValue$$1[1] === -1) {\n      $target$$17 = 6;\n    } else if (matchValue$$1[1] === 0) {\n      $target$$17 = 4;\n    } else if (matchValue$$1[1] === 1) {\n      $target$$17 = 5;\n    } else {\n      $target$$17 = 9;\n    }\n  } else if (matchValue$$1[0] === 1) {\n    if (matchValue$$1[1] === -1) {\n      $target$$17 = 2;\n    } else if (matchValue$$1[1] === 0) {\n      $target$$17 = 7;\n    } else if (matchValue$$1[1] === 1) {\n      $target$$17 = 0;\n    } else {\n      $target$$17 = 9;\n    }\n  } else {\n    $target$$17 = 9;\n  }\n\n  switch ($target$$17) {\n    case 0:\n      {\n        return BigNatModule$0024$0024$0024lt(BigInteger$$get_V(x$$5), BigInteger$$get_V(y$$2));\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024lt(BigInteger$$get_V(y$$2), BigInteger$$get_V(x$$5));\n      }\n\n    case 2:\n      {\n        return false;\n      }\n\n    case 3:\n      {\n        if (!BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$5))) {\n          return true;\n        } else {\n          return !BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$2));\n        }\n      }\n\n    case 4:\n      {\n        return false;\n      }\n\n    case 5:\n      {\n        return !BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$2));\n      }\n\n    case 6:\n      {\n        return false;\n      }\n\n    case 7:\n      {\n        return false;\n      }\n\n    case 8:\n      {\n        return !BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$5));\n      }\n\n    case 9:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\");\n      }\n  }\n}\nexport function BigInteger$$$op_GreaterThan$$56F059C0(x$$6, y$$3) {\n  const matchValue$$2 = [BigInteger$$get_SignInt(x$$6), BigInteger$$get_SignInt(y$$3)];\n  var $target$$20;\n\n  if (matchValue$$2[0] === -1) {\n    if (matchValue$$2[1] === -1) {\n      $target$$20 = 1;\n    } else if (matchValue$$2[1] === 0) {\n      $target$$20 = 8;\n    } else if (matchValue$$2[1] === 1) {\n      $target$$20 = 3;\n    } else {\n      $target$$20 = 9;\n    }\n  } else if (matchValue$$2[0] === 0) {\n    if (matchValue$$2[1] === -1) {\n      $target$$20 = 6;\n    } else if (matchValue$$2[1] === 0) {\n      $target$$20 = 4;\n    } else if (matchValue$$2[1] === 1) {\n      $target$$20 = 5;\n    } else {\n      $target$$20 = 9;\n    }\n  } else if (matchValue$$2[0] === 1) {\n    if (matchValue$$2[1] === -1) {\n      $target$$20 = 2;\n    } else if (matchValue$$2[1] === 0) {\n      $target$$20 = 7;\n    } else if (matchValue$$2[1] === 1) {\n      $target$$20 = 0;\n    } else {\n      $target$$20 = 9;\n    }\n  } else {\n    $target$$20 = 9;\n  }\n\n  switch ($target$$20) {\n    case 0:\n      {\n        return BigNatModule$0024$0024$0024gt(BigInteger$$get_V(x$$6), BigInteger$$get_V(y$$3));\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024gt(BigInteger$$get_V(y$$3), BigInteger$$get_V(x$$6));\n      }\n\n    case 2:\n      {\n        if (!BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$6))) {\n          return true;\n        } else {\n          return !BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$3));\n        }\n      }\n\n    case 3:\n      {\n        return false;\n      }\n\n    case 4:\n      {\n        return false;\n      }\n\n    case 5:\n      {\n        return false;\n      }\n\n    case 6:\n      {\n        return !BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$3));\n      }\n\n    case 7:\n      {\n        return !BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$6));\n      }\n\n    case 8:\n      {\n        return false;\n      }\n\n    case 9:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\");\n      }\n  }\n}\nexport function BigInteger$$$compare$$56F059C0(n$$5, nn) {\n  if (BigInteger$$$op_LessThan$$56F059C0(n$$5, nn)) {\n    return -1 | 0;\n  } else if (BigInteger$$$op_Equality$$56F059C0(n$$5, nn)) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\nexport function BigInteger$$$hash$$Z665282C2(z) {\n  if (BigInteger$$get_SignInt(z) === 0) {\n    return 1;\n  } else {\n    return BigInteger$$get_SignInt(z) + BigNatModule$0024$0024$0024hash(BigInteger$$get_V(z)) | 0;\n  }\n}\n\nBigInteger.prototype.toString = function () {\n  const x$$7 = this;\n  const matchValue$$3 = BigInteger$$get_SignInt(x$$7) | 0;\n\n  switch (matchValue$$3) {\n    case -1:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$7)) ? \"0\" : \"-\" + BigNatModule$0024$0024$0024toString(BigInteger$$get_V(x$$7));\n      }\n\n    case 0:\n      {\n        return \"0\";\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024toString(BigInteger$$get_V(x$$7));\n      }\n\n    default:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\");\n      }\n  }\n};\n\nexport function BigInteger$$get_StructuredDisplayString(x$$8) {\n  return String(x$$8);\n}\n\nBigInteger.prototype.Equals = function (obj) {\n  const this$ = this;\n  return obj instanceof BigInteger ? BigInteger$$$op_Equality$$56F059C0(this$, obj) : false;\n};\n\nBigInteger.prototype.GetHashCode = function () {\n  const x$$9 = this;\n  return BigInteger$$$hash$$Z665282C2(x$$9) | 0;\n};\n\nexport function BigInteger$$$$002Ector$$Z524259A4(n$$6) {\n  if (n$$6 >= 0) {\n    return BigInteger$$$$002Ector$$Z2BE94A1.call(this, 1, BigInteger$$$nat$$Z67CCE57D(BigNatModule$0024$0024$0024ofInt32(n$$6)));\n  } else if (n$$6 === -2147483648) {\n    return BigInteger$$$$002Ector$$Z2BE94A1.call(this, -1, BigInteger$$$nat$$Z67CCE57D(BigNatModule$0024$0024$0024ofInt64(op_UnaryNegation(fromInteger(n$$6, false, 2)))));\n  } else {\n    return BigInteger$$$$002Ector$$Z2BE94A1.call(this, -1, BigInteger$$$nat$$Z67CCE57D(BigNatModule$0024$0024$0024ofInt32(op_UnaryNegation_Int32(n$$6))));\n  }\n}\nexport function BigInteger$$$$002Ector$$Z524259C1(n$$7) {\n  if (compare(n$$7, fromBits(0, 0, false)) >= 0) {\n    return BigInteger$$$$002Ector$$Z2BE94A1.call(this, 1, BigInteger$$$nat$$Z67CCE57D(BigNatModule$0024$0024$0024ofInt64(n$$7)));\n  } else if (equals(n$$7, fromBits(0, 2147483648, false))) {\n    return BigInteger$$$$002Ector$$Z2BE94A1.call(this, -1, BigInteger$$$nat$$Z67CCE57D(BigNatModule$0024$0024$0024add(BigNatModule$0024$0024$0024ofInt64(fromBits(4294967295, 2147483647, false)), BigNatModule$0024$0024$0024one)));\n  } else {\n    return BigInteger$$$$002Ector$$Z2BE94A1.call(this, -1, BigInteger$$$nat$$Z67CCE57D(BigNatModule$0024$0024$0024ofInt64(op_UnaryNegation(n$$7))));\n  }\n}\nexport function BigInteger$$$get_One() {\n  return BigInteger.one;\n}\nexport function BigInteger$$$get_Two() {\n  return BigInteger.two;\n}\nexport function BigInteger$$$get_Zero() {\n  return BigInteger.zero;\n}\nexport function BigInteger$$$op_UnaryNegation$$Z665282C2(z$$1) {\n  const matchValue$$4 = BigInteger$$get_SignInt(z$$1) | 0;\n\n  if (matchValue$$4 === 0) {\n    return BigInteger$$$get_Zero();\n  } else {\n    return BigInteger$$$create$$Z2BE94A1(op_UnaryNegation_Int32(matchValue$$4), BigInteger$$get_V(z$$1));\n  }\n}\nexport function BigInteger$$$Scale$$Z320F31E(k, z$$2) {\n  if (BigInteger$$get_SignInt(z$$2) === 0) {\n    return BigInteger$$$get_Zero();\n  } else if (k < 0) {\n    return BigInteger$$$create$$Z2BE94A1(op_UnaryNegation_Int32(BigInteger$$get_SignInt(z$$2)), BigNatModule$0024$0024$0024scale(op_UnaryNegation_Int32(k), BigInteger$$get_V(z$$2)));\n  } else {\n    return BigInteger$$$create$$Z2BE94A1(BigInteger$$get_SignInt(z$$2), BigNatModule$0024$0024$0024scale(k, BigInteger$$get_V(z$$2)));\n  }\n}\nexport function BigInteger$$$subnn$$6A57060(nx, ny) {\n  if (BigNatModule$0024$0024$0024gte(nx, ny)) {\n    return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024sub(nx, ny));\n  } else {\n    return BigInteger$$$negn$$Z67CCE57D(BigNatModule$0024$0024$0024sub(ny, nx));\n  }\n}\nexport function BigInteger$$$addnn$$6A57060(nx$$1, ny$$1) {\n  return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024add(nx$$1, ny$$1));\n}\nexport function BigInteger$$get_IsZero(x$$10) {\n  if (BigInteger$$get_SignInt(x$$10) === 0) {\n    return true;\n  } else {\n    return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$10));\n  }\n}\nexport function BigInteger$$get_IsOne(x$$11) {\n  if (BigInteger$$get_SignInt(x$$11) === 1) {\n    return BigNatModule$0024$0024$0024isOne(BigInteger$$get_V(x$$11));\n  } else {\n    return false;\n  }\n}\nexport function BigInteger$$$op_Addition$$56F059C0(x$$12, y$$4) {\n  if (BigInteger$$get_IsZero(y$$4)) {\n    return x$$12;\n  } else if (BigInteger$$get_IsZero(x$$12)) {\n    return y$$4;\n  } else {\n    const matchValue$$5 = [BigInteger$$get_SignInt(x$$12), BigInteger$$get_SignInt(y$$4)];\n    var $target$$38;\n\n    if (matchValue$$5[0] === -1) {\n      if (matchValue$$5[1] === -1) {\n        $target$$38 = 1;\n      } else if (matchValue$$5[1] === 1) {\n        $target$$38 = 3;\n      } else {\n        $target$$38 = 4;\n      }\n    } else if (matchValue$$5[0] === 1) {\n      if (matchValue$$5[1] === -1) {\n        $target$$38 = 2;\n      } else if (matchValue$$5[1] === 1) {\n        $target$$38 = 0;\n      } else {\n        $target$$38 = 4;\n      }\n    } else {\n      $target$$38 = 4;\n    }\n\n    switch ($target$$38) {\n      case 0:\n        {\n          return BigInteger$$$addnn$$6A57060(BigInteger$$get_V(x$$12), BigInteger$$get_V(y$$4));\n        }\n\n      case 1:\n        {\n          return BigInteger$$$op_UnaryNegation$$Z665282C2(BigInteger$$$addnn$$6A57060(BigInteger$$get_V(x$$12), BigInteger$$get_V(y$$4)));\n        }\n\n      case 2:\n        {\n          return BigInteger$$$subnn$$6A57060(BigInteger$$get_V(x$$12), BigInteger$$get_V(y$$4));\n        }\n\n      case 3:\n        {\n          return BigInteger$$$subnn$$6A57060(BigInteger$$get_V(y$$4), BigInteger$$get_V(x$$12));\n        }\n\n      case 4:\n        {\n          throw new Error(\"signs should be +/- 1\\\\nParameter name: x\");\n        }\n    }\n  }\n}\nexport function BigInteger$$$op_Subtraction$$56F059C0(x$$13, y$$5) {\n  if (BigInteger$$get_IsZero(y$$5)) {\n    return x$$13;\n  } else if (BigInteger$$get_IsZero(x$$13)) {\n    return BigInteger$$$op_UnaryNegation$$Z665282C2(y$$5);\n  } else {\n    const matchValue$$6 = [BigInteger$$get_SignInt(x$$13), BigInteger$$get_SignInt(y$$5)];\n    var $target$$41;\n\n    if (matchValue$$6[0] === -1) {\n      if (matchValue$$6[1] === -1) {\n        $target$$41 = 1;\n      } else if (matchValue$$6[1] === 1) {\n        $target$$41 = 3;\n      } else {\n        $target$$41 = 4;\n      }\n    } else if (matchValue$$6[0] === 1) {\n      if (matchValue$$6[1] === -1) {\n        $target$$41 = 2;\n      } else if (matchValue$$6[1] === 1) {\n        $target$$41 = 0;\n      } else {\n        $target$$41 = 4;\n      }\n    } else {\n      $target$$41 = 4;\n    }\n\n    switch ($target$$41) {\n      case 0:\n        {\n          return BigInteger$$$subnn$$6A57060(BigInteger$$get_V(x$$13), BigInteger$$get_V(y$$5));\n        }\n\n      case 1:\n        {\n          return BigInteger$$$subnn$$6A57060(BigInteger$$get_V(y$$5), BigInteger$$get_V(x$$13));\n        }\n\n      case 2:\n        {\n          return BigInteger$$$addnn$$6A57060(BigInteger$$get_V(x$$13), BigInteger$$get_V(y$$5));\n        }\n\n      case 3:\n        {\n          return BigInteger$$$op_UnaryNegation$$Z665282C2(BigInteger$$$addnn$$6A57060(BigInteger$$get_V(x$$13), BigInteger$$get_V(y$$5)));\n        }\n\n      case 4:\n        {\n          throw new Error(\"signs should be +/- 1\\\\nParameter name: x\");\n        }\n    }\n  }\n}\nexport function BigInteger$$$op_Multiply$$56F059C0(x$$14, y$$6) {\n  if (BigInteger$$get_IsZero(x$$14)) {\n    return x$$14;\n  } else if (BigInteger$$get_IsZero(y$$6)) {\n    return y$$6;\n  } else if (BigInteger$$get_IsOne(x$$14)) {\n    return y$$6;\n  } else if (BigInteger$$get_IsOne(y$$6)) {\n    return x$$14;\n  } else {\n    const m = BigNatModule$0024$0024$0024mul(BigInteger$$get_V(x$$14), BigInteger$$get_V(y$$6));\n    return BigInteger$$$create$$Z2BE94A1(BigInteger$$get_SignInt(x$$14) * BigInteger$$get_SignInt(y$$6), m);\n  }\n}\nexport function BigInteger$$$DivRem$$56F059C0(x$$15, y$$7) {\n  if (BigInteger$$get_IsZero(y$$7)) {\n    throw new Error();\n  } else {\n    void null;\n  }\n\n  if (BigInteger$$get_IsZero(x$$15)) {\n    return [BigInteger$$$get_Zero(), BigInteger$$$get_Zero()];\n  } else {\n    const patternInput = BigNatModule$0024$0024$0024divmod(BigInteger$$get_V(x$$15), BigInteger$$get_V(y$$7));\n    const matchValue$$7 = [BigInteger$$get_SignInt(x$$15), BigInteger$$get_SignInt(y$$7)];\n    var $target$$46;\n\n    if (matchValue$$7[0] === -1) {\n      if (matchValue$$7[1] === -1) {\n        $target$$46 = 1;\n      } else if (matchValue$$7[1] === 1) {\n        $target$$46 = 3;\n      } else {\n        $target$$46 = 4;\n      }\n    } else if (matchValue$$7[0] === 1) {\n      if (matchValue$$7[1] === -1) {\n        $target$$46 = 2;\n      } else if (matchValue$$7[1] === 1) {\n        $target$$46 = 0;\n      } else {\n        $target$$46 = 4;\n      }\n    } else {\n      $target$$46 = 4;\n    }\n\n    switch ($target$$46) {\n      case 0:\n        {\n          return [BigInteger$$$posn$$Z67CCE57D(patternInput[0]), BigInteger$$$posn$$Z67CCE57D(patternInput[1])];\n        }\n\n      case 1:\n        {\n          return [BigInteger$$$posn$$Z67CCE57D(patternInput[0]), BigInteger$$$negn$$Z67CCE57D(patternInput[1])];\n        }\n\n      case 2:\n        {\n          return [BigInteger$$$negn$$Z67CCE57D(patternInput[0]), BigInteger$$$posn$$Z67CCE57D(patternInput[1])];\n        }\n\n      case 3:\n        {\n          return [BigInteger$$$negn$$Z67CCE57D(patternInput[0]), BigInteger$$$negn$$Z67CCE57D(patternInput[1])];\n        }\n\n      case 4:\n        {\n          throw new Error(\"signs should be +/- 1\\\\nParameter name: x\");\n        }\n    }\n  }\n}\nexport function BigInteger$$$op_Division$$56F059C0(x$$16, y$$8) {\n  const tuple = BigInteger$$$DivRem$$56F059C0(x$$16, y$$8);\n  return tuple[0];\n}\nexport function BigInteger$$$op_Modulus$$56F059C0(x$$17, y$$9) {\n  const tuple$$1 = BigInteger$$$DivRem$$56F059C0(x$$17, y$$9);\n  return tuple$$1[1];\n}\nexport function BigInteger$$$op_RightShift$$62E082A2(x$$18, y$$10) {\n  return BigInteger$$$op_Division$$56F059C0(x$$18, BigInteger$$$Pow$$62E082A2(BigInteger$$$get_Two(), y$$10));\n}\nexport function BigInteger$$$op_LeftShift$$62E082A2(x$$19, y$$11) {\n  return BigInteger$$$op_Multiply$$56F059C0(x$$19, BigInteger$$$Pow$$62E082A2(BigInteger$$$get_Two(), y$$11));\n}\nexport function BigInteger$$$op_BitwiseAnd$$56F059C0(x$$20, y$$12) {\n  return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024bitAnd(BigInteger$$get_V(x$$20), BigInteger$$get_V(y$$12)));\n}\nexport function BigInteger$$$op_BitwiseOr$$56F059C0(x$$21, y$$13) {\n  return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024bitOr(BigInteger$$get_V(x$$21), BigInteger$$get_V(y$$13)));\n}\nexport function BigInteger$$$op_ExclusiveOr$$56F059C0(x$$22, y$$14) {\n  return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024bitXor(BigInteger$$get_V(x$$22), BigInteger$$get_V(y$$14)));\n}\nexport function BigInteger$$$GreatestCommonDivisor$$56F059C0(x$$23, y$$15) {\n  const matchValue$$8 = [BigInteger$$get_SignInt(x$$23), BigInteger$$get_SignInt(y$$15)];\n\n  if (matchValue$$8[0] === 0) {\n    if (matchValue$$8[1] === 0) {\n      return BigInteger$$$get_Zero();\n    } else {\n      return BigInteger$$$posn$$Z67CCE57D(BigInteger$$get_V(y$$15));\n    }\n  } else if (matchValue$$8[1] === 0) {\n    return BigInteger$$$posn$$Z67CCE57D(BigInteger$$get_V(x$$23));\n  } else {\n    return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024hcf(BigInteger$$get_V(x$$23), BigInteger$$get_V(y$$15)));\n  }\n}\nexport function BigInteger$$get_IsNegative(x$$24) {\n  if (BigInteger$$get_SignInt(x$$24) === -1) {\n    return !BigInteger$$get_IsZero(x$$24);\n  } else {\n    return false;\n  }\n}\nexport function BigInteger$$get_IsPositive(x$$25) {\n  if (BigInteger$$get_SignInt(x$$25) === 1) {\n    return !BigInteger$$get_IsZero(x$$25);\n  } else {\n    return false;\n  }\n}\nexport function BigInteger$$$Abs$$Z665282C2(x$$26) {\n  if (BigInteger$$get_SignInt(x$$26) === -1) {\n    return BigInteger$$$op_UnaryNegation$$Z665282C2(x$$26);\n  } else {\n    return x$$26;\n  }\n}\nexport function BigInteger$$$op_LessThanOrEqual$$56F059C0(x$$27, y$$16) {\n  const matchValue$$9 = [BigInteger$$get_SignInt(x$$27), BigInteger$$get_SignInt(y$$16)];\n  var $target$$68;\n\n  if (matchValue$$9[0] === -1) {\n    if (matchValue$$9[1] === -1) {\n      $target$$68 = 1;\n    } else if (matchValue$$9[1] === 0) {\n      $target$$68 = 6;\n    } else if (matchValue$$9[1] === 1) {\n      $target$$68 = 3;\n    } else {\n      $target$$68 = 9;\n    }\n  } else if (matchValue$$9[0] === 0) {\n    if (matchValue$$9[1] === -1) {\n      $target$$68 = 8;\n    } else if (matchValue$$9[1] === 0) {\n      $target$$68 = 4;\n    } else if (matchValue$$9[1] === 1) {\n      $target$$68 = 7;\n    } else {\n      $target$$68 = 9;\n    }\n  } else if (matchValue$$9[0] === 1) {\n    if (matchValue$$9[1] === -1) {\n      $target$$68 = 2;\n    } else if (matchValue$$9[1] === 0) {\n      $target$$68 = 5;\n    } else if (matchValue$$9[1] === 1) {\n      $target$$68 = 0;\n    } else {\n      $target$$68 = 9;\n    }\n  } else {\n    $target$$68 = 9;\n  }\n\n  switch ($target$$68) {\n    case 0:\n      {\n        return BigNatModule$0024$0024$0024lte(BigInteger$$get_V(x$$27), BigInteger$$get_V(y$$16));\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024lte(BigInteger$$get_V(y$$16), BigInteger$$get_V(x$$27));\n      }\n\n    case 2:\n      {\n        if (BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$27))) {\n          return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$16));\n        } else {\n          return false;\n        }\n      }\n\n    case 3:\n      {\n        return true;\n      }\n\n    case 4:\n      {\n        return true;\n      }\n\n    case 5:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$27));\n      }\n\n    case 6:\n      {\n        return true;\n      }\n\n    case 7:\n      {\n        return true;\n      }\n\n    case 8:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$16));\n      }\n\n    case 9:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\");\n      }\n  }\n}\nexport function BigInteger$$$op_GreaterThanOrEqual$$56F059C0(x$$28, y$$17) {\n  const matchValue$$10 = [BigInteger$$get_SignInt(x$$28), BigInteger$$get_SignInt(y$$17)];\n  var $target$$71;\n\n  if (matchValue$$10[0] === -1) {\n    if (matchValue$$10[1] === -1) {\n      $target$$71 = 1;\n    } else if (matchValue$$10[1] === 0) {\n      $target$$71 = 6;\n    } else if (matchValue$$10[1] === 1) {\n      $target$$71 = 3;\n    } else {\n      $target$$71 = 9;\n    }\n  } else if (matchValue$$10[0] === 0) {\n    if (matchValue$$10[1] === -1) {\n      $target$$71 = 8;\n    } else if (matchValue$$10[1] === 0) {\n      $target$$71 = 4;\n    } else if (matchValue$$10[1] === 1) {\n      $target$$71 = 7;\n    } else {\n      $target$$71 = 9;\n    }\n  } else if (matchValue$$10[0] === 1) {\n    if (matchValue$$10[1] === -1) {\n      $target$$71 = 2;\n    } else if (matchValue$$10[1] === 0) {\n      $target$$71 = 5;\n    } else if (matchValue$$10[1] === 1) {\n      $target$$71 = 0;\n    } else {\n      $target$$71 = 9;\n    }\n  } else {\n    $target$$71 = 9;\n  }\n\n  switch ($target$$71) {\n    case 0:\n      {\n        return BigNatModule$0024$0024$0024gte(BigInteger$$get_V(x$$28), BigInteger$$get_V(y$$17));\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024gte(BigInteger$$get_V(y$$17), BigInteger$$get_V(x$$28));\n      }\n\n    case 2:\n      {\n        return true;\n      }\n\n    case 3:\n      {\n        if (BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$28))) {\n          return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$17));\n        } else {\n          return false;\n        }\n      }\n\n    case 4:\n      {\n        return true;\n      }\n\n    case 5:\n      {\n        return true;\n      }\n\n    case 6:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(x$$28));\n      }\n\n    case 7:\n      {\n        return BigNatModule$0024$0024$0024isZero(BigInteger$$get_V(y$$17));\n      }\n\n    case 8:\n      {\n        return true;\n      }\n\n    case 9:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\");\n      }\n  }\n}\nexport function BigInteger$$$Pow$$62E082A2(x$$29, y$$18) {\n  if (y$$18 < 0) {\n    throw new Error(\"y\");\n  } else {\n    void null;\n  }\n\n  const matchValue$$11 = [BigInteger$$get_IsZero(x$$29), y$$18];\n\n  if (matchValue$$11[0]) {\n    if (matchValue$$11[1] === 0) {\n      return BigInteger$$$get_One();\n    } else {\n      return BigInteger$$$get_Zero();\n    }\n  } else {\n    const yval = BigInteger$$$$002Ector$$Z524259A4(y$$18);\n    return BigInteger$$$create$$Z2BE94A1(BigNatModule$0024$0024$0024isZero(BigNatModule$0024$0024$0024rem(BigInteger$$get_V(yval), BigNatModule$0024$0024$0024two)) ? 1 : BigInteger$$get_SignInt(x$$29), BigNatModule$0024$0024$0024pow(BigInteger$$get_V(x$$29), BigInteger$$get_V(yval)));\n  }\n}\nexport function BigInteger$$get_ToInt32(x$$30) {\n  if (BigInteger$$get_IsZero(x$$30)) {\n    return 0;\n  } else {\n    const u = BigNatModule$0024$0024$0024toUInt32(BigInteger$$get_V(x$$30));\n\n    if (u <= 2147483647 >>> 0) {\n      return BigInteger$$get_SignInt(x$$30) * ~~u | 0;\n    } else if (BigInteger$$get_SignInt(x$$30) === -1 ? u === 2147483647 + 1 >>> 0 : false) {\n      return -2147483648 | 0;\n    } else {\n      throw new Error();\n    }\n  }\n}\nexport function BigInteger$$get_ToUInt32(x$$31) {\n  if (BigInteger$$get_IsZero(x$$31)) {\n    return 0;\n  } else {\n    return BigNatModule$0024$0024$0024toUInt32(BigInteger$$get_V(x$$31));\n  }\n}\nexport function BigInteger$$get_ToInt64(x$$32) {\n  if (BigInteger$$get_IsZero(x$$32)) {\n    return fromBits(0, 0, false);\n  } else {\n    const u$$1 = BigNatModule$0024$0024$0024toUInt64(BigInteger$$get_V(x$$32));\n\n    if (compare(u$$1, fromValue(fromBits(4294967295, 2147483647, false), true)) <= 0) {\n      return op_Multiply(fromInteger(BigInteger$$get_SignInt(x$$32), false, 2), fromValue(u$$1, false));\n    } else if (BigInteger$$get_SignInt(x$$32) === -1 ? equals(u$$1, fromValue(op_Addition(fromBits(4294967295, 2147483647, false), fromBits(1, 0, false)), true)) : false) {\n      return fromBits(0, 2147483648, false);\n    } else {\n      throw new Error();\n    }\n  }\n}\nexport function BigInteger$$get_ToUInt64(x$$33) {\n  if (BigInteger$$get_IsZero(x$$33)) {\n    return fromBits(0, 0, true);\n  } else {\n    return BigNatModule$0024$0024$0024toUInt64(BigInteger$$get_V(x$$33));\n  }\n}\nexport function BigInteger$$get_ToDouble(x$$34) {\n  const matchValue$$12 = BigInteger$$get_SignInt(x$$34) | 0;\n\n  switch (matchValue$$12) {\n    case -1:\n      {\n        return -BigNatModule$0024$0024$0024toFloat(BigInteger$$get_V(x$$34));\n      }\n\n    case 0:\n      {\n        return 0;\n      }\n\n    case 1:\n      {\n        return BigNatModule$0024$0024$0024toFloat(BigInteger$$get_V(x$$34));\n      }\n\n    default:\n      {\n        throw new Error(\"signs should be +/- 1 or 0\\\\nParameter name: x\");\n      }\n  }\n}\nexport function BigInteger$$get_ToSByte(x$$35) {\n  return (BigInteger$$get_ToInt32(x$$35) + 0x80 & 0xFF) - 0x80;\n}\nexport function BigInteger$$get_ToByte(x$$36) {\n  return BigInteger$$get_ToUInt32(x$$36) & 0xFF;\n}\nexport function BigInteger$$get_ToInt16(x$$37) {\n  return (BigInteger$$get_ToInt32(x$$37) + 0x8000 & 0xFFFF) - 0x8000;\n}\nexport function BigInteger$$get_ToUInt16(x$$38) {\n  return BigInteger$$get_ToUInt32(x$$38) & 0xFFFF;\n}\nexport function BigInteger$$get_ToSingle(x$$39) {\n  return BigInteger$$get_ToDouble(x$$39);\n}\nexport function BigInteger$$get_ToDecimal(x$$40) {\n  return new Decimal(BigInteger$$get_ToDouble(x$$40));\n}\nexport function BigInteger$$$Parse$$Z721C83C5(text) {\n  if (text == null) {\n    throw new Error(\"text\");\n  } else {\n    void null;\n  }\n\n  const text$$1 = text.trim();\n  const len = text$$1.length | 0;\n\n  if (len === 0) {\n    throw new Error();\n  } else {\n    void null;\n  }\n\n  const matchValue$$13 = [text$$1[0], len];\n\n  if (matchValue$$13[0] === \"+\") {\n    if (matchValue$$13[1] === 1) {\n      throw new Error();\n    } else {\n      return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024ofString(text$$1.slice(1, len - 1 + 1)));\n    }\n  } else if (matchValue$$13[0] === \"-\") {\n    if (matchValue$$13[1] === 1) {\n      throw new Error();\n    } else {\n      return BigInteger$$$negn$$Z67CCE57D(BigNatModule$0024$0024$0024ofString(text$$1.slice(1, len - 1 + 1)));\n    }\n  } else {\n    return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024ofString(text$$1));\n  }\n}\nexport function BigInteger$$get_IsSmall(x$$41) {\n  if (BigInteger$$get_IsZero(x$$41)) {\n    return true;\n  } else {\n    return BigNatModule$0024$0024$0024isSmall(BigInteger$$get_V(x$$41));\n  }\n}\nexport function BigInteger$$$Factorial$$Z665282C2(x$$42) {\n  if (BigInteger$$get_IsNegative(x$$42)) {\n    throw new Error(\"mustBeNonNegative\\\\nParameter name: x\");\n  } else {\n    void null;\n  }\n\n  if (BigInteger$$get_IsPositive(x$$42)) {\n    return BigInteger$$$posn$$Z67CCE57D(BigNatModule$0024$0024$0024factorial(BigInteger$$get_V(x$$42)));\n  } else {\n    return BigInteger$$$get_One();\n  }\n}\nexport function BigInteger$$$op_UnaryPlus$$Z665282C2(n1) {\n  return n1;\n}\nexport function BigInteger$$$FromInt64$$Z524259C1(x$$43) {\n  return BigInteger$$$$002Ector$$Z524259C1(x$$43);\n}\nexport function BigInteger$$$FromInt32$$Z524259A4(x$$44) {\n  return BigInteger$$$$002Ector$$Z524259A4(x$$44);\n}\n\nBigInteger.prototype.CompareTo = function (obj$$1) {\n  const this$$$1 = this;\n\n  if (obj$$1 instanceof BigInteger) {\n    return BigInteger$$$compare$$56F059C0(this$$$1, obj$$1) | 0;\n  } else {\n    throw new Error(\"the objects are not comparable\\\\nParameter name: obj\");\n  }\n};","import { defaultArg, value as value$$1, some } from \"./Option.js\";\nimport { List } from \"./Types.js\";\nimport { transpose as transpose$$1, pairwise as pairwise$$1, collect as collect$$1, scanBack as scanBack$$1, scan as scan$$1, foldBack2 as foldBack2$$1, fold2 as fold2$$1, fold as fold$$1, map as map$$1 } from \"./Seq.js\";\nimport { getItemFromDict, addToDict, tryGetValue, addToSet, count } from \"./Util.js\";\nimport { ofList } from \"./Array.js\";\nimport { splitInto as splitInto$$1, chunkBySize as chunkBySize$$1, permute as permute$$1, findIndexBack as findIndexBack$$1, tryFindIndexBack as tryFindIndexBack$$1 } from \"./Array\";\nimport { createMutable } from \"./Set.js\";\nimport { createMutable as createMutable$$1 } from \"./Map.js\";\nexport function head(_arg1) {\n  if (_arg1.tail != null) {\n    return _arg1.head;\n  } else {\n    throw new Error(\"List was empty\");\n  }\n}\nexport function tryHead(_arg1$$1) {\n  if (_arg1$$1.tail != null) {\n    return some(_arg1$$1.head);\n  } else {\n    return undefined;\n  }\n}\nexport function tail(_arg1$$2) {\n  if (_arg1$$2.tail != null) {\n    return _arg1$$2.tail;\n  } else {\n    throw new Error(\"List was empty\");\n  }\n}\nexport function last($_arg1$$3$$5) {\n  last: while (true) {\n    const _arg1$$3 = $_arg1$$3$$5;\n\n    if (_arg1$$3.tail != null) {\n      if (_arg1$$3.tail.tail == null) {\n        return _arg1$$3.head;\n      } else {\n        $_arg1$$3$$5 = _arg1$$3.tail;\n        continue last;\n      }\n    } else {\n      throw new Error(\"List was empty\");\n    }\n\n    break;\n  }\n}\nexport function tryLast($_arg1$$4$$6) {\n  tryLast: while (true) {\n    const _arg1$$4 = $_arg1$$4$$6;\n\n    if (_arg1$$4.tail != null) {\n      if (_arg1$$4.tail.tail == null) {\n        return some(_arg1$$4.head);\n      } else {\n        $_arg1$$4$$6 = _arg1$$4.tail;\n        continue tryLast;\n      }\n    } else {\n      return undefined;\n    }\n\n    break;\n  }\n}\nexport function compareWith(comparer, xs$$3, ys) {\n  if (xs$$3 === ys) {\n    return 0;\n  } else {\n    const loop = function loop($xs$$4$$10, $ys$$1$$11) {\n      loop: while (true) {\n        const xs$$4 = $xs$$4$$10,\n              ys$$1 = $ys$$1$$11;\n\n        if (xs$$4.tail != null) {\n          if (ys$$1.tail != null) {\n            const matchValue$$1 = comparer(xs$$4.head, ys$$1.head) | 0;\n\n            if (matchValue$$1 === 0) {\n              $xs$$4$$10 = xs$$4.tail;\n              $ys$$1$$11 = ys$$1.tail;\n              continue loop;\n            } else {\n              return matchValue$$1 | 0;\n            }\n          } else {\n            return 1;\n          }\n        } else if (ys$$1.tail == null) {\n          return 0;\n        } else {\n          return -1 | 0;\n        }\n\n        break;\n      }\n    };\n\n    return loop(xs$$3, ys) | 0;\n  }\n}\nexport function foldIndexedAux($f$$12, $i$$13, $acc$$14, $_arg1$$5$$15) {\n  foldIndexedAux: while (true) {\n    const f = $f$$12,\n          i = $i$$13,\n          acc = $acc$$14,\n          _arg1$$5 = $_arg1$$5$$15;\n\n    if (_arg1$$5.tail != null) {\n      $f$$12 = f;\n      $i$$13 = i + 1;\n      $acc$$14 = f(i, acc, _arg1$$5.head);\n      $_arg1$$5$$15 = _arg1$$5.tail;\n      continue foldIndexedAux;\n    } else {\n      return acc;\n    }\n\n    break;\n  }\n}\nexport function foldIndexed(f$$1, state, xs$$7) {\n  return foldIndexedAux(f$$1, 0, state, xs$$7);\n}\nexport function fold($f$$2$$19, $state$$1$$20, $xs$$8$$21) {\n  fold: while (true) {\n    const f$$2 = $f$$2$$19,\n          state$$1 = $state$$1$$20,\n          xs$$8 = $xs$$8$$21;\n\n    if (xs$$8.tail != null) {\n      $f$$2$$19 = f$$2;\n      $state$$1$$20 = f$$2(state$$1, xs$$8.head);\n      $xs$$8$$21 = xs$$8.tail;\n      continue fold;\n    } else {\n      return state$$1;\n    }\n\n    break;\n  }\n}\nexport function reverse(xs$$9) {\n  return fold(function (acc$$1, x$$6) {\n    return new List(x$$6, acc$$1);\n  }, new List(), xs$$9);\n}\nexport function foldBack(f$$3, xs$$10, state$$2) {\n  return fold(function (acc$$2, x$$7) {\n    return f$$3(x$$7, acc$$2);\n  }, state$$2, reverse(xs$$10));\n}\nexport function toSeq(xs$$11) {\n  return map$$1(function (x$$8) {\n    return x$$8;\n  }, xs$$11);\n}\nexport function ofSeq(xs$$12) {\n  const xs$$13 = fold$$1(function (acc$$3, x$$9) {\n    return new List(x$$9, acc$$3);\n  }, new List(), xs$$12);\n  return reverse(xs$$13);\n}\nexport function concat(lists) {\n  const xs$$15 = fold$$1(function (state$$3, xs$$14) {\n    return fold(function f$$4(acc$$4, x$$10) {\n      return new List(x$$10, acc$$4);\n    }, state$$3, xs$$14);\n  }, new List(), lists);\n  return reverse(xs$$15);\n}\nexport function foldIndexed2Aux($f$$5$$31, $i$$1$$32, $acc$$5$$33, $bs$$34, $cs$$35) {\n  foldIndexed2Aux: while (true) {\n    const f$$5 = $f$$5$$31,\n          i$$1 = $i$$1$$32,\n          acc$$5 = $acc$$5$$33,\n          bs = $bs$$34,\n          cs = $cs$$35;\n    var $target$$36, x$$11, xs$$16, y$$1, ys$$3;\n\n    if (bs.tail != null) {\n      if (cs.tail != null) {\n        $target$$36 = 1;\n        x$$11 = bs.head;\n        xs$$16 = bs.tail;\n        y$$1 = cs.head;\n        ys$$3 = cs.tail;\n      } else {\n        $target$$36 = 2;\n      }\n    } else if (cs.tail == null) {\n      $target$$36 = 0;\n    } else {\n      $target$$36 = 2;\n    }\n\n    switch ($target$$36) {\n      case 0:\n        {\n          return acc$$5;\n        }\n\n      case 1:\n        {\n          $f$$5$$31 = f$$5;\n          $i$$1$$32 = i$$1 + 1;\n          $acc$$5$$33 = f$$5(i$$1, acc$$5, x$$11, y$$1);\n          $bs$$34 = xs$$16;\n          $cs$$35 = ys$$3;\n          continue foldIndexed2Aux;\n        }\n\n      case 2:\n        {\n          throw new Error(\"Lists had different lengths\");\n        }\n    }\n\n    break;\n  }\n}\nexport function foldIndexed2(f$$6, state$$4, xs$$17, ys$$4) {\n  return foldIndexed2Aux(f$$6, 0, state$$4, xs$$17, ys$$4);\n}\nexport function fold2(f$$7, state$$5, xs$$18, ys$$5) {\n  return fold2$$1(f$$7, state$$5, xs$$18, ys$$5);\n}\nexport function foldBack2(f$$8, xs$$19, ys$$6, state$$6) {\n  return foldBack2$$1(f$$8, xs$$19, ys$$6, state$$6);\n}\nexport function unfold(f$$9, state$$7) {\n  const unfoldInner = function unfoldInner($acc$$6$$51, $state$$8$$52) {\n    unfoldInner: while (true) {\n      const acc$$6 = $acc$$6$$51,\n            state$$8 = $state$$8$$52;\n      const matchValue$$3 = f$$9(state$$8);\n\n      if (matchValue$$3 != null) {\n        const x$$12 = matchValue$$3[0];\n        const state$$9 = matchValue$$3[1];\n        $acc$$6$$51 = new List(x$$12, acc$$6);\n        $state$$8$$52 = state$$9;\n        continue unfoldInner;\n      } else {\n        return reverse(acc$$6);\n      }\n\n      break;\n    }\n  };\n\n  return unfoldInner(new List(), state$$7);\n}\nexport function foldIndexed3Aux($f$$10$$53, $i$$2$$54, $acc$$7$$55, $bs$$1$$56, $cs$$1$$57, $ds$$58) {\n  foldIndexed3Aux: while (true) {\n    const f$$10 = $f$$10$$53,\n          i$$2 = $i$$2$$54,\n          acc$$7 = $acc$$7$$55,\n          bs$$1 = $bs$$1$$56,\n          cs$$1 = $cs$$1$$57,\n          ds = $ds$$58;\n    var $target$$59, x$$13, xs$$20, y$$2, ys$$7, z, zs;\n\n    if (bs$$1.tail != null) {\n      if (cs$$1.tail != null) {\n        if (ds.tail != null) {\n          $target$$59 = 1;\n          x$$13 = bs$$1.head;\n          xs$$20 = bs$$1.tail;\n          y$$2 = cs$$1.head;\n          ys$$7 = cs$$1.tail;\n          z = ds.head;\n          zs = ds.tail;\n        } else {\n          $target$$59 = 2;\n        }\n      } else {\n        $target$$59 = 2;\n      }\n    } else if (cs$$1.tail == null) {\n      if (ds.tail == null) {\n        $target$$59 = 0;\n      } else {\n        $target$$59 = 2;\n      }\n    } else {\n      $target$$59 = 2;\n    }\n\n    switch ($target$$59) {\n      case 0:\n        {\n          return acc$$7;\n        }\n\n      case 1:\n        {\n          $f$$10$$53 = f$$10;\n          $i$$2$$54 = i$$2 + 1;\n          $acc$$7$$55 = f$$10(i$$2, acc$$7, x$$13, y$$2, z);\n          $bs$$1$$56 = xs$$20;\n          $cs$$1$$57 = ys$$7;\n          $ds$$58 = zs;\n          continue foldIndexed3Aux;\n        }\n\n      case 2:\n        {\n          throw new Error(\"Lists had different lengths\");\n        }\n    }\n\n    break;\n  }\n}\nexport function foldIndexed3(f$$11, seed, xs$$21, ys$$8, zs$$1) {\n  return foldIndexed3Aux(f$$11, 0, seed, xs$$21, ys$$8, zs$$1);\n}\nexport function fold3(f$$12, state$$10, xs$$22, ys$$9, zs$$2) {\n  return foldIndexed3(function (_arg1$$6, acc$$8, x$$14, y$$3, z$$1) {\n    return f$$12(acc$$8, x$$14, y$$3, z$$1);\n  }, state$$10, xs$$22, ys$$9, zs$$2);\n}\nexport function scan(f$$13, state$$11, xs$$23) {\n  const xs$$24 = scan$$1(f$$13, state$$11, xs$$23);\n  return ofSeq(xs$$24);\n}\nexport function scanBack(f$$14, xs$$25, state$$12) {\n  const xs$$26 = scanBack$$1(f$$14, xs$$25, state$$12);\n  return ofSeq(xs$$26);\n}\nexport function length(xs$$27) {\n  return fold(function (acc$$9, _arg1$$7) {\n    return acc$$9 + 1;\n  }, 0, xs$$27);\n}\nexport function append(xs$$28, ys$$10) {\n  return fold(function (acc$$10, x$$15) {\n    return new List(x$$15, acc$$10);\n  }, ys$$10, reverse(xs$$28));\n}\nexport function collect(f$$15, xs$$29) {\n  const xs$$30 = collect$$1(f$$15, xs$$29);\n  return ofSeq(xs$$30);\n}\nexport function map(f$$16, xs$$31) {\n  const xs$$32 = fold(function (acc$$11, x$$16) {\n    return new List(f$$16(x$$16), acc$$11);\n  }, new List(), xs$$31);\n  return reverse(xs$$32);\n}\nexport function mapIndexed(f$$17, xs$$33) {\n  const xs$$34 = foldIndexed(function (i$$3, acc$$12, x$$17) {\n    return new List(f$$17(i$$3, x$$17), acc$$12);\n  }, new List(), xs$$33);\n  return reverse(xs$$34);\n}\nexport function indexed(xs$$35) {\n  return mapIndexed(function (i$$4, x$$18) {\n    return [i$$4, x$$18];\n  }, xs$$35);\n}\nexport function map2(f$$18, xs$$36, ys$$11) {\n  const xs$$37 = fold2(function (acc$$13, x$$19, y$$4) {\n    return new List(f$$18(x$$19, y$$4), acc$$13);\n  }, new List(), xs$$36, ys$$11);\n  return reverse(xs$$37);\n}\nexport function mapIndexed2(f$$19, xs$$38, ys$$12) {\n  const xs$$39 = foldIndexed2(function (i$$5, acc$$14, x$$20, y$$5) {\n    return new List(f$$19(i$$5, x$$20, y$$5), acc$$14);\n  }, new List(), xs$$38, ys$$12);\n  return reverse(xs$$39);\n}\nexport function map3(f$$20, xs$$40, ys$$13, zs$$3) {\n  const xs$$41 = fold3(function (acc$$15, x$$21, y$$6, z$$2) {\n    return new List(f$$20(x$$21, y$$6, z$$2), acc$$15);\n  }, new List(), xs$$40, ys$$13, zs$$3);\n  return reverse(xs$$41);\n}\nexport function mapIndexed3(f$$21, xs$$42, ys$$14, zs$$4) {\n  const xs$$43 = foldIndexed3(function (i$$6, acc$$16, x$$22, y$$7, z$$3) {\n    return new List(f$$21(i$$6, x$$22, y$$7, z$$3), acc$$16);\n  }, new List(), xs$$42, ys$$14, zs$$4);\n  return reverse(xs$$43);\n}\nexport function mapFold(f$$22, s, xs$$44) {\n  const patternInput$$1 = fold(function foldFn(tupledArg, x$$23) {\n    const patternInput = f$$22(tupledArg[1], x$$23);\n    return [new List(patternInput[0], tupledArg[0]), patternInput[1]];\n  }, [new List(), s], xs$$44);\n  return [reverse(patternInput$$1[0]), patternInput$$1[1]];\n}\nexport function mapFoldBack(f$$23, xs$$45, s$$2) {\n  return mapFold(function (s$$3, v) {\n    return f$$23(v, s$$3);\n  }, s$$2, reverse(xs$$45));\n}\nexport function iterate(f$$24, xs$$46) {\n  fold(function (unitVar0, x$$24) {\n    f$$24(x$$24);\n  }, void null, xs$$46);\n}\nexport function iterate2(f$$25, xs$$47, ys$$15) {\n  fold2(function (unitVar0$$1, x$$25, y$$8) {\n    f$$25(x$$25, y$$8);\n  }, void null, xs$$47, ys$$15);\n}\nexport function iterateIndexed(f$$26, xs$$48) {\n  foldIndexed(function (i$$7, unitVar1, x$$26) {\n    f$$26(i$$7, x$$26);\n  }, void null, xs$$48);\n}\nexport function iterateIndexed2(f$$27, xs$$49, ys$$16) {\n  foldIndexed2(function (i$$8, unitVar1$$1, x$$27, y$$9) {\n    f$$27(i$$8, x$$27, y$$9);\n  }, void null, xs$$49, ys$$16);\n}\nexport function ofArray(xs$$50) {\n  let res$$1 = new List();\n\n  for (let i$$9 = count(xs$$50) - 1; i$$9 >= 0; i$$9--) {\n    res$$1 = new List(xs$$50[i$$9], res$$1);\n  }\n\n  return res$$1;\n}\nexport function empty() {\n  return new List();\n}\nexport function isEmpty(_arg1$$8) {\n  if (_arg1$$8.tail == null) {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function tryPickIndexedAux($f$$28$$120, $i$$10$$121, $_arg1$$9$$122) {\n  tryPickIndexedAux: while (true) {\n    const f$$28 = $f$$28$$120,\n          i$$10 = $i$$10$$121,\n          _arg1$$9 = $_arg1$$9$$122;\n\n    if (_arg1$$9.tail != null) {\n      const result = f$$28(i$$10, _arg1$$9.head);\n\n      if (result == null) {\n        $f$$28$$120 = f$$28;\n        $i$$10$$121 = i$$10 + 1;\n        $_arg1$$9$$122 = _arg1$$9.tail;\n        continue tryPickIndexedAux;\n      } else {\n        return result;\n      }\n    } else {\n      return undefined;\n    }\n\n    break;\n  }\n}\nexport function tryPickIndexed(f$$29, xs$$52) {\n  return tryPickIndexedAux(f$$29, 0, xs$$52);\n}\nexport function tryPick(f$$30, xs$$53) {\n  return tryPickIndexed(function (_arg1$$10, x$$29) {\n    return f$$30(x$$29);\n  }, xs$$53);\n}\nexport function pick(f$$31, xs$$54) {\n  const matchValue$$5 = tryPick(f$$31, xs$$54);\n\n  if (matchValue$$5 != null) {\n    const x$$30 = value$$1(matchValue$$5);\n    return x$$30;\n  } else {\n    throw new Error(\"List did not contain any matching elements\");\n  }\n}\nexport function tryFindIndexed(f$$32, xs$$55) {\n  return tryPickIndexed(function (i$$11, x$$31) {\n    return f$$32(i$$11, x$$31) ? some(x$$31) : undefined;\n  }, xs$$55);\n}\nexport function tryFind(f$$33, xs$$56) {\n  return tryPickIndexed(function (_arg1$$11, x$$32) {\n    return f$$33(x$$32) ? some(x$$32) : undefined;\n  }, xs$$56);\n}\nexport function findIndexed(f$$34, xs$$57) {\n  const matchValue$$6 = tryFindIndexed(f$$34, xs$$57);\n\n  if (matchValue$$6 != null) {\n    const x$$33 = value$$1(matchValue$$6);\n    return x$$33;\n  } else {\n    throw new Error(\"List did not contain any matching elements\");\n  }\n}\nexport function find(f$$35, xs$$58) {\n  return findIndexed(function (_arg1$$12, x$$34) {\n    return f$$35(x$$34);\n  }, xs$$58);\n}\nexport function findBack(f$$36, xs$$59) {\n  let xs$$61;\n  xs$$61 = reverse(xs$$59);\n  return find(f$$36, xs$$61);\n}\nexport function tryFindBack(f$$37, xs$$62) {\n  let xs$$64;\n  xs$$64 = reverse(xs$$62);\n  return tryFind(f$$37, xs$$64);\n}\nexport function tryFindIndex(f$$38, xs$$65) {\n  return tryPickIndexed(function (i$$12, x$$35) {\n    return f$$38(x$$35) ? i$$12 : undefined;\n  }, xs$$65);\n}\nexport function tryFindIndexBack(f$$39, xs$$66) {\n  const array = ofList(xs$$66, Array);\n  return tryFindIndexBack$$1(f$$39, array);\n}\nexport function findIndex(f$$40, xs$$67) {\n  const matchValue$$7 = tryFindIndex(f$$40, xs$$67);\n\n  if (matchValue$$7 != null) {\n    const x$$36 = matchValue$$7 | 0;\n    return x$$36 | 0;\n  } else {\n    throw new Error(\"List did not contain any matching elements\");\n  }\n}\nexport function findIndexBack(f$$41, xs$$68) {\n  const array$$1 = ofList(xs$$68, Array);\n  return findIndexBack$$1(f$$41, array$$1) | 0;\n}\nexport function item(n, xs$$69) {\n  return findIndexed(function (i$$13, _arg1$$13) {\n    return n === i$$13;\n  }, xs$$69);\n}\nexport function tryItem(n$$1, xs$$70) {\n  return tryFindIndexed(function (i$$14, _arg1$$14) {\n    return n$$1 === i$$14;\n  }, xs$$70);\n}\nexport function filter(f$$42, xs$$71) {\n  const xs$$72 = fold(function (acc$$17, x$$37) {\n    return f$$42(x$$37) ? new List(x$$37, acc$$17) : acc$$17;\n  }, new List(), xs$$71);\n  return reverse(xs$$72);\n}\nexport function partition(f$$43, xs$$73) {\n  return fold(function (tupledArg$$1, x$$38) {\n    return f$$43(x$$38) ? [new List(x$$38, tupledArg$$1[0]), tupledArg$$1[1]] : [tupledArg$$1[0], new List(x$$38, tupledArg$$1[1])];\n  }, [new List(), new List()], reverse(xs$$73));\n}\nexport function choose(f$$44, xs$$74) {\n  const xs$$75 = fold(function (acc$$18, x$$39) {\n    const matchValue$$8 = f$$44(x$$39);\n\n    if (matchValue$$8 == null) {\n      return acc$$18;\n    } else {\n      const y$$10 = value$$1(matchValue$$8);\n      return new List(y$$10, acc$$18);\n    }\n  }, new List(), xs$$74);\n  return reverse(xs$$75);\n}\nexport function contains(value, list, eq) {\n  const loop$$1 = function loop$$1($xs$$76$$162) {\n    loop$$1: while (true) {\n      const xs$$76 = $xs$$76$$162;\n\n      if (xs$$76.tail != null) {\n        if (eq.Equals(value, xs$$76.head)) {\n          return true;\n        } else {\n          $xs$$76$$162 = xs$$76.tail;\n          continue loop$$1;\n        }\n      } else {\n        return false;\n      }\n\n      break;\n    }\n  };\n\n  return loop$$1(list);\n}\nexport function except(itemsToExclude, array$$2, eq$$1) {\n  if (isEmpty(array$$2)) {\n    return array$$2;\n  } else {\n    const cached = createMutable(itemsToExclude, eq$$1);\n    return filter(function f$$45(arg00) {\n      return addToSet(arg00, cached);\n    }, array$$2);\n  }\n}\nexport function initialize(n$$2, f$$46) {\n  let xs$$78 = new List();\n\n  for (let i$$15 = 0; i$$15 <= n$$2 - 1; i$$15++) {\n    xs$$78 = new List(f$$46(i$$15), xs$$78);\n  }\n\n  return reverse(xs$$78);\n}\nexport function replicate(n$$3, x$$40) {\n  return initialize(n$$3, function (_arg1$$15) {\n    return x$$40;\n  });\n}\nexport function reduce(f$$47, _arg1$$16) {\n  if (_arg1$$16.tail != null) {\n    return fold(f$$47, _arg1$$16.head, _arg1$$16.tail);\n  } else {\n    throw new Error(\"List was empty\");\n  }\n}\nexport function reduceBack(f$$48, _arg1$$17) {\n  if (_arg1$$17.tail != null) {\n    return foldBack(f$$48, _arg1$$17.tail, _arg1$$17.head);\n  } else {\n    throw new Error(\"List was empty\");\n  }\n}\nexport function forAll(f$$49, xs$$79) {\n  return fold(function (acc$$19, x$$41) {\n    return acc$$19 ? f$$49(x$$41) : false;\n  }, true, xs$$79);\n}\nexport function forAll2(f$$50, xs$$80, ys$$17) {\n  return fold2(function (acc$$20, x$$42, y$$11) {\n    return acc$$20 ? f$$50(x$$42, y$$11) : false;\n  }, true, xs$$80, ys$$17);\n}\nexport function exists($f$$51$$180, $_arg1$$18$$181) {\n  exists: while (true) {\n    const f$$51 = $f$$51$$180,\n          _arg1$$18 = $_arg1$$18$$181;\n\n    if (_arg1$$18.tail != null) {\n      if (f$$51(_arg1$$18.head)) {\n        return true;\n      } else {\n        $f$$51$$180 = f$$51;\n        $_arg1$$18$$181 = _arg1$$18.tail;\n        continue exists;\n      }\n    } else {\n      return false;\n    }\n\n    break;\n  }\n}\nexport function exists2($f$$52$$182, $bs$$2$$183, $cs$$2$$184) {\n  exists2: while (true) {\n    const f$$52 = $f$$52$$182,\n          bs$$2 = $bs$$2$$183,\n          cs$$2 = $cs$$2$$184;\n    var $target$$185, x$$44, xs$$82, y$$12, ys$$18;\n\n    if (bs$$2.tail != null) {\n      if (cs$$2.tail != null) {\n        $target$$185 = 1;\n        x$$44 = bs$$2.head;\n        xs$$82 = bs$$2.tail;\n        y$$12 = cs$$2.head;\n        ys$$18 = cs$$2.tail;\n      } else {\n        $target$$185 = 2;\n      }\n    } else if (cs$$2.tail == null) {\n      $target$$185 = 0;\n    } else {\n      $target$$185 = 2;\n    }\n\n    switch ($target$$185) {\n      case 0:\n        {\n          return false;\n        }\n\n      case 1:\n        {\n          if (f$$52(x$$44, y$$12)) {\n            return true;\n          } else {\n            $f$$52$$182 = f$$52;\n            $bs$$2$$183 = xs$$82;\n            $cs$$2$$184 = ys$$18;\n            continue exists2;\n          }\n        }\n\n      case 2:\n        {\n          throw new Error(\"Lists had different lengths\");\n        }\n    }\n\n    break;\n  }\n}\nexport function unzip(xs$$83) {\n  return foldBack(function (tupledArg$$2, tupledArg$$3) {\n    return [new List(tupledArg$$2[0], tupledArg$$3[0]), new List(tupledArg$$2[1], tupledArg$$3[1])];\n  }, xs$$83, [new List(), new List()]);\n}\nexport function unzip3(xs$$84) {\n  return foldBack(function (tupledArg$$4, tupledArg$$5) {\n    return [new List(tupledArg$$4[0], tupledArg$$5[0]), new List(tupledArg$$4[1], tupledArg$$5[1]), new List(tupledArg$$4[2], tupledArg$$5[2])];\n  }, xs$$84, [new List(), new List(), new List()]);\n}\nexport function zip(xs$$85, ys$$19) {\n  return map2(function (x$$47, y$$15) {\n    return [x$$47, y$$15];\n  }, xs$$85, ys$$19);\n}\nexport function zip3(xs$$86, ys$$20, zs$$5) {\n  return map3(function (x$$48, y$$16, z$$5) {\n    return [x$$48, y$$16, z$$5];\n  }, xs$$86, ys$$20, zs$$5);\n}\nexport function sort(xs$$87, comparer$$1) {\n  let xs$$89;\n  const xs$$88 = ofList(xs$$87, Array);\n  xs$$88.sort(function comparer$$2(x$$49, y$$17) {\n    return comparer$$1.Compare(x$$49, y$$17);\n  });\n  xs$$89 = xs$$88;\n  return ofArray(xs$$89);\n}\nexport function sortBy(projection, xs$$90, comparer$$3) {\n  let xs$$92;\n  const xs$$91 = ofList(xs$$90, Array);\n  xs$$91.sort(function comparer$$4(x$$50, y$$18) {\n    return comparer$$3.Compare(projection(x$$50), projection(y$$18));\n  });\n  xs$$92 = xs$$91;\n  return ofArray(xs$$92);\n}\nexport function sortDescending(xs$$93, comparer$$5) {\n  let xs$$95;\n  const xs$$94 = ofList(xs$$93, Array);\n  xs$$94.sort(function comparer$$6(x$$51, y$$19) {\n    return comparer$$5.Compare(x$$51, y$$19) * -1;\n  });\n  xs$$95 = xs$$94;\n  return ofArray(xs$$95);\n}\nexport function sortByDescending(projection$$1, xs$$96, comparer$$7) {\n  let xs$$98;\n  const xs$$97 = ofList(xs$$96, Array);\n  xs$$97.sort(function comparer$$8(x$$52, y$$20) {\n    return comparer$$7.Compare(projection$$1(x$$52), projection$$1(y$$20)) * -1;\n  });\n  xs$$98 = xs$$97;\n  return ofArray(xs$$98);\n}\nexport function sortWith(comparer$$9, xs$$99) {\n  let xs$$101;\n  const xs$$100 = ofList(xs$$99, Array);\n  xs$$100.sort(comparer$$9);\n  xs$$101 = xs$$100;\n  return ofArray(xs$$101);\n}\nexport function sum(xs$$102, adder) {\n  return fold(function (acc$$21, x$$53) {\n    return adder.Add(acc$$21, x$$53);\n  }, adder.GetZero(), xs$$102);\n}\nexport function sumBy(f$$53, xs$$103, adder$$1) {\n  return fold(function (acc$$22, x$$54) {\n    return adder$$1.Add(acc$$22, f$$53(x$$54));\n  }, adder$$1.GetZero(), xs$$103);\n}\nexport function maxBy(projection$$2, xs$$104, comparer$$11) {\n  return reduce(function (x$$55, y$$21) {\n    return comparer$$11.Compare(projection$$2(y$$21), projection$$2(x$$55)) > 0 ? y$$21 : x$$55;\n  }, xs$$104);\n}\nexport function max(li, comparer$$12) {\n  return reduce(function (x$$56, y$$22) {\n    return comparer$$12.Compare(y$$22, x$$56) > 0 ? y$$22 : x$$56;\n  }, li);\n}\nexport function minBy(projection$$3, xs$$105, comparer$$13) {\n  return reduce(function (x$$57, y$$23) {\n    return comparer$$13.Compare(projection$$3(y$$23), projection$$3(x$$57)) > 0 ? x$$57 : y$$23;\n  }, xs$$105);\n}\nexport function min(xs$$106, comparer$$14) {\n  return reduce(function (x$$58, y$$24) {\n    return comparer$$14.Compare(y$$24, x$$58) > 0 ? x$$58 : y$$24;\n  }, xs$$106);\n}\nexport function average(xs$$107, averager) {\n  const total = fold(function (acc$$23, x$$59) {\n    return averager.Add(acc$$23, x$$59);\n  }, averager.GetZero(), xs$$107);\n  return averager.DivideByInt(total, length(xs$$107));\n}\nexport function averageBy(f$$54, xs$$108, averager$$1) {\n  const total$$1 = fold(function (acc$$24, x$$60) {\n    return averager$$1.Add(acc$$24, f$$54(x$$60));\n  }, averager$$1.GetZero(), xs$$108);\n  return averager$$1.DivideByInt(total$$1, length(xs$$108));\n}\nexport function permute(f$$55, xs$$109) {\n  let xs$$110;\n  let array$$3;\n  array$$3 = ofList(xs$$109, Array);\n  xs$$110 = permute$$1(f$$55, array$$3);\n  return ofArray(xs$$110);\n}\nexport function chunkBySize(chunkSize, xs$$111) {\n  let xs$$114;\n  let xs$$112;\n  let array$$4;\n  array$$4 = ofList(xs$$111, Array);\n  xs$$112 = chunkBySize$$1(chunkSize, array$$4);\n  xs$$114 = ofArray(xs$$112);\n  return map(function f$$56(xs$$113) {\n    return ofArray(xs$$113);\n  }, xs$$114);\n}\nexport function skip(i$$16, xs$$115) {\n  const skipInner = function skipInner($i$$17$$240, $xs$$116$$241) {\n    skipInner: while (true) {\n      const i$$17 = $i$$17$$240,\n            xs$$116 = $xs$$116$$241;\n\n      if (i$$17 === 0) {\n        return xs$$116;\n      } else if (xs$$116.tail != null) {\n        $i$$17$$240 = i$$17 - 1;\n        $xs$$116$$241 = xs$$116.tail;\n        continue skipInner;\n      } else {\n        throw new Error(\"The input sequence has an insufficient number of elements.\");\n      }\n\n      break;\n    }\n  };\n\n  if (i$$16 < 0) {\n    throw new Error(\"The input must be non-negative.\");\n  } else {\n    var $target$$242, i$$20, xs$$119;\n\n    if (i$$16 === 0) {\n      $target$$242 = 0;\n    } else if (i$$16 === 1) {\n      if (xs$$115.tail != null) {\n        $target$$242 = 1;\n      } else {\n        $target$$242 = 2;\n        i$$20 = i$$16;\n        xs$$119 = xs$$115;\n      }\n    } else {\n      $target$$242 = 2;\n      i$$20 = i$$16;\n      xs$$119 = xs$$115;\n    }\n\n    switch ($target$$242) {\n      case 0:\n        {\n          return xs$$115;\n        }\n\n      case 1:\n        {\n          return xs$$115.tail;\n        }\n\n      case 2:\n        {\n          return skipInner(i$$20, xs$$119);\n        }\n    }\n  }\n}\nexport function skipWhile($predicate$$243, $xs$$120$$244) {\n  skipWhile: while (true) {\n    const predicate = $predicate$$243,\n          xs$$120 = $xs$$120$$244;\n    var $target$$245, h$$4, t$$4;\n\n    if (xs$$120.tail != null) {\n      if (predicate(xs$$120.head)) {\n        $target$$245 = 0;\n        h$$4 = xs$$120.head;\n        t$$4 = xs$$120.tail;\n      } else {\n        $target$$245 = 1;\n      }\n    } else {\n      $target$$245 = 1;\n    }\n\n    switch ($target$$245) {\n      case 0:\n        {\n          $predicate$$243 = predicate;\n          $xs$$120$$244 = t$$4;\n          continue skipWhile;\n        }\n\n      case 1:\n        {\n          return xs$$120;\n        }\n    }\n\n    break;\n  }\n}\nexport function takeSplitAux($error$$246, $i$$21$$247, $acc$$25$$248, $xs$$121$$249) {\n  takeSplitAux: while (true) {\n    const error = $error$$246,\n          i$$21 = $i$$21$$247,\n          acc$$25 = $acc$$25$$248,\n          xs$$121 = $xs$$121$$249;\n\n    if (i$$21 === 0) {\n      return [reverse(acc$$25), xs$$121];\n    } else if (xs$$121.tail != null) {\n      $error$$246 = error;\n      $i$$21$$247 = i$$21 - 1;\n      $acc$$25$$248 = new List(xs$$121.head, acc$$25);\n      $xs$$121$$249 = xs$$121.tail;\n      continue takeSplitAux;\n    } else {\n      if (error) {\n        throw new Error(\"The input sequence has an insufficient number of elements.\");\n      } else {\n        return [reverse(acc$$25), xs$$121];\n      }\n    }\n\n    break;\n  }\n}\nexport function take(i$$22, xs$$123) {\n  if (i$$22 < 0) {\n    throw new Error(\"The input must be non-negative.\");\n  } else {\n    var $target$$252, i$$25, xs$$124;\n\n    if (i$$22 === 0) {\n      $target$$252 = 0;\n    } else if (i$$22 === 1) {\n      if (xs$$123.tail != null) {\n        $target$$252 = 1;\n      } else {\n        $target$$252 = 2;\n        i$$25 = i$$22;\n        xs$$124 = xs$$123;\n      }\n    } else {\n      $target$$252 = 2;\n      i$$25 = i$$22;\n      xs$$124 = xs$$123;\n    }\n\n    switch ($target$$252) {\n      case 0:\n        {\n          return new List();\n        }\n\n      case 1:\n        {\n          return new List(xs$$123.head, new List());\n        }\n\n      case 2:\n        {\n          const tuple = takeSplitAux(true, i$$25, new List(), xs$$124);\n          return tuple[0];\n        }\n    }\n  }\n}\nexport function takeWhile(predicate$$1, xs$$125) {\n  if (xs$$125.tail != null) {\n    if (xs$$125.tail.tail == null) {\n      if (predicate$$1(xs$$125.head)) {\n        return xs$$125;\n      } else {\n        return xs$$125.tail;\n      }\n    } else {\n      if (!predicate$$1(xs$$125.head)) {\n        return new List();\n      } else {\n        return new List(xs$$125.head, takeWhile(predicate$$1, xs$$125.tail));\n      }\n    }\n  } else {\n    return xs$$125;\n  }\n}\nexport function truncate(i$$26, xs$$127) {\n  if (i$$26 < 0) {\n    throw new Error(\"The input must be non-negative.\");\n  } else {\n    var $target$$257, i$$29, xs$$128;\n\n    if (i$$26 === 0) {\n      $target$$257 = 0;\n    } else if (i$$26 === 1) {\n      if (xs$$127.tail != null) {\n        $target$$257 = 1;\n      } else {\n        $target$$257 = 2;\n        i$$29 = i$$26;\n        xs$$128 = xs$$127;\n      }\n    } else {\n      $target$$257 = 2;\n      i$$29 = i$$26;\n      xs$$128 = xs$$127;\n    }\n\n    switch ($target$$257) {\n      case 0:\n        {\n          return new List();\n        }\n\n      case 1:\n        {\n          return new List(xs$$127.head, new List());\n        }\n\n      case 2:\n        {\n          const tuple$$1 = takeSplitAux(false, i$$29, new List(), xs$$128);\n          return tuple$$1[0];\n        }\n    }\n  }\n}\nexport function splitAt(i$$30, xs$$129) {\n  if (i$$30 < 0) {\n    throw new Error(\"The input must be non-negative.\");\n  } else {\n    var $target$$260, i$$33, xs$$131;\n\n    if (i$$30 === 0) {\n      $target$$260 = 0;\n    } else if (i$$30 === 1) {\n      if (xs$$129.tail != null) {\n        $target$$260 = 1;\n      } else {\n        $target$$260 = 2;\n        i$$33 = i$$30;\n        xs$$131 = xs$$129;\n      }\n    } else {\n      $target$$260 = 2;\n      i$$33 = i$$30;\n      xs$$131 = xs$$129;\n    }\n\n    switch ($target$$260) {\n      case 0:\n        {\n          return [new List(), xs$$129];\n        }\n\n      case 1:\n        {\n          return [new List(xs$$129.head, new List()), xs$$129.tail];\n        }\n\n      case 2:\n        {\n          return takeSplitAux(true, i$$33, new List(), xs$$131);\n        }\n    }\n  }\n}\nexport function outOfRange() {\n  throw new Error(\"Index out of range\");\n}\nexport function slice(lower, upper, xs$$132) {\n  const lower$$1 = defaultArg(lower, 0) | 0;\n  const hasUpper = upper != null;\n\n  if (lower$$1 < 0) {\n    return outOfRange();\n  } else if (hasUpper ? upper < lower$$1 : false) {\n    return new List();\n  } else {\n    let lastIndex = -1 | 0;\n    let res$$2;\n    const state$$13 = new List();\n    res$$2 = foldIndexed(function f$$57(i$$34, acc$$26, x$$67) {\n      lastIndex = i$$34;\n\n      if (lower$$1 <= i$$34 ? !hasUpper ? true : i$$34 <= upper : false) {\n        return new List(x$$67, acc$$26);\n      } else {\n        return acc$$26;\n      }\n    }, state$$13, xs$$132);\n\n    if (lower$$1 > lastIndex + 1 ? true : hasUpper ? upper > lastIndex : false) {\n      outOfRange();\n    } else {\n      void null;\n    }\n\n    return reverse(res$$2);\n  }\n}\nexport function distinctBy(projection$$4, xs$$134, eq$$2) {\n  const hashSet = createMutable([], eq$$2);\n  return filter(function f$$58($arg$$1) {\n    const arg00$$1 = projection$$4($arg$$1);\n    return addToSet(arg00$$1, hashSet);\n  }, xs$$134);\n}\nexport function distinct(xs$$136, eq$$3) {\n  return distinctBy(function (x$$68) {\n    return x$$68;\n  }, xs$$136, eq$$3);\n}\nexport function exactlyOne(xs$$137) {\n  if (xs$$137.tail != null) {\n    if (xs$$137.tail.tail != null) {\n      throw new Error(\"Input list too long\\\\nParameter name: list\");\n    } else {\n      return xs$$137.head;\n    }\n  } else {\n    throw new Error(\"The input sequence was empty\\\\nParameter name: list\");\n  }\n}\nexport function groupBy(projection$$5, xs$$139, eq$$4) {\n  const dict = createMutable$$1([], eq$$4);\n  let keys = new List();\n  iterate(function f$$59(v$$2) {\n    const key = projection$$5(v$$2);\n    const matchValue$$16 = tryGetValue(dict, key, null);\n\n    if (matchValue$$16[0]) {\n      dict.set(key, new List(v$$2, matchValue$$16[1]));\n    } else {\n      addToDict(dict, key, new List(v$$2, new List()));\n      keys = new List(key, keys);\n    }\n  }, xs$$139);\n  let result$$1 = new List();\n  const xs$$141 = keys;\n  iterate(function f$$60(key$$1) {\n    result$$1 = new List([key$$1, reverse(getItemFromDict(dict, key$$1))], result$$1);\n  }, xs$$141);\n  return result$$1;\n}\nexport function countBy(projection$$6, xs$$142, eq$$5) {\n  const dict$$1 = createMutable$$1([], eq$$5);\n  let keys$$1 = new List();\n  iterate(function f$$61(v$$3) {\n    const key$$2 = projection$$6(v$$3);\n    const matchValue$$17 = tryGetValue(dict$$1, key$$2, 0);\n\n    if (matchValue$$17[0]) {\n      dict$$1.set(key$$2, matchValue$$17[1] + 1);\n    } else {\n      dict$$1.set(key$$2, 1);\n      keys$$1 = new List(key$$2, keys$$1);\n    }\n  }, xs$$142);\n  let result$$2 = new List();\n  const xs$$144 = keys$$1;\n  iterate(function f$$62(key$$3) {\n    result$$2 = new List([key$$3, getItemFromDict(dict$$1, key$$3)], result$$2);\n  }, xs$$144);\n  return result$$2;\n}\nexport function where(predicate$$2, source) {\n  return filter(predicate$$2, source);\n}\nexport function pairwise(source$$1) {\n  const xs$$145 = pairwise$$1(source$$1);\n  return ofSeq(xs$$145);\n}\nexport function windowed(windowSize, source$$2) {\n  if (windowSize <= 0) {\n    throw new Error(\"windowSize must be positive\");\n  } else {\n    void null;\n  }\n\n  let res$$3 = new List();\n\n  for (let i$$35 = length(source$$2); i$$35 >= windowSize; i$$35--) {\n    res$$3 = new List(slice(i$$35 - windowSize, i$$35 - 1, source$$2), res$$3);\n  }\n\n  return res$$3;\n}\nexport function splitInto(chunks, source$$3) {\n  let xs$$148;\n  let xs$$146;\n  let array$$5;\n  array$$5 = ofList(source$$3, Array);\n  xs$$146 = splitInto$$1(chunks, array$$5);\n  xs$$148 = ofArray(xs$$146);\n  return map(function f$$63(xs$$147) {\n    return ofArray(xs$$147);\n  }, xs$$148);\n}\nexport function transpose(lists$$1) {\n  let xs$$150;\n  let source$$5;\n  source$$5 = transpose$$1(lists$$1);\n  xs$$150 = map$$1(ofSeq, source$$5);\n  return ofSeq(xs$$150);\n}","import { BigInteger$$$op_Inequality$$56F059C0 as BigInteger$0024$0024$0024op_Inequality$0024$002456F059C0, BigInteger$$$op_Equality$$56F059C0 as BigInteger$0024$0024$0024op_Equality$0024$002456F059C0, BigInteger$$$op_GreaterThanOrEqual$$56F059C0 as BigInteger$0024$0024$0024op_GreaterThanOrEqual$0024$002456F059C0, BigInteger$$$op_GreaterThan$$56F059C0 as BigInteger$0024$0024$0024op_GreaterThan$0024$002456F059C0, BigInteger$$$op_LessThanOrEqual$$56F059C0 as BigInteger$0024$0024$0024op_LessThanOrEqual$0024$002456F059C0, BigInteger$$$op_LessThan$$56F059C0 as BigInteger$0024$0024$0024op_LessThan$0024$002456F059C0, BigInteger$$$op_ExclusiveOr$$56F059C0 as BigInteger$0024$0024$0024op_ExclusiveOr$0024$002456F059C0, BigInteger$$$op_BitwiseOr$$56F059C0 as BigInteger$0024$0024$0024op_BitwiseOr$0024$002456F059C0, BigInteger$$$op_BitwiseAnd$$56F059C0 as BigInteger$0024$0024$0024op_BitwiseAnd$0024$002456F059C0, BigInteger$$$op_LeftShift$$62E082A2 as BigInteger$0024$0024$0024op_LeftShift$0024$002462E082A2, BigInteger$$$op_RightShift$$62E082A2 as BigInteger$0024$0024$0024op_RightShift$0024$002462E082A2, BigInteger$$$op_UnaryPlus$$Z665282C2 as BigInteger$0024$0024$0024op_UnaryPlus$0024$0024Z665282C2, BigInteger$$$op_UnaryNegation$$Z665282C2 as BigInteger$0024$0024$0024op_UnaryNegation$0024$0024Z665282C2, BigInteger$$$op_Modulus$$56F059C0 as BigInteger$0024$0024$0024op_Modulus$0024$002456F059C0, BigInteger$$$op_Division$$56F059C0 as BigInteger$0024$0024$0024op_Division$0024$002456F059C0, BigInteger$$$op_Multiply$$56F059C0 as BigInteger$0024$0024$0024op_Multiply$0024$002456F059C0, BigInteger$$$op_Subtraction$$56F059C0 as BigInteger$0024$0024$0024op_Subtraction$0024$002456F059C0, BigInteger$$$op_Addition$$56F059C0 as BigInteger$0024$0024$0024op_Addition$0024$002456F059C0, BigInteger$$get_IsOne as BigInteger$0024$0024get_IsOne, BigInteger$$get_IsZero as BigInteger$0024$0024get_IsZero, BigInteger$$get_Sign as BigInteger$0024$0024get_Sign, BigInteger$$get_ToDecimal as BigInteger$0024$0024get_ToDecimal, BigInteger$$get_ToDouble as BigInteger$0024$0024get_ToDouble, BigInteger$$get_ToSingle as BigInteger$0024$0024get_ToSingle, BigInteger$$get_ToUInt64 as BigInteger$0024$0024get_ToUInt64, BigInteger$$get_ToInt64 as BigInteger$0024$0024get_ToInt64, BigInteger$$get_ToUInt32 as BigInteger$0024$0024get_ToUInt32, BigInteger$$get_ToInt32 as BigInteger$0024$0024get_ToInt32, BigInteger$$get_ToUInt16 as BigInteger$0024$0024get_ToUInt16, BigInteger$$get_ToInt16 as BigInteger$0024$0024get_ToInt16, BigInteger$$get_ToByte as BigInteger$0024$0024get_ToByte, BigInteger$$get_ToSByte as BigInteger$0024$0024get_ToSByte, BigInteger$$$$002Ector$$Z524259A4 as BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259A4, BigInteger$$$$002Ector$$Z524259C1 as BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259C1, BigInteger$$$get_Two as BigInteger$0024$0024$0024get_Two, BigInteger$$$get_One as BigInteger$0024$0024$0024get_One, BigInteger$$$Abs$$Z665282C2 as BigInteger$0024$0024$0024Abs$0024$0024Z665282C2, BigInteger$$$Pow$$62E082A2 as BigInteger$0024$0024$0024Pow$0024$002462E082A2, BigInteger$$$GreatestCommonDivisor$$56F059C0 as BigInteger$0024$0024$0024GreatestCommonDivisor$0024$002456F059C0, BigInteger$$$DivRem$$56F059C0 as BigInteger$0024$0024$0024DivRem$0024$002456F059C0, BigInteger$$$Parse$$Z721C83C5 as BigInteger$0024$0024$0024Parse$0024$0024Z721C83C5, BigInteger$$$get_Zero as BigInteger$0024$0024$0024get_Zero, BigInteger } from \"./BigInt/z\";\nimport { fromInteger } from \"./Long.js\";\nimport { min, comparePrimitives, equals as equals$$1, structuralHash } from \"./Util.js\";\nimport { delay, unfold, rangeNumber } from \"./Seq.js\";\nimport { fold, head, skipWhile, find, ofSeq } from \"./List.js\";\nimport { List } from \"./Types.js\";\nimport { fill, reverse, ofList } from \"./Array.js\";\nexport function isBigInt(x) {\n  return x instanceof BigInteger;\n}\nexport function tryParse(str) {\n  try {\n    const res = BigInteger$0024$0024$0024Parse$0024$0024Z721C83C5(str);\n    return [true, res];\n  } catch (matchValue) {\n    return [false, BigInteger$0024$0024$0024get_Zero()];\n  }\n}\nexport function parse(arg00) {\n  return BigInteger$0024$0024$0024Parse$0024$0024Z721C83C5(arg00);\n}\nexport function divRem(arg00$$1, arg01) {\n  return BigInteger$0024$0024$0024DivRem$0024$002456F059C0(arg00$$1, arg01);\n}\nexport function greatestCommonDivisor(arg00$$2, arg01$$1) {\n  return BigInteger$0024$0024$0024GreatestCommonDivisor$0024$002456F059C0(arg00$$2, arg01$$1);\n}\nexport function pow(arg00$$3, arg01$$2) {\n  return BigInteger$0024$0024$0024Pow$0024$002462E082A2(arg00$$3, arg01$$2);\n}\nexport function abs(arg00$$4) {\n  return BigInteger$0024$0024$0024Abs$0024$0024Z665282C2(arg00$$4);\n}\nexport const zero = BigInteger$0024$0024$0024get_Zero();\nexport const one = BigInteger$0024$0024$0024get_One();\nexport const two = BigInteger$0024$0024$0024get_Two();\nexport function fromString(s) {\n  return BigInteger$0024$0024$0024Parse$0024$0024Z721C83C5(s);\n}\nexport function fromZero() {\n  return BigInteger$0024$0024$0024get_Zero();\n}\nexport function fromOne() {\n  return BigInteger$0024$0024$0024get_One();\n}\nexport function fromInt64(i) {\n  return BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259C1(i);\n}\nexport function fromInt32(i$$1) {\n  var value;\n\n  if (i$$1 > 2147483647) {\n    return BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259C1((value = i$$1, (fromInteger(value, false, 6))));\n  } else {\n    return BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259A4(i$$1);\n  }\n}\nexport function toSByte(x$$1) {\n  return BigInteger$0024$0024get_ToSByte(x$$1);\n}\nexport function toByte(x$$2) {\n  return BigInteger$0024$0024get_ToByte(x$$2);\n}\nexport function toInt16(x$$3) {\n  return BigInteger$0024$0024get_ToInt16(x$$3);\n}\nexport function toUInt16(x$$4) {\n  return BigInteger$0024$0024get_ToUInt16(x$$4);\n}\nexport function toInt32(x$$5) {\n  return BigInteger$0024$0024get_ToInt32(x$$5);\n}\nexport function toUInt32(x$$6) {\n  return BigInteger$0024$0024get_ToUInt32(x$$6);\n}\nexport function toInt64(x$$7) {\n  return BigInteger$0024$0024get_ToInt64(x$$7);\n}\nexport function toUInt64(x$$8) {\n  return BigInteger$0024$0024get_ToUInt64(x$$8);\n}\nexport function toSingle(x$$9) {\n  return BigInteger$0024$0024get_ToSingle(x$$9);\n}\nexport function toDouble(x$$10) {\n  return BigInteger$0024$0024get_ToDouble(x$$10);\n}\nexport function toDecimal(x$$11) {\n  return BigInteger$0024$0024get_ToDecimal(x$$11);\n}\nexport function sign(x$$12) {\n  return BigInteger$0024$0024get_Sign(x$$12);\n}\nexport function isZero(x$$13) {\n  return BigInteger$0024$0024get_IsZero(x$$13);\n}\nexport function isOne(x$$14) {\n  return BigInteger$0024$0024get_IsOne(x$$14);\n}\nexport function hash(x$$15) {\n  return structuralHash(x$$15);\n}\nexport function compare(x$$16, y) {\n  return x$$16.CompareTo(y);\n}\nexport function equals(x$$17, y$$1) {\n  return equals$$1(x$$17, y$$1);\n}\nexport function toString(x$$18) {\n  return String(x$$18);\n}\nexport const get_Zero = BigInteger$0024$0024$0024get_Zero();\nexport const get_One = BigInteger$0024$0024$0024get_One();\nexport function op_Addition(arg00$$5, arg01$$3) {\n  return BigInteger$0024$0024$0024op_Addition$0024$002456F059C0(arg00$$5, arg01$$3);\n}\nexport function op_Subtraction(arg00$$6, arg01$$4) {\n  return BigInteger$0024$0024$0024op_Subtraction$0024$002456F059C0(arg00$$6, arg01$$4);\n}\nexport function op_Multiply(arg00$$7, arg01$$5) {\n  return BigInteger$0024$0024$0024op_Multiply$0024$002456F059C0(arg00$$7, arg01$$5);\n}\nexport function op_Division(arg00$$8, arg01$$6) {\n  return BigInteger$0024$0024$0024op_Division$0024$002456F059C0(arg00$$8, arg01$$6);\n}\nexport function op_Modulus(arg00$$9, arg01$$7) {\n  return BigInteger$0024$0024$0024op_Modulus$0024$002456F059C0(arg00$$9, arg01$$7);\n}\nexport function op_UnaryNegation(arg00$$10) {\n  return BigInteger$0024$0024$0024op_UnaryNegation$0024$0024Z665282C2(arg00$$10);\n}\nexport function op_UnaryPlus(arg00$$11) {\n  return BigInteger$0024$0024$0024op_UnaryPlus$0024$0024Z665282C2(arg00$$11);\n}\nexport function op_RightShift(arg00$$12, arg01$$8) {\n  return BigInteger$0024$0024$0024op_RightShift$0024$002462E082A2(arg00$$12, arg01$$8);\n}\nexport function op_LeftShift(arg00$$13, arg01$$9) {\n  return BigInteger$0024$0024$0024op_LeftShift$0024$002462E082A2(arg00$$13, arg01$$9);\n}\nexport function op_BitwiseAnd(arg00$$14, arg01$$10) {\n  return BigInteger$0024$0024$0024op_BitwiseAnd$0024$002456F059C0(arg00$$14, arg01$$10);\n}\nexport function op_BitwiseOr(arg00$$15, arg01$$11) {\n  return BigInteger$0024$0024$0024op_BitwiseOr$0024$002456F059C0(arg00$$15, arg01$$11);\n}\nexport function op_ExclusiveOr(arg00$$16, arg01$$12) {\n  return BigInteger$0024$0024$0024op_ExclusiveOr$0024$002456F059C0(arg00$$16, arg01$$12);\n}\nexport function op_LessThan(arg00$$17, arg01$$13) {\n  return BigInteger$0024$0024$0024op_LessThan$0024$002456F059C0(arg00$$17, arg01$$13);\n}\nexport function op_LessThanOrEqual(arg00$$18, arg01$$14) {\n  return BigInteger$0024$0024$0024op_LessThanOrEqual$0024$002456F059C0(arg00$$18, arg01$$14);\n}\nexport function op_GreaterThan(arg00$$19, arg01$$15) {\n  return BigInteger$0024$0024$0024op_GreaterThan$0024$002456F059C0(arg00$$19, arg01$$15);\n}\nexport function op_GreaterThanOrEqual(arg00$$20, arg01$$16) {\n  return BigInteger$0024$0024$0024op_GreaterThanOrEqual$0024$002456F059C0(arg00$$20, arg01$$16);\n}\nexport function op_Equality(arg00$$21, arg01$$17) {\n  return BigInteger$0024$0024$0024op_Equality$0024$002456F059C0(arg00$$21, arg01$$17);\n}\nexport function op_Inequality(arg00$$22, arg01$$18) {\n  return BigInteger$0024$0024$0024op_Inequality$0024$002456F059C0(arg00$$22, arg01$$18);\n}\n\nfunction flipTwosComplement(currByte, lowBitFound) {\n  if (lowBitFound) {\n    return [(currByte ^ 255) & 255, true];\n  } else if (currByte === 0) {\n    return [0, false];\n  } else {\n    let firstBitIndex;\n    const list = ofSeq(rangeNumber(0, 1, 7));\n    firstBitIndex = find(function predicate(i$$2) {\n      return (currByte & 1 << i$$2) > 0;\n    }, list);\n    return [(currByte ^ 254 << firstBitIndex) & 255, true];\n  }\n}\n\nexport function toByteArray(value$$1) {\n  if (equals$$1(value$$1, zero)) {\n    return new Uint8Array([0]);\n  } else {\n    const isPositive = value$$1.CompareTo(zero) > 0;\n    const value$$2 = isPositive ? value$$1 : BigInteger$0024$0024$0024op_Multiply$0024$002456F059C0(BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259A4(-1), value$$1);\n    let mask32;\n    let i$$3;\n    i$$3 = fromInteger(4294967295, false, 6);\n    mask32 = fromInt64(i$$3);\n\n    const loop = function loop($accumBytes$$74, $consumeValue$$75, $lowBitFound$$1$$76) {\n      var value$$9, value$$10, value$$11;\n\n      loop: while (true) {\n        const accumBytes = $accumBytes$$74,\n              consumeValue = $consumeValue$$75,\n              lowBitFound$$1 = $lowBitFound$$1$$76;\n\n        if (consumeValue.CompareTo(zero) <= 0) {\n          let accumBytes$$1;\n\n          if (isPositive) {\n            accumBytes$$1 = skipWhile(function predicate$$1(b) {\n              return b === 0;\n            }, accumBytes);\n          } else {\n            accumBytes$$1 = skipWhile(function predicate$$2(b$$1) {\n              return b$$1 === 255;\n            }, accumBytes);\n          }\n\n          const isHighBitOne = (head(accumBytes$$1) & 128) !== 0;\n          const accumBytes$$2 = (isPositive ? isHighBitOne : false) ? new List(0, accumBytes$$1) : (!isPositive ? !isHighBitOne : false) ? new List(255, accumBytes$$1) : accumBytes$$1;\n          let array;\n          array = ofList(accumBytes$$2, Uint8Array);\n          return reverse(array, Uint8Array);\n        } else {\n          let currValue;\n          const x$$19 = BigInteger$0024$0024$0024op_BitwiseAnd$0024$002456F059C0(consumeValue, mask32);\n          currValue = toUInt32(x$$19);\n\n          if (isPositive) {\n            let b0;\n            b0 = currValue & 0xFF;\n            let b1;\n            const value$$5 = currValue >>> 8;\n            b1 = value$$5 & 0xFF;\n            let b2;\n            const value$$6 = currValue >>> 16;\n            b2 = value$$6 & 0xFF;\n            let b3;\n            const value$$7 = currValue >>> 24;\n            b3 = value$$7 & 0xFF;\n            $accumBytes$$74 = new List(b3, new List(b2, new List(b1, new List(b0, accumBytes))));\n            $consumeValue$$75 = BigInteger$0024$0024$0024op_RightShift$0024$002462E082A2(consumeValue, 32);\n            $lowBitFound$$1$$76 = false;\n            continue loop;\n          } else {\n            const patternInput = flipTwosComplement((currValue & 0xFF), lowBitFound$$1);\n            const patternInput$$1 = flipTwosComplement((value$$9 = currValue >>> 8, (value$$9 & 0xFF)), patternInput[1]);\n            const patternInput$$2 = flipTwosComplement((value$$10 = currValue >>> 16, (value$$10 & 0xFF)), patternInput$$1[1]);\n            const patternInput$$3 = flipTwosComplement((value$$11 = currValue >>> 24, (value$$11 & 0xFF)), patternInput$$2[1]);\n            $accumBytes$$74 = new List(patternInput$$3[0], new List(patternInput$$2[0], new List(patternInput$$1[0], new List(patternInput[0], accumBytes))));\n            $consumeValue$$75 = BigInteger$0024$0024$0024op_RightShift$0024$002462E082A2(consumeValue, 32);\n            $lowBitFound$$1$$76 = patternInput$$3[1];\n            continue loop;\n          }\n        }\n\n        break;\n      }\n    };\n\n    return loop(new List(), value$$2, false);\n  }\n}\nexport function fromByteArray(bytes) {\n  if (bytes == null) {\n    throw new Error(\"bytes\");\n  } else {\n    void null;\n  }\n\n  if (bytes.length === 0) {\n    return zero;\n  } else {\n    const isPositive$$1 = (bytes[bytes.length - 1] & 128) === 0;\n    const buffer = fill(new Uint8Array(4), 0, 4, 0);\n\n    const loop$$1 = function loop$$1($accumUInt32$$80, $currIndex$$81, $bytesRemaining$$82, $lowBitFound$$6$$83) {\n      loop$$1: while (true) {\n        const accumUInt32 = $accumUInt32$$80,\n              currIndex = $currIndex$$81,\n              bytesRemaining = $bytesRemaining$$82,\n              lowBitFound$$6 = $lowBitFound$$6$$83;\n\n        if (bytesRemaining === 0) {\n          let value$$14;\n          value$$14 = fold(function folder(acc, value$$12) {\n            var i$$4;\n            return BigInteger$0024$0024$0024op_Addition$0024$002456F059C0(BigInteger$0024$0024$0024op_LeftShift$0024$002462E082A2(acc, 32), (i$$4 = (fromInteger(value$$12, false, 6)), (fromInt64(i$$4))));\n          }, zero, accumUInt32);\n\n          if (isPositive$$1) {\n            return value$$14;\n          } else {\n            return BigInteger$0024$0024$0024op_Multiply$0024$002456F059C0(BigInteger$0024$0024$0024$0024002Ector$0024$0024Z524259A4(-1), value$$14);\n          }\n        } else {\n          const bytesToProcess = min(comparePrimitives, bytesRemaining, 4) | 0;\n\n          for (let i$$5 = 0; i$$5 <= bytesToProcess - 1; i$$5++) {\n            buffer[i$$5] = bytes[currIndex + i$$5];\n          }\n\n          if (isPositive$$1) {\n            fill(buffer, bytesToProcess, 4 - bytesToProcess, 0);\n            const value$$15 = (((buffer[0] | buffer[1] << 8 >>> 0) >>> 0 | buffer[2] << 16 >>> 0) >>> 0 | buffer[3] << 24 >>> 0) >>> 0;\n            $accumUInt32$$80 = new List(value$$15, accumUInt32);\n            $currIndex$$81 = currIndex + bytesToProcess;\n            $bytesRemaining$$82 = bytesRemaining - bytesToProcess;\n            $lowBitFound$$6$$83 = false;\n            continue loop$$1;\n          } else {\n            fill(buffer, bytesToProcess, 4 - bytesToProcess, 255);\n            const patternInput$$4 = flipTwosComplement(buffer[0], lowBitFound$$6);\n            const patternInput$$5 = flipTwosComplement(buffer[1], patternInput$$4[1]);\n            const patternInput$$6 = flipTwosComplement(buffer[2], patternInput$$5[1]);\n            const patternInput$$7 = flipTwosComplement(buffer[3], patternInput$$6[1]);\n            const value$$16 = (((patternInput$$4[0] | patternInput$$5[0] << 8 >>> 0) >>> 0 | patternInput$$6[0] << 16 >>> 0) >>> 0 | patternInput$$7[0] << 24 >>> 0) >>> 0;\n            $accumUInt32$$80 = new List(value$$16, accumUInt32);\n            $currIndex$$81 = currIndex + bytesToProcess;\n            $bytesRemaining$$82 = bytesRemaining - bytesToProcess;\n            $lowBitFound$$6$$83 = patternInput$$7[1];\n            continue loop$$1;\n          }\n        }\n\n        break;\n      }\n    };\n\n    return loop$$1(new List(), 0, bytes.length, false);\n  }\n}\nexport function makeRangeStepFunction(step, last) {\n  const stepComparedWithZero = step.CompareTo(zero) | 0;\n\n  if (stepComparedWithZero === 0) {\n    throw new Error(\"The step of a range cannot be zero\");\n  } else {\n    void null;\n  }\n\n  const stepGreaterThanZero = stepComparedWithZero > 0;\n  return function (x$$20) {\n    const comparedWithLast = x$$20.CompareTo(last) | 0;\n    return ((stepGreaterThanZero ? comparedWithLast <= 0 : false) ? true : !stepGreaterThanZero ? comparedWithLast >= 0 : false) ? [x$$20, BigInteger$0024$0024$0024op_Addition$0024$002456F059C0(x$$20, step)] : undefined;\n  };\n}\nexport function range(first, step$$1, last$$1) {\n  const stepFn = makeRangeStepFunction(step$$1, last$$1);\n  return delay(function () {\n    return unfold(stepFn, first);\n  });\n}","/**\n * DateTimeOffset functions.\n *\n * Note: DateOffset instances are always DateObjects in local\n * timezone (because JS dates are all kinds of messed up).\n * A local date returns UTC epoc when `.getTime()` is called.\n *\n * However, this means that in order to construct an UTC date\n * from a DateOffset with offset of +5 hours, you first need\n * to subtract those 5 hours, than add the \"local\" offset.\n * As said, all kinds of messed up.\n *\n * Basically; invariant: date.getTime() always return UTC time.\n */\nimport { create as createDate, dateOffsetToString, daysInMonth, offsetRegex, parseRaw } from \"./Date\";\nimport { fromValue, ticksToUnixEpochMilliseconds, unixEpochMillisecondsToTicks } from \"./Long\";\nimport { compareDates, padWithZeros } from \"./Util\";\nexport default function DateTimeOffset(value, offset) {\n    const d = new Date(value);\n    d.offset = offset != null ? offset : new Date().getTimezoneOffset() * -60000;\n    return d;\n}\nexport function fromDate(date, offset) {\n    const isUtc = date.kind === 1 /* UTC */;\n    const offset2 = isUtc ? 0 : date.getTimezoneOffset() * -60000;\n    if (offset != null && offset !== offset2) {\n        throw new Error(isUtc\n            ? \"The UTC Offset for Utc DateTime instances must be 0.\"\n            : \"The UTC Offset of the local dateTime parameter does not match the offset argument.\");\n    }\n    return DateTimeOffset(date.getTime(), offset2);\n}\nexport function fromTicks(ticks, offset) {\n    ticks = fromValue(ticks);\n    const epoc = ticksToUnixEpochMilliseconds(ticks) - offset;\n    return DateTimeOffset(epoc, offset);\n}\nexport function getUtcTicks(date) {\n    return unixEpochMillisecondsToTicks(date.getTime(), 0);\n}\nexport function minValue() {\n    // This is \"0001-01-01T00:00:00.000Z\", actual JS min value is -8640000000000000\n    return DateTimeOffset(-62135596800000, 0);\n}\nexport function maxValue() {\n    // This is \"9999-12-31T23:59:59.999Z\", actual JS max value is 8640000000000000\n    return DateTimeOffset(253402300799999, 0);\n}\nexport function parse(str) {\n    const date = parseRaw(str);\n    const offsetMatch = offsetRegex.exec(str);\n    const offset = offsetMatch == null\n        ? date.getTimezoneOffset() * -60000\n        : (offsetMatch[0] === \"Z\"\n            ? 0\n            : parseInt(offsetMatch[1], 10) * 3600000\n                + parseInt(offsetMatch[2], 10) * 60000);\n    return DateTimeOffset(date.getTime(), offset);\n}\nexport function tryParse(v, _refValue) {\n    try {\n        return [true, parse(v)];\n    }\n    catch (_err) {\n        return [false, minValue()];\n    }\n}\nexport function create(year, month, day, h, m, s, ms, offset) {\n    if (offset == null) {\n        offset = ms;\n        ms = 0;\n    }\n    if (offset !== 0) {\n        if (offset % 60000 !== 0) {\n            throw new Error(\"Offset must be specified in whole minutes\");\n        }\n        if (~~(offset / 3600000) > 14) {\n            throw new Error(\"Offset must be within plus or minus 14 hour\");\n        }\n    }\n    let date;\n    if (offset === 0) {\n        date = new Date(Date.UTC(year, month - 1, day, h, m, s, ms));\n        if (year <= 99) {\n            date.setFullYear(year, month - 1, day);\n        }\n    }\n    else {\n        const str = padWithZeros(year, 4) + \"-\" +\n            padWithZeros(month, 2) + \"-\" +\n            padWithZeros(day, 2) + \"T\" +\n            padWithZeros(h, 2) + \":\" +\n            padWithZeros(m, 2) + \":\" +\n            padWithZeros(s, 2) + \".\" +\n            padWithZeros(ms, 3) +\n            dateOffsetToString(offset);\n        date = new Date(str);\n    }\n    const dateValue = date.getTime();\n    if (isNaN(dateValue)) {\n        throw new Error(\"The parameters describe an unrepresentable Date\");\n    }\n    return DateTimeOffset(dateValue, offset);\n}\nexport function now() {\n    const date = new Date();\n    const offset = date.getTimezoneOffset() * -60000;\n    return DateTimeOffset(date.getTime(), offset);\n}\nexport function utcNow() {\n    const date = now();\n    return DateTimeOffset(date.getTime(), 0);\n}\nexport function toUniversalTime(date) {\n    return DateTimeOffset(date.getTime(), 0);\n}\nexport function toLocalTime(date) {\n    return DateTimeOffset(date.getTime(), date.getTimezoneOffset() * -60000);\n}\nexport function timeOfDay(d) {\n    var _a;\n    const d2 = new Date(d.getTime() + ((_a = d.offset) !== null && _a !== void 0 ? _a : 0));\n    return d2.getUTCHours() * 3600000\n        + d2.getUTCMinutes() * 60000\n        + d2.getUTCSeconds() * 1000\n        + d2.getUTCMilliseconds();\n}\nexport function date(d) {\n    var _a;\n    const d2 = new Date(d.getTime() + ((_a = d.offset) !== null && _a !== void 0 ? _a : 0));\n    return createDate(d2.getUTCFullYear(), d2.getUTCMonth() + 1, d2.getUTCDate(), 0, 0, 0, 0);\n}\nexport function day(d) {\n    var _a;\n    return new Date(d.getTime() + ((_a = d.offset) !== null && _a !== void 0 ? _a : 0)).getUTCDate();\n}\nexport function hour(d) {\n    var _a;\n    return new Date(d.getTime() + ((_a = d.offset) !== null && _a !== void 0 ? _a : 0)).getUTCHours();\n}\nexport function millisecond(d) {\n    var _a;\n    return new Date(d.getTime() + ((_a = d.offset) !== null && _a !== void 0 ? _a : 0)).getUTCMilliseconds();\n}\nexport function minute(d) {\n    var _a;\n    return new Date(d.getTime() + ((_a = d.offset) !== null && _a !== void 0 ? _a : 0)).getUTCMinutes();\n}\nexport function month(d) {\n    var _a;\n    return new Date(d.getTime() + ((_a = d.offset) !== null && _a !== void 0 ? _a : 0)).getUTCMonth() + 1;\n}\nexport function second(d) {\n    var _a;\n    return new Date(d.getTime() + ((_a = d.offset) !== null && _a !== void 0 ? _a : 0)).getUTCSeconds();\n}\nexport function year(d) {\n    var _a;\n    return new Date(d.getTime() + ((_a = d.offset) !== null && _a !== void 0 ? _a : 0)).getUTCFullYear();\n}\nexport function dayOfWeek(d) {\n    var _a;\n    return new Date(d.getTime() + ((_a = d.offset) !== null && _a !== void 0 ? _a : 0)).getUTCDay();\n}\nexport function dayOfYear(d) {\n    var _a;\n    const d2 = new Date(d.getTime() + ((_a = d.offset) !== null && _a !== void 0 ? _a : 0));\n    const _year = d2.getUTCFullYear();\n    const _month = d2.getUTCMonth() + 1;\n    let _day = d2.getUTCDate();\n    for (let i = 1; i < _month; i++) {\n        _day += daysInMonth(_year, i);\n    }\n    return _day;\n}\nexport function add(d, ts) {\n    var _a;\n    return DateTimeOffset(d.getTime() + ts, ((_a = d.offset) !== null && _a !== void 0 ? _a : 0));\n}\nexport function addDays(d, v) {\n    var _a;\n    return DateTimeOffset(d.getTime() + v * 86400000, ((_a = d.offset) !== null && _a !== void 0 ? _a : 0));\n}\nexport function addHours(d, v) {\n    var _a;\n    return DateTimeOffset(d.getTime() + v * 3600000, ((_a = d.offset) !== null && _a !== void 0 ? _a : 0));\n}\nexport function addMinutes(d, v) {\n    var _a;\n    return DateTimeOffset(d.getTime() + v * 60000, ((_a = d.offset) !== null && _a !== void 0 ? _a : 0));\n}\nexport function addSeconds(d, v) {\n    var _a;\n    return DateTimeOffset(d.getTime() + v * 1000, ((_a = d.offset) !== null && _a !== void 0 ? _a : 0));\n}\nexport function addMilliseconds(d, v) {\n    var _a;\n    return DateTimeOffset(d.getTime() + v, ((_a = d.offset) !== null && _a !== void 0 ? _a : 0));\n}\nexport function addYears(d, v) {\n    var _a;\n    const newMonth = d.getUTCMonth() + 1;\n    const newYear = d.getUTCFullYear() + v;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, d.getUTCDate());\n    return create(newYear, newMonth, newDay, d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds(), ((_a = d.offset) !== null && _a !== void 0 ? _a : 0));\n}\nexport function addMonths(d, v) {\n    var _a, _b;\n    const d2 = new Date(d.getTime() + ((_a = d.offset) !== null && _a !== void 0 ? _a : 0));\n    let newMonth = d2.getUTCMonth() + 1 + v;\n    let newMonth_ = 0;\n    let yearOffset = 0;\n    if (newMonth > 12) {\n        newMonth_ = newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12);\n        newMonth = newMonth_;\n    }\n    else if (newMonth < 1) {\n        newMonth_ = 12 + newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12) + (newMonth_ === 12 ? -1 : 0);\n        newMonth = newMonth_;\n    }\n    const newYear = d2.getUTCFullYear() + yearOffset;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, d2.getUTCDate());\n    return create(newYear, newMonth, newDay, d2.getUTCHours(), d2.getUTCMinutes(), d2.getUTCSeconds(), d2.getUTCMilliseconds(), ((_b = d.offset) !== null && _b !== void 0 ? _b : 0));\n}\nexport function subtract(d, that) {\n    var _a;\n    return typeof that === \"number\"\n        ? DateTimeOffset(d.getTime() - that, ((_a = d.offset) !== null && _a !== void 0 ? _a : 0))\n        : d.getTime() - that.getTime();\n}\nexport function equals(d1, d2) {\n    return d1.getTime() === d2.getTime();\n}\nexport function equalsExact(d1, d2) {\n    return d1.getTime() === d2.getTime() && d1.offset === d2.offset;\n}\nexport function compare(d1, d2) {\n    return compareDates(d1, d2);\n}\nexport const compareTo = compare;\nexport function op_Addition(x, y) {\n    return add(x, y);\n}\nexport function op_Subtraction(x, y) {\n    return subtract(x, y);\n}\n//# sourceMappingURL=DateOffset.js.map","// tslint:disable:max-line-length\nimport { fromNumber, op_Division, op_Multiply, toNumber } from \"./Long\";\nimport { comparePrimitives, padLeftAndRightWithZeros, padWithZeros } from \"./Util\";\n// TimeSpan in runtime just becomes a number representing milliseconds\n/**\n * Calls:\n * - `Math.ceil` if the `value` is **negative**\n * - `Math.floor` if the `value` is **positive**\n * @param value Value to round\n */\nfunction signedRound(value) {\n    return value < 0 ? Math.ceil(value) : Math.floor(value);\n}\nexport function create(d = 0, h = 0, m = 0, s = 0, ms = 0) {\n    switch (arguments.length) {\n        case 1:\n            // ticks\n            return fromTicks(arguments[0]);\n        case 3:\n            // h,m,s\n            d = 0, h = arguments[0], m = arguments[1], s = arguments[2], ms = 0;\n            break;\n        default:\n            // d,h,m,s,ms\n            break;\n    }\n    return d * 86400000 + h * 3600000 + m * 60000 + s * 1000 + ms;\n}\nexport function fromTicks(ticks) {\n    return toNumber(op_Division(ticks, 10000));\n}\nexport function fromDays(d) {\n    return create(d, 0, 0, 0);\n}\nexport function fromHours(h) {\n    return create(h, 0, 0);\n}\nexport function fromMinutes(m) {\n    return create(0, m, 0);\n}\nexport function fromSeconds(s) {\n    return create(0, 0, s);\n}\nexport function days(ts) {\n    return signedRound(ts / 86400000);\n}\nexport function hours(ts) {\n    return signedRound(ts % 86400000 / 3600000);\n}\nexport function minutes(ts) {\n    return signedRound(ts % 3600000 / 60000);\n}\nexport function seconds(ts) {\n    return signedRound(ts % 60000 / 1000);\n}\nexport function milliseconds(ts) {\n    return signedRound(ts % 1000);\n}\nexport function ticks(ts) {\n    return op_Multiply(fromNumber(ts), 10000);\n}\nexport function totalDays(ts) {\n    return ts / 86400000;\n}\nexport function totalHours(ts) {\n    return ts / 3600000;\n}\nexport function totalMinutes(ts) {\n    return ts / 60000;\n}\nexport function totalSeconds(ts) {\n    return ts / 1000;\n}\nexport function negate(ts) {\n    return ts * -1;\n}\nexport function add(ts1, ts2) {\n    return ts1 + ts2;\n}\nexport function subtract(ts1, ts2) {\n    return ts1 - ts2;\n}\nexport const op_Addition = add;\nexport const op_Subtraction = subtract;\nexport const compare = comparePrimitives;\nexport const compareTo = comparePrimitives;\nexport function duration(x) {\n    return Math.abs(x);\n}\nexport function toString(ts, format = \"c\", _provider) {\n    if ([\"c\", \"g\", \"G\"].indexOf(format) === -1) {\n        throw new Error(\"Custom formats are not supported\");\n    }\n    const d = Math.abs(days(ts));\n    const h = Math.abs(hours(ts));\n    const m = Math.abs(minutes(ts));\n    const s = Math.abs(seconds(ts));\n    const ms = Math.abs(milliseconds(ts));\n    const sign = ts < 0 ? \"-\" : \"\";\n    return `${sign}${d === 0 && (format === \"c\" || format === \"g\") ? \"\" : format === \"c\" ? d + \".\" : d + \":\"}${format === \"g\" ? h : padWithZeros(h, 2)}:${padWithZeros(m, 2)}:${padWithZeros(s, 2)}${ms === 0 && (format === \"c\" || format === \"g\") ? \"\" : format === \"g\" ? \".\" + padWithZeros(ms, 3) : \".\" + padLeftAndRightWithZeros(ms, 3, 7)}`;\n}\nexport function parse(str) {\n    const firstDot = str.search(\"\\\\.\");\n    const firstColon = str.search(\"\\\\:\");\n    if (firstDot === -1 && firstColon === -1) { // There is only a day ex: 4\n        const d = parseInt(str, 0);\n        if (isNaN(d)) {\n            throw new Error(`String '${str}' was not recognized as a valid TimeSpan.`);\n        }\n        else {\n            return create(d, 0, 0, 0, 0);\n        }\n    }\n    if (firstColon > 0) { // process time part\n        // WIP: (-?)(((\\d+)\\.)?([0-9]|0[0-9]|1[0-9]|2[0-3]):(\\d+)(:\\d+(\\.\\d{1,7})?)?|\\d+(?:(?!\\.)))\n        const r = /^(-?)((\\d+)\\.)?(?:0*)([0-9]|0[0-9]|1[0-9]|2[0-3]):(?:0*)([0-5][0-9]|[0-9])(:(?:0*)([0-5][0-9]|[0-9]))?\\.?(\\d+)?$/.exec(str);\n        if (r != null && r[4] != null && r[5] != null) {\n            let d = 0;\n            let ms = 0;\n            let s = 0;\n            const sign = r[1] != null && r[1] === \"-\" ? -1 : 1;\n            const h = +r[4];\n            const m = +r[5];\n            if (r[3] != null) {\n                d = +r[3];\n            }\n            if (r[7] != null) {\n                s = +r[7];\n            }\n            if (r[8] != null) {\n                // Depending on the number of decimals passed, we need to adapt the numbers\n                switch (r[8].length) {\n                    case 1:\n                        ms = +r[8] * 100;\n                        break;\n                    case 2:\n                        ms = +r[8] * 10;\n                        break;\n                    case 3:\n                        ms = +r[8];\n                        break;\n                    case 4:\n                        ms = +r[8] / 10;\n                        break;\n                    case 5:\n                        ms = +r[8] / 100;\n                        break;\n                    case 6:\n                        ms = +r[8] / 1000;\n                        break;\n                    case 7:\n                        ms = +r[8] / 10000;\n                        break;\n                    default:\n                        throw new Error(`String '${str}' was not recognized as a valid TimeSpan.`);\n                }\n            }\n            return sign * create(d, h, m, s, ms);\n        }\n    }\n    throw new Error(`String '${str}' was not recognized as a valid TimeSpan.`);\n}\nexport function tryParse(v, _refValue) {\n    try {\n        return [true, parse(v)];\n    }\n    catch (_err) {\n        return [false, 0];\n    }\n}\n//# sourceMappingURL=TimeSpan.js.map","\nnamespace Thoth.Json\nopen System.Text.RegularExpressions\n\n[<RequireQualifiedAccess>]\nmodule Decode =\n\n    open System.Globalization\n    open Fable.Core\n    open Fable.Core.JsInterop\n\n    module internal Helpers =\n        [<Emit(\"typeof $0\")>]\n        let jsTypeof (_ : JsonValue) : string = jsNative\n\n        [<Emit(\"$0 instanceof SyntaxError\")>]\n        let isSyntaxError (_ : JsonValue) : bool = jsNative\n\n        let inline getField (fieldName: string) (o: JsonValue) = o?(fieldName)\n        let inline isString (o: JsonValue) : bool = o :? string\n\n        let inline isBoolean (o: JsonValue) : bool = o :? bool\n\n        let inline isNumber (o: JsonValue) : bool = jsTypeof o = \"number\"\n\n        let inline isArray (o: JsonValue) : bool = JS.Constructors.Array.isArray(o)\n\n        [<Emit(\"$0 === null ? false : (Object.getPrototypeOf($0 || false) === Object.prototype)\")>]\n        let isObject (_ : JsonValue) : bool = jsNative\n\n        let inline isNaN (o: JsonValue) : bool = JS.Constructors.Number.isNaN(!!o)\n\n        let inline isNullValue (o: JsonValue): bool = isNull o\n\n        /// is the value an integer? This returns false for 1.1, NaN, Infinite, ...\n        [<Emit(\"isFinite($0) && Math.floor($0) === $0\")>]\n        let isIntegralValue (_: JsonValue) : bool = jsNative\n\n        [<Emit(\"$1 <= $0 && $0 < $2\")>]\n        let isBetweenInclusive(_v: JsonValue, _min: obj, _max: obj) = jsNative\n\n        [<Emit(\"isFinite($0) && !($0 % 1)\")>]\n        let isIntFinite (_: JsonValue) : bool = jsNative\n\n        let isUndefined (o: JsonValue): bool = jsTypeof o = \"undefined\"\n\n        [<Emit(\"JSON.stringify($0, null, 4) + ''\")>]\n        let anyToString (_: JsonValue) : string = jsNative\n\n        let inline isFunction (o: JsonValue) : bool = jsTypeof o = \"function\"\n\n        let inline objectKeys (o: JsonValue) : string seq = upcast JS.Constructors.Object.keys(o)\n        let inline asBool (o: JsonValue): bool = unbox o\n        let inline asInt (o: JsonValue): int = unbox o\n        let inline asFloat (o: JsonValue): float = unbox o\n        let inline asFloat32 (o: JsonValue): float32 = unbox o\n        let inline asString (o: JsonValue): string = unbox o\n        let inline asArray (o: JsonValue): JsonValue[] = unbox o\n\n    let private genericMsg msg value newLine =\n        try\n            \"Expecting \"\n                + msg\n                + \" but instead got:\"\n                + (if newLine then \"\\n\" else \" \")\n                + (Helpers.anyToString value)\n        with\n            | _ ->\n                \"Expecting \"\n                + msg\n                + \" but decoder failed. Couldn't report given value due to circular structure.\"\n                + (if newLine then \"\\n\" else \" \")\n\n    let private errorToString (path : string, error) =\n        let reason =\n            match error with\n            | BadPrimitive (msg, value) ->\n                genericMsg msg value false\n            | BadType (msg, value) ->\n                genericMsg msg value true\n            | BadPrimitiveExtra (msg, value, reason) ->\n                genericMsg msg value false + \"\\nReason: \" + reason\n            | BadField (msg, value) ->\n                genericMsg msg value true\n            | BadPath (msg, value, fieldName) ->\n                genericMsg msg value true + (\"\\nNode `\" + fieldName + \"` is unkown.\")\n            | TooSmallArray (msg, value) ->\n                \"Expecting \" + msg + \".\\n\" + (Helpers.anyToString value)\n            | BadOneOf messages ->\n                \"The following errors were found:\\n\\n\" + String.concat \"\\n\\n\" messages\n            | FailMessage msg ->\n                \"The following `failure` occurred with the decoder: \" + msg\n\n        match error with\n        | BadOneOf _ ->\n            // Don't need to show the path here because each error case will show it's own path\n            reason\n        | _ ->\n            \"Error at: `\" + path + \"`\\n\" + reason\n\n    ///////////////\n    // Runners ///\n    /////////////\n\n    let fromValue (path : string) (decoder : Decoder<'T>) =\n        fun value ->\n            match decoder path value with\n            | Ok success ->\n                Ok success\n            | Error error ->\n                Error (errorToString error)\n\n    let fromString (decoder : Decoder<'T>) =\n        fun value ->\n            try\n               let json = JS.JSON.parse value\n               fromValue \"$\" decoder json\n            with\n                | ex when Helpers.isSyntaxError ex ->\n                    Error(\"Given an invalid JSON: \" + ex.Message)\n\n    let unsafeFromString (decoder : Decoder<'T>) =\n        fun value ->\n            match fromString decoder value with\n            | Ok x -> x\n            | Error msg -> failwith msg\n\n    [<System.Obsolete(\"Please use fromValue instead\")>]\n    let decodeValue (path : string) (decoder : Decoder<'T>) = fromValue path decoder\n\n    [<System.Obsolete(\"Please use fromString instead\")>]\n    let decodeString (decoder : Decoder<'T>) = fromString decoder\n\n    //////////////////\n    // Primitives ///\n    ////////////////\n\n    let string : Decoder<string> =\n        fun path value ->\n            if Helpers.isString value then\n                Ok(Helpers.asString value)\n            else\n                (path, BadPrimitive(\"a string\", value)) |> Error\n\n    let guid : Decoder<System.Guid> =\n        fun path value ->\n            if Helpers.isString value then\n                match System.Guid.TryParse (Helpers.asString value) with\n                | true, x -> Ok x\n                | _ -> (path, BadPrimitive(\"a guid\", value)) |> Error\n            else (path, BadPrimitive(\"a guid\", value)) |> Error\n\n    let unit : Decoder<unit> =\n        fun path value ->\n            if Helpers.isNullValue value then\n                Ok ()\n            else\n                (path, BadPrimitive(\"null\", value)) |> Error\n\n    let inline private integral\n                    (name : string)\n                    (tryParse : (string -> bool * 'T))\n                    (min : 'T)\n                    (max : 'T)\n                    (conv : float -> 'T) : Decoder< 'T > =\n\n        fun path value ->\n            if Helpers.isNumber value then\n                let value : float = unbox value\n                if Helpers.isIntegralValue value then\n                    if (float min) <= value && value <= (float max) then\n                        Ok(conv value)\n                    else\n                        (path, BadPrimitiveExtra(name, value, \"Value was either too large or too small for \" + name)) |> Error\n                else\n                    (path, BadPrimitiveExtra(name, value, \"Value is not an integral value\")) |> Error\n            elif Helpers.isString value then\n                match tryParse (Helpers.asString value) with\n                | true, x -> Ok x\n                | _ -> (path, BadPrimitive(name, value)) |> Error\n            else\n                (path, BadPrimitive(name, value)) |> Error\n\n    let sbyte : Decoder<sbyte> =\n        integral\n            \"a sbyte\"\n            System.SByte.TryParse\n            System.SByte.MinValue\n            System.SByte.MaxValue\n            sbyte\n\n    /// Alias to Decode.uint8\n    let byte : Decoder<byte> =\n        integral\n            \"a byte\"\n            System.Byte.TryParse\n            System.Byte.MinValue\n            System.Byte.MaxValue\n            byte\n\n    let int16 : Decoder<int16> =\n        integral\n            \"an int16\"\n            System.Int16.TryParse\n            System.Int16.MinValue\n            System.Int16.MaxValue\n            int16\n\n    let uint16 : Decoder<uint16> =\n        integral\n            \"an uint16\"\n            System.UInt16.TryParse\n            System.UInt16.MinValue\n            System.UInt16.MaxValue\n            uint16\n\n    let int : Decoder<int> =\n        integral\n            \"an int\"\n            System.Int32.TryParse\n            System.Int32.MinValue\n            System.Int32.MaxValue\n            int\n\n    let uint32 : Decoder<uint32> =\n        integral\n            \"an uint32\"\n            System.UInt32.TryParse\n            System.UInt32.MinValue\n            System.UInt32.MaxValue\n            uint32\n\n    let int64 : Decoder<int64> =\n        integral\n            \"an int64\"\n            System.Int64.TryParse\n            System.Int64.MinValue\n            System.Int64.MaxValue\n            int64\n\n    let uint64 : Decoder<uint64> =\n        integral\n            \"an uint64\"\n            System.UInt64.TryParse\n            System.UInt64.MinValue\n            System.UInt64.MaxValue\n            uint64\n\n    let bigint : Decoder<bigint> =\n        fun path value ->\n            if Helpers.isNumber value then\n                Helpers.asInt value |> bigint |> Ok\n            elif Helpers.isString value then\n                // TODO: BigInt.TryParse has been added in Fable 2.1.4\n                // Don't use it for now to support lower Fable versions\n                try\n                    bigint.Parse (Helpers.asString value) |> Ok\n                with _ ->\n                    (path, BadPrimitive(\"a bigint\", value)) |> Error\n            else\n                (path, BadPrimitive(\"a bigint\", value)) |> Error\n\n    let bool : Decoder<bool> =\n        fun path value ->\n            if Helpers.isBoolean value then\n                Ok(Helpers.asBool value)\n            else\n                (path, BadPrimitive(\"a boolean\", value)) |> Error\n\n    let float : Decoder<float> =\n        fun path value ->\n            if Helpers.isNumber value then\n                Ok(Helpers.asFloat value)\n            else\n                (path, BadPrimitive(\"a float\", value)) |> Error\n\n    let float32 : Decoder<float32> =\n        fun path value ->\n            if Helpers.isNumber value then\n                Ok(Helpers.asFloat32 value)\n            else\n                (path, BadPrimitive(\"a float32\", value)) |> Error\n\n    let decimal : Decoder<decimal> =\n        fun path value ->\n            if Helpers.isNumber value then\n                Helpers.asFloat value |> decimal |> Ok\n            elif Helpers.isString value then\n                match System.Decimal.TryParse (Helpers.asString value) with\n                | true, x -> Ok x\n                | _ -> (path, BadPrimitive(\"a decimal\", value)) |> Error\n            else\n                (path, BadPrimitive(\"a decimal\", value)) |> Error\n\n    let datetime : Decoder<System.DateTime> =\n        fun path value ->\n            if Helpers.isString value then\n                match System.DateTime.TryParse (Helpers.asString value) with\n                | true, x -> x.ToUniversalTime() |> Ok\n                | _ -> (path, BadPrimitive(\"a datetime\", value)) |> Error\n            else\n                (path, BadPrimitive(\"a datetime\", value)) |> Error\n\n    let datetimeOffset : Decoder<System.DateTimeOffset> =\n        fun path value ->\n            if Helpers.isString value then\n                match System.DateTimeOffset.TryParse(Helpers.asString value) with\n                | true, x -> Ok x\n                | _ -> (path, BadPrimitive(\"a datetimeoffset\", value)) |> Error\n            else\n                (path, BadPrimitive(\"a datetime\", value)) |> Error\n\n    let timespan : Decoder<System.TimeSpan> =\n        fun path value ->\n            if Helpers.isString value then\n                match System.TimeSpan.TryParse(Helpers.asString value) with\n                | true, x -> Ok x\n                | _ -> (path, BadPrimitive(\"a timespan\", value)) |> Error\n            else\n                (path, BadPrimitive(\"a timespan\", value)) |> Error\n\n    /////////////////////////\n    // Object primitives ///\n    ///////////////////////\n\n    let private decodeMaybeNull path (decoder : Decoder<'T>) value =\n        // The decoder may be an option decoder so give it an opportunity to check null values\n        match decoder path value with\n        | Ok v -> Ok(Some v)\n        | Error _ when Helpers.isNullValue value -> Ok None\n        | Error er -> Error er\n\n    let optional (fieldName : string) (decoder : Decoder<'value>) : Decoder<'value option> =\n        fun path value ->\n            if Helpers.isObject value then\n                let fieldValue = Helpers.getField fieldName value\n                if Helpers.isUndefined fieldValue then Ok None\n                else decodeMaybeNull (path + \".\" + fieldName) decoder fieldValue\n            else\n                Error(path, BadType(\"an object\", value))\n\n    let private badPathError fieldNames currentPath value =\n        let currentPath = defaultArg currentPath (\"$\"::fieldNames |> String.concat \".\")\n        let msg = \"an object with path `\" + (String.concat \".\" fieldNames) + \"`\"\n        Error(currentPath, BadPath (msg, value, List.tryLast fieldNames |> Option.defaultValue \"\"))\n\n    let optionalAt (fieldNames : string list) (decoder : Decoder<'value>) : Decoder<'value option> =\n        fun firstPath firstValue ->\n            ((firstPath, firstValue, None), fieldNames)\n            ||> List.fold (fun (curPath, curValue, res) field ->\n                match res with\n                | Some _ -> curPath, curValue, res\n                | None ->\n                    if Helpers.isNullValue curValue then\n                        let res = badPathError fieldNames (Some curPath) firstValue\n                        curPath, curValue, Some res\n                    elif Helpers.isObject curValue then\n                        let curValue = Helpers.getField field curValue\n                        curPath + \".\" + field, curValue, None\n                    else\n                        let res = Error(curPath, BadType(\"an object\", curValue))\n                        curPath, curValue, Some res)\n            |> function\n                | _, _, Some res -> res\n                | lastPath, lastValue, None ->\n                    if Helpers.isUndefined lastValue then Ok None\n                    else decodeMaybeNull lastPath decoder lastValue\n\n    let field (fieldName: string) (decoder : Decoder<'value>) : Decoder<'value> =\n        fun path value ->\n            if Helpers.isObject value then\n                let fieldValue = Helpers.getField fieldName value\n                if Helpers.isUndefined fieldValue then\n                    Error(path, BadField (\"an object with a field named `\" + fieldName + \"`\", value))\n                else\n                    decoder (path + \".\" + fieldName) fieldValue\n            else\n                Error(path, BadType(\"an object\", value))\n\n    let at (fieldNames: string list) (decoder : Decoder<'value>) : Decoder<'value> =\n        fun firstPath firstValue ->\n            ((firstPath, firstValue, None), fieldNames)\n            ||> List.fold (fun (curPath, curValue, res) field ->\n                match res with\n                | Some _ -> curPath, curValue, res\n                | None ->\n                    if Helpers.isNullValue curValue then\n                        let res = badPathError fieldNames (Some curPath) firstValue\n                        curPath, curValue, Some res\n                    elif Helpers.isObject curValue then\n                        let curValue = Helpers.getField field curValue\n                        if Helpers.isUndefined curValue then\n                            let res = badPathError fieldNames None firstValue\n                            curPath, curValue, Some res\n                        else\n                            curPath + \".\" + field, curValue, None\n                    else\n                        let res = Error(curPath, BadType(\"an object\", curValue))\n                        curPath, curValue, Some res)\n            |> function\n                | _, _, Some res -> res\n                | lastPath, lastValue, None ->\n                    decoder lastPath lastValue\n\n    let index (requestedIndex: int) (decoder : Decoder<'value>) : Decoder<'value> =\n        fun path value ->\n            let currentPath = path + \".[\" + (Operators.string requestedIndex) + \"]\"\n            if Helpers.isArray value then\n                let vArray = Helpers.asArray value\n                if requestedIndex < vArray.Length then\n                    decoder currentPath (vArray.[requestedIndex])\n                else\n                    let msg =\n                        \"a longer array. Need index `\"\n                            + (requestedIndex.ToString())\n                            + \"` but there are only `\"\n                            + (vArray.Length.ToString())\n                            + \"` entries\"\n\n                    (currentPath, TooSmallArray(msg, value))\n                    |> Error\n            else\n                (currentPath, BadPrimitive(\"an array\", value))\n                |> Error\n\n    let option (decoder : Decoder<'value>) : Decoder<'value option> =\n        fun path value ->\n            if Helpers.isNullValue value then Ok None\n            else decoder path value |> Result.map Some\n\n    //////////////////////\n    // Data structure ///\n    ////////////////////\n\n    let list (decoder : Decoder<'value>) : Decoder<'value list> =\n        fun path value ->\n            if Helpers.isArray value then\n                let mutable i = -1\n                let tokens = Helpers.asArray value\n                (Ok [], tokens) ||> Array.fold (fun acc value ->\n                    i <- i + 1\n                    match acc with\n                    | Error _ -> acc\n                    | Ok acc ->\n                        match decoder (path + \".[\" + (i.ToString()) + \"]\") value with\n                        | Error er -> Error er\n                        | Ok value -> Ok (value::acc))\n                |> Result.map List.rev\n            else\n                (path, BadPrimitive (\"a list\", value))\n                |> Error\n\n    let seq (decoder : Decoder<'value>) : Decoder<'value seq> =\n        fun path value ->\n            if Helpers.isArray value then\n                let mutable i = -1\n                let tokens = Helpers.asArray value\n                (Ok (seq []), tokens) ||> Array.fold (fun acc value ->\n                    i <- i + 1\n                    match acc with\n                    | Error _ -> acc\n                    | Ok acc ->\n                        match decoder (path + \".[\" + (i.ToString()) + \"]\") value with\n                        | Error er -> Error er\n                        | Ok value -> Ok (Seq.append [value] acc))\n                |> Result.map Seq.rev\n            else\n                (path, BadPrimitive (\"a seq\", value))\n                |> Error\n\n    let array (decoder : Decoder<'value>) : Decoder<'value array> =\n        fun path value ->\n            if Helpers.isArray value then\n                let mutable i = -1\n                let tokens = Helpers.asArray value\n                let arr = Array.zeroCreate tokens.Length\n                (Ok arr, tokens) ||> Array.fold (fun acc value ->\n                    i <- i + 1\n                    match acc with\n                    | Error _ -> acc\n                    | Ok acc ->\n                        match decoder (path + \".[\" + (i.ToString()) + \"]\") value with\n                        | Error er -> Error er\n                        | Ok value -> acc.[i] <- value; Ok acc)\n            else\n                (path, BadPrimitive (\"an array\", value))\n                |> Error\n\n    let keys: Decoder<string list> =\n        fun path value ->\n            if Helpers.isObject value then\n                Helpers.objectKeys value |> List.ofSeq |> Ok\n            else\n                (path, BadPrimitive (\"an object\", value))\n                |> Error\n\n    let keyValuePairs (decoder : Decoder<'value>) : Decoder<(string * 'value) list> =\n        fun path value ->\n            match keys path value with\n            | Ok objectKeys ->\n                (Ok [], objectKeys) ||> List.fold (fun acc prop ->\n                    match acc with\n                    | Error _ -> acc\n                    | Ok acc ->\n                        match Helpers.getField prop value |> decoder path with\n                        | Error er -> Error er\n                        | Ok value -> (prop, value)::acc |> Ok)\n                |> Result.map List.rev\n            | Error e -> Error e\n\n    //////////////////////////////\n    // Inconsistent Structure ///\n    ////////////////////////////\n\n    let oneOf (decoders : Decoder<'value> list) : Decoder<'value> =\n        fun path value ->\n            let rec runner (decoders : Decoder<'value> list) (errors : string list) =\n                match decoders with\n                | head::tail ->\n                    match fromValue path head value with\n                    | Ok v ->\n                        Ok v\n                    | Error error -> runner tail (errors @ [error])\n                | [] -> (path, BadOneOf errors) |> Error\n\n            runner decoders []\n\n    //////////////////////\n    // Fancy decoding ///\n    ////////////////////\n\n    let nil (output : 'a) : Decoder<'a> =\n        fun path value ->\n            if Helpers.isNullValue value then\n                Ok output\n            else\n                (path, BadPrimitive(\"null\", value)) |> Error\n\n    let value _ v = Ok v\n\n    let succeed (output : 'a) : Decoder<'a> =\n        fun _ _ ->\n            Ok output\n\n    let fail (msg: string) : Decoder<'a> =\n        fun path _ ->\n            (path, FailMessage msg) |> Error\n\n    let andThen (cb: 'a -> Decoder<'b>) (decoder : Decoder<'a>) : Decoder<'b> =\n        fun path value ->\n            match decoder path value with\n            | Error error -> Error error\n            | Ok result -> cb result path value\n\n    let all (decoders: Decoder<'a> list): Decoder<'a list> =\n        fun path value ->\n            let rec runner (decoders: Decoder<'a> list) (values: 'a list) =\n                match decoders with\n                | decoder :: tail ->\n                    match decoder path value with\n                    | Ok value -> runner tail (values @ [ value ])\n                    | Error error -> Error error\n                | [] -> Ok values\n\n            runner decoders []\n\n    /////////////////////\n    // Map functions ///\n    ///////////////////\n\n    let map\n        (ctor : 'a -> 'value)\n        (d1 : Decoder<'a>) : Decoder<'value> =\n        fun path value ->\n            match d1 path value with\n            | Ok v1 -> Ok (ctor v1)\n            | Error er -> Error er\n\n    let map2\n        (ctor : 'a -> 'b -> 'value)\n        (d1 : Decoder<'a>)\n        (d2 : Decoder<'b>) : Decoder<'value> =\n        fun path value ->\n            match d1 path value, d2 path value with\n            | Ok v1, Ok v2 -> Ok (ctor v1 v2)\n            | Error er,_ -> Error er\n            | _,Error er -> Error er\n\n    let map3\n        (ctor : 'a -> 'b -> 'c -> 'value)\n        (d1 : Decoder<'a>)\n        (d2 : Decoder<'b>)\n        (d3 : Decoder<'c>) : Decoder<'value> =\n        fun path value ->\n            match d1 path value, d2 path value, d3 path value with\n            | Ok v1, Ok v2, Ok v3 -> Ok (ctor v1 v2 v3)\n            | Error er,_,_ -> Error er\n            | _,Error er,_ -> Error er\n            | _,_,Error er -> Error er\n\n    let map4\n        (ctor : 'a -> 'b -> 'c -> 'd -> 'value)\n        (d1 : Decoder<'a>)\n        (d2 : Decoder<'b>)\n        (d3 : Decoder<'c>)\n        (d4 : Decoder<'d>) : Decoder<'value> =\n        fun path value ->\n            match d1 path value, d2 path value, d3 path value, d4 path value with\n            | Ok v1, Ok v2, Ok v3, Ok v4 -> Ok (ctor v1 v2 v3 v4)\n            | Error er,_,_,_ -> Error er\n            | _,Error er,_,_ -> Error er\n            | _,_,Error er,_ -> Error er\n            | _,_,_,Error er -> Error er\n\n    let map5\n        (ctor : 'a -> 'b -> 'c -> 'd -> 'e -> 'value)\n        (d1 : Decoder<'a>)\n        (d2 : Decoder<'b>)\n        (d3 : Decoder<'c>)\n        (d4 : Decoder<'d>)\n        (d5 : Decoder<'e>) : Decoder<'value> =\n        fun path value ->\n            match d1 path value, d2 path value, d3 path value, d4 path value, d5 path value with\n            | Ok v1, Ok v2, Ok v3, Ok v4, Ok v5 -> Ok (ctor v1 v2 v3 v4 v5)\n            | Error er,_,_,_,_ -> Error er\n            | _,Error er,_,_,_ -> Error er\n            | _,_,Error er,_,_ -> Error er\n            | _,_,_,Error er,_ -> Error er\n            | _,_,_,_,Error er -> Error er\n\n    let map6\n        (ctor : 'a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'value)\n        (d1 : Decoder<'a>)\n        (d2 : Decoder<'b>)\n        (d3 : Decoder<'c>)\n        (d4 : Decoder<'d>)\n        (d5 : Decoder<'e>)\n        (d6 : Decoder<'f>) : Decoder<'value> =\n        fun path value ->\n            match d1 path value, d2 path value, d3 path value, d4 path value, d5 path value, d6 path value with\n            | Ok v1, Ok v2, Ok v3, Ok v4, Ok v5, Ok v6 -> Ok (ctor v1 v2 v3 v4 v5 v6)\n            | Error er,_,_,_,_,_ -> Error er\n            | _,Error er,_,_,_,_ -> Error er\n            | _,_,Error er,_,_,_ -> Error er\n            | _,_,_,Error er,_,_ -> Error er\n            | _,_,_,_,Error er,_ -> Error er\n            | _,_,_,_,_,Error er -> Error er\n\n    let map7\n        (ctor : 'a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g -> 'value)\n        (d1 : Decoder<'a>)\n        (d2 : Decoder<'b>)\n        (d3 : Decoder<'c>)\n        (d4 : Decoder<'d>)\n        (d5 : Decoder<'e>)\n        (d6 : Decoder<'f>)\n        (d7 : Decoder<'g>) : Decoder<'value> =\n        fun path value ->\n            match d1 path value, d2 path value, d3 path value, d4 path value, d5 path value, d6 path value, d7 path value with\n            | Ok v1, Ok v2, Ok v3, Ok v4, Ok v5, Ok v6, Ok v7 -> Ok (ctor v1 v2 v3 v4 v5 v6 v7)\n            | Error er,_,_,_,_,_,_ -> Error er\n            | _,Error er,_,_,_,_,_ -> Error er\n            | _,_,Error er,_,_,_,_ -> Error er\n            | _,_,_,Error er,_,_,_ -> Error er\n            | _,_,_,_,Error er,_,_ -> Error er\n            | _,_,_,_,_,Error er,_ -> Error er\n            | _,_,_,_,_,_,Error er -> Error er\n\n    let map8\n        (ctor : 'a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g -> 'h -> 'value)\n        (d1 : Decoder<'a>)\n        (d2 : Decoder<'b>)\n        (d3 : Decoder<'c>)\n        (d4 : Decoder<'d>)\n        (d5 : Decoder<'e>)\n        (d6 : Decoder<'f>)\n        (d7 : Decoder<'g>)\n        (d8 : Decoder<'h>) : Decoder<'value> =\n        fun path value ->\n            match d1 path value, d2 path value, d3 path value, d4 path value, d5 path value, d6 path value, d7 path value, d8 path value with\n            | Ok v1, Ok v2, Ok v3, Ok v4, Ok v5, Ok v6, Ok v7, Ok v8 -> Ok (ctor v1 v2 v3 v4 v5 v6 v7 v8)\n            | Error er,_,_,_,_,_,_,_ -> Error er\n            | _,Error er,_,_,_,_,_,_ -> Error er\n            | _,_,Error er,_,_,_,_,_ -> Error er\n            | _,_,_,Error er,_,_,_,_ -> Error er\n            | _,_,_,_,Error er,_,_,_ -> Error er\n            | _,_,_,_,_,Error er,_,_ -> Error er\n            | _,_,_,_,_,_,Error er,_ -> Error er\n            | _,_,_,_,_,_,_,Error er -> Error er\n\n    let dict (decoder : Decoder<'value>) : Decoder<Map<string, 'value>> =\n        map Map.ofList (keyValuePairs decoder)\n\n    //////////////////////\n    // Object builder ///\n    ////////////////////\n\n    type IRequiredGetter =\n        abstract Field : string -> Decoder<'a> -> 'a\n        abstract At : List<string> -> Decoder<'a> -> 'a\n        abstract Raw : Decoder<'a> -> 'a\n\n    type IOptionalGetter =\n        abstract Field : string -> Decoder<'a> -> 'a option\n        abstract At : List<string> -> Decoder<'a> -> 'a option\n        abstract Raw : Decoder<'a> -> 'a option\n\n    type IGetters =\n        abstract Required: IRequiredGetter\n        abstract Optional: IOptionalGetter\n\n    let private unwrapWith (errors: ResizeArray<DecoderError>) path (decoder: Decoder<'T>) value: 'T =\n        match decoder path value with\n        | Ok v -> v\n        | Error er -> errors.Add(er); Unchecked.defaultof<'T>\n\n    type Getters<'T>(path: string, v: 'T) =\n        let mutable errors = ResizeArray<DecoderError>()\n        let required =\n            { new IRequiredGetter with\n                member __.Field (fieldName : string) (decoder : Decoder<_>) =\n                    unwrapWith errors path (field fieldName decoder) v\n                member __.At (fieldNames : string list) (decoder : Decoder<_>) =\n                    unwrapWith errors path (at fieldNames decoder) v\n                member __.Raw (decoder: Decoder<_>) =\n                    unwrapWith errors path decoder v }\n        let optional =\n            { new IOptionalGetter with\n                member __.Field (fieldName : string) (decoder : Decoder<_>) =\n                    unwrapWith errors path (optional fieldName decoder) v\n                member __.At (fieldNames : string list) (decoder : Decoder<_>) =\n                    unwrapWith errors path (optionalAt fieldNames decoder) v\n                member __.Raw (decoder: Decoder<_>) =\n                    match decoder path v with\n                    | Ok v -> Some v\n                    | Error((_, reason) as error) ->\n                        match reason with\n                        | BadPrimitive(_,v)\n                        | BadPrimitiveExtra(_,v,_)\n                        | BadType(_,v) ->\n                            if Helpers.isNullValue v then None\n                            else errors.Add(error); Unchecked.defaultof<_>\n                        | BadField _\n                        | BadPath _ -> None\n                        | TooSmallArray _\n                        | FailMessage _\n                        | BadOneOf _ -> errors.Add(error); Unchecked.defaultof<_> }\n        member __.Errors: _ list = Seq.toList errors\n        interface IGetters with\n            member __.Required = required\n            member __.Optional = optional\n\n    let object (builder: IGetters -> 'value) : Decoder<'value> =\n        fun path v ->\n            let getters = Getters(path, v)\n            let result = builder getters\n            match getters.Errors with\n            | [] -> Ok result\n            | fst::_ as errors ->\n                if errors.Length > 1 then\n                    let errors = List.map errorToString errors\n                    (path, BadOneOf errors) |> Error\n                else\n                    Error fst\n\n    ///////////////////////\n    // Tuples decoders ///\n    ////////////////////\n\n    let tuple2 (decoder1: Decoder<'T1>) (decoder2: Decoder<'T2>) : Decoder<'T1 * 'T2> =\n        index 0 decoder1\n        |> andThen (fun v1 ->\n            index 1 decoder2\n            |> andThen (fun v2 ->\n                succeed (v1, v2)\n            )\n        )\n\n    let tuple3 (decoder1: Decoder<'T1>)\n               (decoder2: Decoder<'T2>)\n               (decoder3: Decoder<'T3>) : Decoder<'T1 * 'T2 * 'T3> =\n        index 0 decoder1\n        |> andThen (fun v1 ->\n            index 1 decoder2\n            |> andThen (fun v2 ->\n                index 2 decoder3\n                |> andThen (fun v3 ->\n                    succeed (v1, v2, v3)\n                )\n            )\n        )\n\n    let tuple4 (decoder1: Decoder<'T1>)\n               (decoder2: Decoder<'T2>)\n               (decoder3: Decoder<'T3>)\n               (decoder4: Decoder<'T4>) : Decoder<'T1 * 'T2 * 'T3 * 'T4> =\n        index 0 decoder1\n        |> andThen (fun v1 ->\n            index 1 decoder2\n            |> andThen (fun v2 ->\n                index 2 decoder3\n                |> andThen (fun v3 ->\n                    index 3 decoder4\n                    |> andThen (fun v4 ->\n                        succeed (v1, v2, v3, v4)\n                    )\n                )\n            )\n        )\n\n    let tuple5 (decoder1: Decoder<'T1>)\n               (decoder2: Decoder<'T2>)\n               (decoder3: Decoder<'T3>)\n               (decoder4: Decoder<'T4>)\n               (decoder5: Decoder<'T5>) : Decoder<'T1 * 'T2 * 'T3 * 'T4 * 'T5> =\n        index 0 decoder1\n        |> andThen (fun v1 ->\n            index 1 decoder2\n            |> andThen (fun v2 ->\n                index 2 decoder3\n                |> andThen (fun v3 ->\n                    index 3 decoder4\n                    |> andThen (fun v4 ->\n                        index 4 decoder5\n                        |> andThen (fun v5 ->\n                            succeed (v1, v2, v3, v4, v5)\n                        )\n                    )\n                )\n            )\n        )\n\n    let tuple6 (decoder1: Decoder<'T1>)\n               (decoder2: Decoder<'T2>)\n               (decoder3: Decoder<'T3>)\n               (decoder4: Decoder<'T4>)\n               (decoder5: Decoder<'T5>)\n               (decoder6: Decoder<'T6>) : Decoder<'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6> =\n        index 0 decoder1\n        |> andThen (fun v1 ->\n            index 1 decoder2\n            |> andThen (fun v2 ->\n                index 2 decoder3\n                |> andThen (fun v3 ->\n                    index 3 decoder4\n                    |> andThen (fun v4 ->\n                        index 4 decoder5\n                        |> andThen (fun v5 ->\n                            index 5 decoder6\n                            |> andThen (fun v6 ->\n                                succeed (v1, v2, v3, v4, v5, v6)\n                            )\n                        )\n                    )\n                )\n            )\n        )\n\n    let tuple7 (decoder1: Decoder<'T1>)\n               (decoder2: Decoder<'T2>)\n               (decoder3: Decoder<'T3>)\n               (decoder4: Decoder<'T4>)\n               (decoder5: Decoder<'T5>)\n               (decoder6: Decoder<'T6>)\n               (decoder7: Decoder<'T7>) : Decoder<'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7> =\n        index 0 decoder1\n        |> andThen (fun v1 ->\n            index 1 decoder2\n            |> andThen (fun v2 ->\n                index 2 decoder3\n                |> andThen (fun v3 ->\n                    index 3 decoder4\n                    |> andThen (fun v4 ->\n                        index 4 decoder5\n                        |> andThen (fun v5 ->\n                            index 5 decoder6\n                            |> andThen (fun v6 ->\n                                index 6 decoder7\n                                |> andThen (fun v7 ->\n                                    succeed (v1, v2, v3, v4, v5, v6, v7)\n                                )\n                            )\n                        )\n                    )\n                )\n            )\n        )\n\n    let tuple8 (decoder1: Decoder<'T1>)\n               (decoder2: Decoder<'T2>)\n               (decoder3: Decoder<'T3>)\n               (decoder4: Decoder<'T4>)\n               (decoder5: Decoder<'T5>)\n               (decoder6: Decoder<'T6>)\n               (decoder7: Decoder<'T7>)\n               (decoder8: Decoder<'T8>) : Decoder<'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8> =\n        index 0 decoder1\n        |> andThen (fun v1 ->\n            index 1 decoder2\n            |> andThen (fun v2 ->\n                index 2 decoder3\n                |> andThen (fun v3 ->\n                    index 3 decoder4\n                    |> andThen (fun v4 ->\n                        index 4 decoder5\n                        |> andThen (fun v5 ->\n                            index 5 decoder6\n                            |> andThen (fun v6 ->\n                                index 6 decoder7\n                                |> andThen (fun v7 ->\n                                    index 7 decoder8\n                                    |> andThen (fun v8 ->\n                                        succeed (v1, v2, v3, v4, v5, v6, v7, v8)\n                                    )\n                                )\n                            )\n                        )\n                    )\n                )\n            )\n        )\n\n    ////////////\n    // Enum ///\n    /////////\n\n    #if !FABLE_REPL_LIB\n    module Enum =\n\n        let inline byte<'TEnum when 'TEnum : enum<byte>> : Decoder<'TEnum> =\n            byte\n            |> andThen (fun value ->\n                LanguagePrimitives.EnumOfValue<byte, 'TEnum> value\n                |> succeed\n            )\n\n        let inline sbyte<'TEnum when 'TEnum : enum<sbyte>> : Decoder<'TEnum> =\n            sbyte\n            |> andThen (fun value ->\n                LanguagePrimitives.EnumOfValue<sbyte, 'TEnum> value\n                |> succeed\n            )\n\n        let inline int16<'TEnum when 'TEnum : enum<int16>> : Decoder<'TEnum> =\n            int16\n            |> andThen (fun value ->\n                LanguagePrimitives.EnumOfValue<int16, 'TEnum> value\n                |> succeed\n            )\n\n        let inline uint16<'TEnum when 'TEnum : enum<uint16>> : Decoder<'TEnum> =\n            uint16\n            |> andThen (fun value ->\n                LanguagePrimitives.EnumOfValue<uint16, 'TEnum> value\n                |> succeed\n            )\n\n        let inline int<'TEnum when 'TEnum : enum<int>> : Decoder<'TEnum> =\n            int\n            |> andThen (fun value ->\n                LanguagePrimitives.EnumOfValue<int, 'TEnum> value\n                |> succeed\n            )\n\n        let inline uint32<'TEnum when 'TEnum : enum<uint32>> : Decoder<'TEnum> =\n            uint32\n            |> andThen (fun value ->\n                LanguagePrimitives.EnumOfValue<uint32, 'TEnum> value\n                |> succeed\n            )\n    #endif\n\n    //////////////////\n    // Reflection ///\n    ////////////////\n\n    open FSharp.Reflection\n\n    // As generics are erased by Fable, let's just do an unsafe cast for performance\n    let inline boxDecoder (d: Decoder<'T>): BoxedDecoder =\n        !!d // d >> Result.map box\n\n    let inline unboxDecoder (d: BoxedDecoder): Decoder<'T> =\n        !!d // d >> Result.map unbox\n\n    // This is used to force Fable use a generic comparer for map keys\n    let private toMap<'key, 'value when 'key: comparison> (xs: ('key*'value) seq) = Map.ofSeq xs\n    let private toSet<'key when 'key: comparison> (xs: 'key seq) = Set.ofSeq xs\n\n    let private autoObject (decoderInfos: (string * BoxedDecoder)[]) (path : string) (value: JsonValue) =\n        if not (Helpers.isObject value) then\n            (path, BadPrimitive (\"an object\", value)) |> Error\n        else\n            (decoderInfos, Ok []) ||> Array.foldBack (fun (name, decoder) acc ->\n                match acc with\n                | Error _ -> acc\n                | Ok result ->\n                    Helpers.getField name value\n                    |> decoder (path + \".\" + name)\n                    |> Result.map (fun v -> v::result))\n\n    let inline private enumDecoder<'UnderlineType when 'UnderlineType : equality>\n        (decoder : Decoder<'UnderlineType>)\n        (toString : 'UnderlineType -> string)\n        (t: System.Type) =\n\n            fun path value ->\n                match decoder path value with\n                | Ok enumValue ->\n                    System.Enum.GetValues(t)\n                    |> Seq.cast<'UnderlineType>\n                    |> Seq.contains enumValue\n                    |> function\n                    | true ->\n                        System.Enum.Parse(t, toString enumValue)\n                        |> Ok\n                    | false ->\n                        (path, BadPrimitiveExtra(t.FullName, value, \"Unkown value provided for the enum\"))\n                        |> Error\n                | Error msg ->\n                    Error msg\n\n    let private autoObject2 (keyDecoder: BoxedDecoder) (valueDecoder: BoxedDecoder) (path : string) (value: JsonValue) =\n        if not (Helpers.isObject value) then\n            (path, BadPrimitive (\"an object\", value)) |> Error\n        else\n            (Ok [], Helpers.objectKeys(value)) ||> Seq.fold (fun acc name ->\n                match acc with\n                | Error _ -> acc\n                | Ok acc ->\n                    match keyDecoder path name with\n                    | Error er -> Error er\n                    | Ok k ->\n                        Helpers.getField name value\n                        |> valueDecoder (path + \".\" + name)\n                        |> function\n                            | Error er -> Error er\n                            | Ok v -> (k,v)::acc |> Ok)\n\n    let private mixedArray msg (decoders: BoxedDecoder[]) (path: string) (values: JsonValue[]): Result<JsonValue list, DecoderError> =\n        if decoders.Length <> values.Length then\n            (path, sprintf \"Expected %i %s but got %i\" decoders.Length msg values.Length\n            |> FailMessage) |> Error\n        else\n            (values, decoders, Ok [])\n            |||> Array.foldBack2 (fun value decoder acc ->\n                match acc with\n                | Error _ -> acc\n                | Ok result -> decoder path value |> Result.map (fun v -> v::result))\n\n    let rec private makeUnion extra caseStrategy t name (path : string) (values: JsonValue[]) =\n        let uci =\n            FSharpType.GetUnionCases(t, allowAccessToPrivateRepresentation=true)\n            |> Array.tryFind (fun x -> x.Name = name)\n        match uci with\n        | None -> (path, FailMessage(\"Cannot find case \" + name + \" in \" + t.FullName)) |> Error\n        | Some uci ->\n            if values.Length = 0 then\n                FSharpValue.MakeUnion(uci, [||], allowAccessToPrivateRepresentation=true) |> Ok\n            else\n                let decoders = uci.GetFields() |> Array.map (fun fi -> autoDecoder extra caseStrategy false fi.PropertyType)\n                mixedArray \"union fields\" decoders path values\n                |> Result.map (fun values -> FSharpValue.MakeUnion(uci, List.toArray values, allowAccessToPrivateRepresentation=true))\n\n    and private autoDecodeRecordsAndUnions extra (caseStrategy : CaseStrategy) (isOptional : bool) (t: System.Type) : BoxedDecoder =\n        // Add the decoder to extra in case one of the fields is recursive\n        let decoderRef = ref Unchecked.defaultof<_>\n        let extra = extra |> Map.add t.FullName decoderRef\n        let decoder =\n            if FSharpType.IsRecord(t, allowAccessToPrivateRepresentation=true) then\n                let decoders =\n                    FSharpType.GetRecordFields(t, allowAccessToPrivateRepresentation=true)\n                    |> Array.map (fun fi ->\n                        let name = Util.Casing.convert caseStrategy fi.Name\n                        name, autoDecoder extra caseStrategy false fi.PropertyType)\n                fun path value ->\n                    autoObject decoders path value\n                    |> Result.map (fun xs -> FSharpValue.MakeRecord(t, List.toArray xs, allowAccessToPrivateRepresentation=true))\n\n            elif FSharpType.IsUnion(t, allowAccessToPrivateRepresentation=true) then\n                fun path (value: JsonValue) ->\n                    if Helpers.isString(value) then\n                        let name = Helpers.asString value\n                        makeUnion extra caseStrategy t name path [||]\n                    elif Helpers.isArray(value) then\n                        let values = Helpers.asArray value\n                        let name = Helpers.asString values.[0]\n                        makeUnion extra caseStrategy t name path values.[1..]\n                    else (path, BadPrimitive(\"a string or array\", value)) |> Error\n\n            else\n                if isOptional then\n                    // The error will only happen at runtime if the value is not null\n                    // See https://github.com/MangelMaxime/Thoth/pull/84#issuecomment-444837773\n                    boxDecoder(fun path value -> Error(path, BadType(\"an extra coder for \" + t.FullName, value)))\n                else\n                    // Don't use failwithf here, for some reason F#/Fable compiles it as a function\n                    // when the return type is a function too, so it doesn't fail immediately\n                    sprintf \"Cannot generate auto decoder for %s. Please pass an extra decoder.\" t.FullName |> failwith\n        decoderRef := decoder\n        decoder\n\n    and private autoDecoder (extra: Map<string, ref<BoxedDecoder>>) caseStrategy (isOptional : bool) (t: System.Type) : BoxedDecoder =\n      let fullname = t.FullName\n      match Map.tryFind fullname extra with\n      | Some decoderRef -> fun path value -> decoderRef.contents path value\n      | None ->\n        if t.IsArray then\n            let decoder = t.GetElementType() |> autoDecoder extra caseStrategy false\n            array decoder |> boxDecoder\n        elif t.IsEnum then\n            let enumType = System.Enum.GetUnderlyingType(t).FullName\n            if enumType = typeof<sbyte>.FullName then\n                enumDecoder<sbyte> sbyte Operators.string t |> boxDecoder\n            elif enumType = typeof<byte>.FullName then\n                enumDecoder<byte> byte Operators.string t |> boxDecoder\n            elif enumType = typeof<int16>.FullName then\n                enumDecoder<int16> int16 Operators.string t |> boxDecoder\n            elif enumType = typeof<uint16>.FullName then\n                enumDecoder<uint16> uint16 Operators.string t |> boxDecoder\n            elif enumType = typeof<int>.FullName then\n                enumDecoder<int> int Operators.string t |> boxDecoder\n            elif enumType = typeof<uint32>.FullName then\n                enumDecoder<uint32> uint32 Operators.string t |> boxDecoder\n            else\n                failwithf\n                    \"\"\"Cannot generate auto decoder for %s.\nThoth.Json.Net only support the folluwing enum types:\n- sbyte\n- byte\n- int16\n- uint16\n- int\n- uint32\nIf you can't use one of these types, please pass an extra decoder.\n                    \"\"\" t.FullName\n        elif t.IsGenericType then\n            if FSharpType.IsTuple(t) then\n                let decoders = FSharpType.GetTupleElements(t) |> Array.map (autoDecoder extra caseStrategy false)\n                fun path value ->\n                    if Helpers.isArray value then\n                        mixedArray \"tuple elements\" decoders path (Helpers.asArray value)\n                        |> Result.map (fun xs -> FSharpValue.MakeTuple(List.toArray xs, t))\n                    else (path, BadPrimitive (\"an array\", value)) |> Error\n            else\n                let fullname = t.GetGenericTypeDefinition().FullName\n                if fullname = typedefof<obj option>.FullName then\n                    t.GenericTypeArguments.[0] |> (autoDecoder extra caseStrategy true) |> option |> boxDecoder\n                elif fullname = typedefof<obj list>.FullName then\n                    t.GenericTypeArguments.[0] |> (autoDecoder extra caseStrategy false) |> list |> boxDecoder\n                // Disable seq support because I don't know how to implement it on Thoth.Json.Net side\n                // elif fullname = typedefof<obj seq>.FullName then\n                //     t.GenericTypeArguments.[0] |> (autoDecoder extra caseStrategy false) |> seq |> boxDecoder\n                elif fullname = typedefof< Map<string, obj> >.FullName then\n                    let keyDecoder = t.GenericTypeArguments.[0] |> autoDecoder extra caseStrategy false\n                    let valueDecoder = t.GenericTypeArguments.[1] |> autoDecoder extra caseStrategy false\n                    oneOf [\n                        autoObject2 keyDecoder valueDecoder\n                        list (tuple2 keyDecoder valueDecoder)\n                    ] |> map (fun ar -> toMap (unbox ar) |> box)\n                elif fullname = typedefof< Set<string> >.FullName then\n                    let decoder = t.GenericTypeArguments.[0] |> autoDecoder extra caseStrategy false\n                    fun path value ->\n                        match array decoder path value with\n                        | Error er -> Error er\n                        | Ok ar -> toSet (unbox ar) |> box |> Ok\n                else\n                    autoDecodeRecordsAndUnions extra caseStrategy isOptional t\n        else\n            if fullname = typeof<bool>.FullName then\n                boxDecoder bool\n            elif fullname = typedefof<unit>.FullName then\n                boxDecoder unit\n            elif fullname = typeof<string>.FullName then\n                boxDecoder string\n            elif fullname = typeof<sbyte>.FullName then\n                boxDecoder sbyte\n            elif fullname = typeof<byte>.FullName then\n                boxDecoder byte\n            elif fullname = typeof<int16>.FullName then\n                boxDecoder int16\n            elif fullname = typeof<uint16>.FullName then\n                boxDecoder uint16\n            elif fullname = typeof<int>.FullName then\n                boxDecoder int\n            elif fullname = typeof<uint32>.FullName then\n                boxDecoder uint32\n            elif fullname = typeof<float>.FullName then\n                boxDecoder float\n            elif fullname = typeof<float32>.FullName then\n                boxDecoder float32\n            // These number types require extra libraries in Fable. To prevent penalizing\n            // all users, extra decoders (withInt64, etc) must be passed when they're needed.\n\n            // elif fullname = typeof<int64>.FullName then\n            //     boxDecoder int64\n            // elif fullname = typeof<uint64>.FullName then\n            //     boxDecoder uint64\n            // elif fullname = typeof<bigint>.FullName then\n            //     boxDecoder bigint\n            // elif fullname = typeof<decimal>.FullName then\n            //     boxDecoder decimal\n            elif fullname = typeof<System.DateTime>.FullName then\n                boxDecoder datetime\n            elif fullname = typeof<System.DateTimeOffset>.FullName then\n                boxDecoder datetimeOffset\n            elif fullname = typeof<System.TimeSpan>.FullName then\n                boxDecoder timespan\n            elif fullname = typeof<System.Guid>.FullName then\n                boxDecoder guid\n            elif fullname = typeof<obj>.FullName then\n                fun _ v -> Ok v\n            else autoDecodeRecordsAndUnions extra caseStrategy isOptional t\n\n    let private makeExtra (extra: ExtraCoders option) =\n        match extra with\n        | None -> Map.empty\n        | Some e -> Map.map (fun _ (_,dec) -> ref dec) e.Coders\n\n    type Auto =\n        static member generateDecoderCached<'T>(?caseStrategy : CaseStrategy, ?extra: ExtraCoders, [<Inject>] ?resolver: ITypeResolver<'T>): Decoder<'T> =\n            let t = Util.resolveType resolver\n            let caseStrategy = defaultArg caseStrategy PascalCase\n\n            let key =\n                t.FullName\n                |> (+) (Operators.string caseStrategy)\n                |> (+) (extra |> Option.map (fun e -> e.Hash) |> Option.defaultValue \"\")\n\n            Util.CachedDecoders.GetOrAdd(key, fun _ ->\n                autoDecoder (makeExtra extra) caseStrategy false t) |> unboxDecoder\n\n        static member generateDecoder<'T>(?caseStrategy : CaseStrategy, ?extra: ExtraCoders, [<Inject>] ?resolver: ITypeResolver<'T>): Decoder<'T> =\n            let caseStrategy = defaultArg caseStrategy PascalCase\n            Util.resolveType resolver\n            |> autoDecoder (makeExtra extra) caseStrategy false |> unboxDecoder\n\n        static member fromString<'T>(json: string, ?caseStrategy : CaseStrategy, ?extra: ExtraCoders, [<Inject>] ?resolver: ITypeResolver<'T>): Result<'T, string> =\n            let decoder = Auto.generateDecoder(?caseStrategy=caseStrategy, ?extra=extra, ?resolver=resolver)\n            fromString decoder json\n\n        static member unsafeFromString<'T>(json: string, ?caseStrategy : CaseStrategy, ?extra: ExtraCoders, [<Inject>] ?resolver: ITypeResolver<'T>): 'T =\n            let decoder = Auto.generateDecoder(?caseStrategy=caseStrategy, ?extra=extra, ?resolver=resolver)\n            match fromString decoder json with\n            | Ok x -> x\n            | Error msg -> failwith msg\n","﻿module DecoderExtra\n\nopen System\nopen Thoth.Json\n\ntype DecoderBuilder() =\n    member __.Bind(decoder: 'a Decoder, f: 'a -> 'b Decoder): 'b Decoder =\n        Decode.andThen f decoder\n\n    member __.Return(value: 'a): 'a Decoder = Decode.succeed value\n\n    member __.ReturnFrom(decoder: 'a Decoder): 'a Decoder = decoder\n\n    member __.Zero(): unit Decoder = __.Return()\n\nlet decoder = DecoderBuilder()\n\n\n[<RequireQualifiedAccess>]\nmodule Decode =\n    let stringLiteral expected =\n        decoder {\n            let! actual = Decode.string\n            if String.Equals(actual, expected)\n            then return! Decode.succeed ()\n            else return! sprintf \"Expected %s to be %s.\" actual expected |> Decode.fail\n        }\n        \n    let fromOption errorMsg option =\n        match option with\n        | Some value -> Decode.succeed value\n        | None -> Decode.fail errorMsg\n","﻿module BattleResult\n\nopen Thoth.Json\nopen DecoderExtra\n\ntype VehicleId = VehicleId of int\n\ntype Outcome =\n    | Victory\n    | DrawOrLoss\n\ntype RandomBattle =\n    { VehicleId: VehicleId\n      DamageDealt: int\n      Spots: int\n      Frags: int\n      DefencePoints: int }\n\ntype BonusType =\n    | RandomBattle of RandomBattle\n    | Other\n\nlet internal decodeRandomBattle =\n    decoder {\n        let! personalKeys = Decode.field \"personal\" Decode.keys\n        let! vehicleId =\n            personalKeys\n            |> List.map System.Int32.TryParse\n            |> List.choose (function\n                | true, id -> Some id\n                | _, _ -> None)\n            |> List.tryHead\n            |> Decode.fromOption \"Expected random battle to have a vehicle.\"\n\n        let atVehicle =\n            Decode.at\n                [ \"personal\"\n                  string vehicleId ]\n\n        let! damageDealt = atVehicle <| Decode.field \"damageDealt\" Decode.int\n        let! spots = atVehicle <| Decode.field \"spotted\" Decode.int\n        let! frags = atVehicle <| Decode.field \"kills\" Decode.int\n        let! defencePoints = atVehicle <| Decode.field \"droppedCapturePoints\" Decode.int\n\n        return { VehicleId = VehicleId vehicleId\n                 DamageDealt = damageDealt\n                 Spots = spots\n                 Frags = frags\n                 DefencePoints = defencePoints }\n    }\n\nlet internal decodeBonusType =\n    decoder {\n        let! bonusType = Decode.at [ \"common\"; \"bonusType\" ] Decode.int\n        match bonusType with\n        | 1 ->\n            let! randomBattle = decodeRandomBattle\n            return RandomBattle randomBattle\n        | _ -> return Other\n    }\n\ntype BattleResult =\n    { Outcome: Outcome\n      BonusType: BonusType }\n\n    static member decoder: Decoder<BattleResult> =\n        decoder {\n            let! winnerTeam = Decode.at [ \"common\"; \"winnerTeam\" ] Decode.int\n            let! team = Decode.at [ \"personal\"; \"avatar\"; \"team\" ] Decode.int\n            let outcome =\n                if winnerTeam = team then Victory else DrawOrLoss\n\n            let! bonusType = decodeBonusType\n\n            return { Outcome = outcome\n                     BonusType = bonusType }\n        }\n        \n    static member isVictory battle =\n        match battle.Outcome with\n        | Victory -> true\n        | DrawOrLoss -> false\n        \n    static member isRandomBattle battle =\n        match battle.BonusType with\n        | RandomBattle -> true\n        | _ -> false\n","\n[<RequireQualifiedAccess>]\nmodule Promise\n\n#nowarn \"1182\" // Unused values\n\nopen System\nopen Fable.Core\nopen Fable.Core.JsInterop\n\nlet inline private (!!) (x:obj): 'T = unbox x\n\n[<Emit(\"new Promise($0)\")>]\n/// The promise function receives two other function parameters: success and fail\nlet create (f: ('T->unit)->(Exception->unit)->unit): JS.Promise<'T> = jsNative\n\n[<Emit(\"new Promise(resolve => setTimeout(resolve, $0))\")>]\nlet sleep (ms: int): JS.Promise<unit> = jsNative\n\n[<Emit(\"Promise.resolve($0)\")>]\nlet lift<'T> (a: 'T): JS.Promise<'T> = jsNative\n\n/// Creates promise (in rejected state) with supplied reason.\nlet reject<'T> reason : JS.Promise<'T> = JS.Promise.reject<'T> reason\n\n[<Emit(\"$1.then($0)\")>]\nlet bind (a: 'T->JS.Promise<'R>) (pr: JS.Promise<'T>): JS.Promise<'R> = jsNative\n\n[<Emit(\"$1.then($0)\")>]\nlet map (a: 'T->'R) (pr: JS.Promise<'T>): JS.Promise<'R> = jsNative\n\n[<Emit(\"$1.then($0)\")>]\nlet iter (a: 'T->unit) (pr: JS.Promise<'T>): unit = jsNative\n\n[<Emit(\"$1.then(void 0, $0)\")>]\n/// This version of `catch` fakes a function returning just 'T, as opposed to `Promise<'T>`. If you need to return `Promise<'T>`, use `catchBind`.\nlet catch (fail: Exception->'T) (pr: JS.Promise<'T>): JS.Promise<'T> = jsNative\n\n[<Emit(\"$1.then(void 0, $0)\")>]\n/// This is a version of `catch` that fakes a function returning Promise<'T> as opposed to just 'T. If you need to return just 'T, use `catch`.\nlet catchBind (fail: Exception->JS.Promise<'T>) (pr: JS.Promise<'T>): JS.Promise<'T> = jsNative\n\n[<Emit(\"$1.then(void 0, $0)\")>]\n/// Used to catch errors at the end of a promise chain.\nlet catchEnd (fail: Exception->unit) (pr: JS.Promise<'T>): unit = jsNative\n\n[<Emit(\"$2.then($0,$1)\")>]\n/// A combination of `map/bind` and `catch/catchBind`, this function applies the `success` continuation when the input promise resolves successfully, or `fail` continuation when the input promise fails. Both continuations may return either naked value `'R` or another promise `Promise<'R>`. Use the erased-cast operator `!^` to cast values when returning, for example:\n/// ```\n/// somePromise |> Promise.either (fun x -> !^(string x)) (fun err -> ^!(Promise.lift err.Message))\n/// ```\nlet either (success: 'T->U2<'R, JS.Promise<'R>>) (fail: 'E->U2<'R, JS.Promise<'R>>) (pr: JS.Promise<'T>): JS.Promise<'R> = jsNative\n\n[<Emit(\"$2.then($0,$1)\")>]\nlet eitherEnd (success: 'T->unit) (fail: 'E->unit) (pr: JS.Promise<'T>): unit = jsNative\n\n[<Emit(\"$0.then()\")>]\nlet start (pr: JS.Promise<'T>): unit = jsNative\n\n[<Emit(\"$1.then(void 0, $0)\")>]\nlet tryStart (fail: Exception->unit) (pr: JS.Promise<'T>): unit = jsNative\n\n[<Emit(\"Promise.all($0)\")>]\nlet Parallel (pr: seq<JS.Promise<'T>>): JS.Promise<'T[]> = jsNative\n\n[<Emit(\"Promise.all($0)\")>]\nlet all (pr: seq<JS.Promise<'T>>): JS.Promise<'T[]> = jsNative\n\nlet result (a: JS.Promise<'A>): JS.Promise<Result<'A, 'E>> =\n    either (U2.Case1 << Ok) (U2.Case1 << Error) a\n\nlet mapResult (fn: 'A -> 'B) (a: JS.Promise<Result<'A, 'E>>): JS.Promise<Result<'B, 'E>> =\n    a |> map (Result.map fn)\n\nlet bindResult (fn: 'A -> JS.Promise<'B>) (a: JS.Promise<Result<'A, 'E>>): JS.Promise<Result<'B, 'E>> =\n    a |> bind (fun a ->\n        match a with\n        | Ok a ->\n            result (fn a)\n        | Error e ->\n            lift (Error e))\n\nlet mapResultError (fn: 'B -> 'C) (a: JS.Promise<Result<'A,'B>>): JS.Promise<Result<'A,'C>> =\n    a |> map (Result.mapError fn)\n\nlet tap (fn: 'A -> unit) (a: JS.Promise<'A>): JS.Promise<'A> =\n    a |> map (fun x -> fn x; x)\n\ntype PromiseBuilder() =\n    [<Emit(\"$1.then($2)\")>]\n    member x.Bind(p: JS.Promise<'T>, f: 'T->JS.Promise<'R>): JS.Promise<'R> = jsNative\n\n    [<Emit(\"$1.then(() => $2)\")>]\n    member x.Combine(p1: JS.Promise<unit>, p2: JS.Promise<'T>): JS.Promise<'T> = jsNative\n\n    member x.For(seq: seq<'T>, body: 'T->JS.Promise<unit>): JS.Promise<unit> =\n        // (lift (), seq)\n        // ||> Seq.fold (fun p a ->\n        //     bind (fun () -> body a) p)\n        let mutable p = lift ()\n        for a in seq do\n            p <- !!p?``then``(fun () -> body a)\n        p\n\n    [<Emit(\"$1.then($2)\")>]\n    member x.For(p: JS.Promise<'T>, f: 'T->JS.Promise<'R>): JS.Promise<'R> = jsNative\n\n    member x.While(guard, p): JS.Promise<unit> =\n        if guard()\n        then bind (fun () -> x.While(guard, p)) p\n        else lift()\n\n    [<Emit(\"Promise.resolve($1)\")>]\n    member x.Return(a: 'T): JS.Promise<'T> = jsNative\n\n    [<Emit(\"$1\")>]\n    member x.ReturnFrom(p: JS.Promise<'T>): JS.Promise<'T> = jsNative\n\n    [<Emit(\"Promise.resolve()\")>]\n    member x.Zero(): JS.Promise<unit> = jsNative\n\n    member x.TryFinally(p: JS.Promise<'T>, compensation: unit->unit): JS.Promise<'T> =\n        either (fun (x: 'T) -> compensation(); U2.Case1 x) (fun er -> compensation(); raise !!er) p\n\n    [<Emit(\"$1.catch($2)\")>]\n    member x.TryWith(p: JS.Promise<'T>, catchHandler: Exception->JS.Promise<'T>): JS.Promise<'T> = jsNative\n\n    member x.Delay(generator: unit->JS.Promise<'T>): JS.Promise<'T> =\n        !!createObj[\n            \"then\" ==> fun f1 f2 ->\n                try generator()?``then``(f1,f2)\n                with er ->\n                    if box f2 = null\n                    then !!JS.Promise.reject(er)\n                    else\n                        try !!JS.Promise.resolve(f2(er))\n                        with er -> !!JS.Promise.reject(er)\n            \"catch\" ==> fun f ->\n                try generator()?catch(f)\n                with er ->\n                    try !!JS.Promise.resolve(f(er))\n                    with er -> !!JS.Promise.reject(er)\n        ]\n\n    member x.Run(p:JS.Promise<'T>): JS.Promise<'T> =\n        create (fun success fail ->\n            try\n                let p : JS.Promise<'T> = !!JS.Promise.resolve(p)\n                p?``then``(success, fail)\n            with\n              er -> fail(er)\n        )\n\n    member x.Using<'T, 'R when 'T :> IDisposable>(resource: 'T, binder: 'T->JS.Promise<'R>): JS.Promise<'R> =\n        x.TryFinally(binder(resource), fun () -> resource.Dispose())\n\n    [<Emit(\"Promise.all([$1,$2]).then(([a,b]) => $3(a,b))\")>]\n    [<CustomOperation(\"andFor\", IsLikeZip=true)>]\n    member x.Merge(a: JS.Promise<'T1>, b: JS.Promise<'T2>, [<ProjectionParameter>] resultSelector : 'T1 -> 'T2 -> 'R): JS.Promise<'R> = jsNative\n","namespace Thoth.Json\nopen System.Text.RegularExpressions\n\n[<RequireQualifiedAccess>]\nmodule Encode =\n\n    open System.Collections.Generic\n    open System.Globalization\n    open Fable.Core\n    open Fable.Core.JsInterop\n\n    [<Emit(\"Array.from($0)\")>]\n    let private arrayFrom(x: JsonValue seq): JsonValue = jsNative\n\n    ///**Description**\n    /// Encode a string\n    ///\n    ///**Parameters**\n    ///  * `value` - parameter of type `string`\n    ///\n    ///**Output Type**\n    ///  * `Value`\n    ///\n    ///**Exceptions**\n    ///\n    let inline string (value : string) : JsonValue =\n        box value\n\n    ///**Description**\n    /// Encode a GUID\n    ///\n    ///**Parameters**\n    ///  * `value` - parameter of type `System.Guid`\n    ///\n    ///**Output Type**\n    ///  * `Value`\n    ///\n    ///**Exceptions**\n    ///\n    let guid (value : System.Guid) : JsonValue =\n        box (value.ToString())\n\n    ///**Description**\n    /// Encode a Float. `Infinity` and `NaN` are encoded as `null`.\n    ///\n    ///**Parameters**\n    ///  * `value` - parameter of type `float`\n    ///\n    ///**Output Type**\n    ///  * `Value`\n    ///\n    ///**Exceptions**\n    ///\n    let inline float (value : float) : JsonValue =\n        box value\n\n    let inline float32 (value : float32) : JsonValue =\n        box value\n\n    ///**Description**\n    /// Encode a Decimal.\n    ///\n    ///**Parameters**\n    ///  * `value` - parameter of type `decimal`\n    ///\n    ///**Output Type**\n    ///  * `Value`\n    ///\n    ///**Exceptions**\n    ///\n    let decimal (value : decimal) : JsonValue =\n        value.ToString() |> string\n\n    ///**Description**\n    /// Encode null\n    ///\n    ///**Parameters**\n    ///\n    ///**Output Type**\n    ///  * `Value`\n    ///\n    ///**Exceptions**\n    ///\n    let nil : JsonValue =\n        box null\n\n    ///**Description**\n    /// Encode a bool\n    ///**Parameters**\n    ///  * `value` - parameter of type `bool`\n    ///\n    ///**Output Type**\n    ///  * `Value`\n    ///\n    ///**Exceptions**\n    ///\n    let inline bool (value : bool) : JsonValue =\n        box value\n\n    ///**Description**\n    /// Encode an object\n    ///\n    ///**Parameters**\n    ///  * `values` - parameter of type `(string * Value) list`\n    ///\n    ///**Output Type**\n    ///  * `Value`\n    ///\n    ///**Exceptions**\n    ///\n    let object (values : (string * JsonValue) seq) : JsonValue =\n        let o = obj()\n        for (key, value) in values do\n            o?(key) <- value\n        box o\n\n    ///**Description**\n    /// Encode an array\n    ///\n    ///**Parameters**\n    ///  * `values` - parameter of type `Value array`\n    ///\n    ///**Output Type**\n    ///  * `Value`\n    ///\n    ///**Exceptions**\n    ///\n    let inline array (values : JsonValue array) : JsonValue =\n        box values\n\n    ///**Description**\n    /// Encode a list\n    ///**Parameters**\n    ///  * `values` - parameter of type `Value list`\n    ///\n    ///**Output Type**\n    ///  * `Value`\n    ///\n    ///**Exceptions**\n    ///\n    let list (values : JsonValue list) : JsonValue =\n        // Don't use List.toArray as it may create a typed array\n        arrayFrom values\n\n    let seq (values : JsonValue seq) : JsonValue =\n        arrayFrom values\n\n    ///**Description**\n    /// Encode a dictionary\n    ///**Parameters**\n    ///  * `values` - parameter of type `Map<string, Value>`\n    ///\n    ///**Output Type**\n    ///  * `Value`\n    ///\n    ///**Exceptions**\n    ///\n    let dict (values : Map<string, JsonValue>) : JsonValue =\n        values\n        |> Map.toList\n        |> object\n\n    let bigint (value : bigint) : JsonValue =\n        box (value.ToString())\n\n    let datetimeOffset (value : System.DateTimeOffset) : JsonValue =\n        value.ToString(\"O\", CultureInfo.InvariantCulture) |> string\n\n    /// **Description**\n    /// Encode a timespan\n    /// **Parameters**\n    ///   * `value` - parameter of type `System.TimeSpan`\n    ///\n    /// **Output Type**\n    ///   * `Value`\n    ///\n    /// **Exceptions**\n    ///\n    let timespan (value : System.TimeSpan) : JsonValue =\n        value.ToString() |> string\n\n    let sbyte (value : sbyte) : JsonValue =\n        box (value.ToString(CultureInfo.InvariantCulture))\n\n    let byte (value : byte) : JsonValue =\n        box (value.ToString(CultureInfo.InvariantCulture))\n\n    let int16 (value : int16) : JsonValue =\n        box (value.ToString(CultureInfo.InvariantCulture))\n\n    let uint16 (value : uint16) : JsonValue =\n        box (value.ToString(CultureInfo.InvariantCulture))\n\n    let inline int (value : int) : JsonValue =\n        box value\n\n    let inline uint32 (value : uint32) : JsonValue =\n        box value\n\n    let int64 (value : int64) : JsonValue =\n        box (value.ToString(CultureInfo.InvariantCulture))\n\n    let uint64 (value : uint64) : JsonValue =\n        box (value.ToString(CultureInfo.InvariantCulture))\n\n    let unit () : JsonValue =\n        box null\n\n    let tuple2\n            (enc1 : Encoder<'T1>)\n            (enc2 : Encoder<'T2>)\n            (v1, v2) : JsonValue =\n        box [| enc1 v1\n               enc2 v2 |]\n\n    let tuple3\n            (enc1 : Encoder<'T1>)\n            (enc2 : Encoder<'T2>)\n            (enc3 : Encoder<'T3>)\n            (v1, v2, v3) : JsonValue =\n        box [| enc1 v1\n               enc2 v2\n               enc3 v3 |]\n\n    let tuple4\n            (enc1 : Encoder<'T1>)\n            (enc2 : Encoder<'T2>)\n            (enc3 : Encoder<'T3>)\n            (enc4 : Encoder<'T4>)\n            (v1, v2, v3, v4) : JsonValue =\n        box [| enc1 v1\n               enc2 v2\n               enc3 v3\n               enc4 v4 |]\n\n    let tuple5\n            (enc1 : Encoder<'T1>)\n            (enc2 : Encoder<'T2>)\n            (enc3 : Encoder<'T3>)\n            (enc4 : Encoder<'T4>)\n            (enc5 : Encoder<'T5>)\n            (v1, v2, v3, v4, v5) : JsonValue =\n        box [| enc1 v1\n               enc2 v2\n               enc3 v3\n               enc4 v4\n               enc5 v5 |]\n\n    let tuple6\n            (enc1 : Encoder<'T1>)\n            (enc2 : Encoder<'T2>)\n            (enc3 : Encoder<'T3>)\n            (enc4 : Encoder<'T4>)\n            (enc5 : Encoder<'T5>)\n            (enc6 : Encoder<'T6>)\n            (v1, v2, v3, v4, v5, v6) : JsonValue =\n        box [| enc1 v1\n               enc2 v2\n               enc3 v3\n               enc4 v4\n               enc5 v5\n               enc6 v6 |]\n\n    let tuple7\n            (enc1 : Encoder<'T1>)\n            (enc2 : Encoder<'T2>)\n            (enc3 : Encoder<'T3>)\n            (enc4 : Encoder<'T4>)\n            (enc5 : Encoder<'T5>)\n            (enc6 : Encoder<'T6>)\n            (enc7 : Encoder<'T7>)\n            (v1, v2, v3, v4, v5, v6, v7) : JsonValue =\n        box [| enc1 v1\n               enc2 v2\n               enc3 v3\n               enc4 v4\n               enc5 v5\n               enc6 v6\n               enc7 v7 |]\n\n    let tuple8\n            (enc1 : Encoder<'T1>)\n            (enc2 : Encoder<'T2>)\n            (enc3 : Encoder<'T3>)\n            (enc4 : Encoder<'T4>)\n            (enc5 : Encoder<'T5>)\n            (enc6 : Encoder<'T6>)\n            (enc7 : Encoder<'T7>)\n            (enc8 : Encoder<'T8>)\n            (v1, v2, v3, v4, v5, v6, v7, v8) : JsonValue =\n        box [| enc1 v1\n               enc2 v2\n               enc3 v3\n               enc4 v4\n               enc5 v5\n               enc6 v6\n               enc7 v7\n               enc8 v8 |]\n\n\n    ////////////\n    // Enum ///\n    /////////\n\n    module Enum =\n\n        let byte<'TEnum when 'TEnum : enum<byte>> (value : 'TEnum) : JsonValue =\n            LanguagePrimitives.EnumToValue value\n            |> byte\n\n        let sbyte<'TEnum when 'TEnum : enum<sbyte>> (value : 'TEnum) : JsonValue =\n            LanguagePrimitives.EnumToValue value\n            |> sbyte\n\n        let int16<'TEnum when 'TEnum : enum<int16>> (value : 'TEnum) : JsonValue =\n            LanguagePrimitives.EnumToValue value\n            |> int16\n\n        let uint16<'TEnum when 'TEnum : enum<uint16>> (value : 'TEnum) : JsonValue =\n            LanguagePrimitives.EnumToValue value\n            |> uint16\n\n        let int<'TEnum when 'TEnum : enum<int>> (value : 'TEnum) : JsonValue =\n            LanguagePrimitives.EnumToValue value\n            |> int\n\n        let uint32<'TEnum when 'TEnum : enum<uint32>> (value : 'TEnum) : JsonValue =\n            LanguagePrimitives.EnumToValue value\n            |> uint32\n\n    /// **Description**\n    ///\n    /// The DateTime is always encoded using UTC representation\n    ///\n    /// **Parameters**\n    ///   * `value` - parameter of type `System.DateTime`\n    ///\n    /// **Output Type**\n    ///   * `Value`\n    ///\n    /// **Exceptions**\n    ///\n    let datetime (value : System.DateTime) : JsonValue =\n        value.ToString(\"O\", CultureInfo.InvariantCulture) |> string\n\n    ///**Description**\n    /// Convert a `Value` into a prettified string.\n    ///**Parameters**\n    ///  * `space` - parameter of type `int` - Amount of indentation\n    ///  * `value` - parameter of type `obj` - Value to convert\n    ///\n    ///**Output Type**\n    ///  * `string`\n    ///\n    ///**Exceptions**\n    ///\n    let toString (space: int) (value: JsonValue) : string =\n       JS.JSON.stringify(value, !!null, space)\n\n    ///**Description**\n    /// Encode an option\n    ///**Parameters**\n    ///  * `encoder` - parameter of type `'a -> Value`\n    ///\n    ///**Output Type**\n    ///  * `'a option -> Value`\n    ///\n    ///**Exceptions**\n    ///\n    let option (encoder : 'a -> JsonValue) =\n        Option.map encoder >> Option.defaultWith (fun _ -> nil)\n\n    //////////////////\n    // Reflection ///\n    ////////////////\n\n    open FSharp.Reflection\n    open Fable.Core.DynamicExtensions\n\n    // As generics are erased by Fable, let's just do an unsafe cast for performance\n    let inline boxEncoder (d: Encoder<'T>): BoxedEncoder =\n        !!d\n\n    let inline unboxEncoder (d: BoxedEncoder): Encoder<'T> =\n        !!d\n\n    let rec private autoEncodeRecordsAndUnions extra (caseStrategy : CaseStrategy) (skipNullField : bool) (t: System.Type) : BoxedEncoder =\n        // Add the encoder to extra in case one of the fields is recursive\n        let encoderRef = ref Unchecked.defaultof<_>\n        let extra = extra |> Map.add t.FullName encoderRef\n        let encoder =\n            if FSharpType.IsRecord(t, allowAccessToPrivateRepresentation=true) then\n                let setters =\n                    FSharpType.GetRecordFields(t, allowAccessToPrivateRepresentation=true)\n                    |> Array.map (fun fi ->\n                        let targetKey = Util.Casing.convert caseStrategy fi.Name\n                        let encode = autoEncoder extra caseStrategy skipNullField fi.PropertyType\n                        fun (source: obj) (target: JsonValue) ->\n                            let value = FSharpValue.GetRecordField(source, fi)\n                            if not skipNullField || (skipNullField && not (isNull value)) then // Discard null fields\n                                target.[targetKey] <- encode value\n                            target)\n                fun (source: obj) ->\n                    (JsonValue(), setters) ||> Seq.fold (fun target set -> set source target)\n            elif FSharpType.IsUnion(t, allowAccessToPrivateRepresentation=true) then\n                fun (value: obj) ->\n                    let info, fields = FSharpValue.GetUnionFields(value, t, allowAccessToPrivateRepresentation=true)\n                    match fields.Length with\n                    | 0 -> string info.Name\n                    | len ->\n                        let fieldTypes = info.GetFields()\n                        let target = Array.zeroCreate<JsonValue> (len + 1)\n                        target.[0] <- string info.Name\n                        for i = 1 to len do\n                            let encode = autoEncoder extra caseStrategy skipNullField fieldTypes.[i-1].PropertyType\n                            target.[i] <- encode fields.[i-1]\n                        array target\n            else\n                // Don't use failwithf here, for some reason F#/Fable compiles it as a function\n                // when the return type is a function too, so it doesn't fail immediately\n                sprintf \"Cannot generate auto encoder for %s. Please pass an extra encoder.\" t.FullName\n                |> failwith\n        encoderRef := encoder\n        encoder\n\n    and private autoEncoder (extra: Map<string, ref<BoxedEncoder>>) caseStrategy (skipNullField : bool) (t: System.Type) : BoxedEncoder =\n      let fullname = t.FullName\n      match Map.tryFind fullname extra with\n      | Some encoderRef -> fun v -> encoderRef.contents v\n      | None ->\n        if t.IsArray then\n            let encoder = t.GetElementType() |> autoEncoder extra caseStrategy skipNullField\n            fun (value: obj) ->\n                value :?> obj seq |> Seq.map encoder |> seq\n        elif t.IsEnum then\n            let enumType = System.Enum.GetUnderlyingType(t).FullName\n            if enumType = typeof<sbyte>.FullName then\n                boxEncoder sbyte\n            elif enumType = typeof<byte>.FullName then\n                boxEncoder byte\n            elif enumType = typeof<int16>.FullName then\n                boxEncoder int16\n            elif enumType = typeof<uint16>.FullName then\n                boxEncoder uint16\n            elif enumType = typeof<int>.FullName then\n                boxEncoder int\n            elif enumType = typeof<uint32>.FullName then\n                boxEncoder uint32\n            else\n                failwithf\n                    \"\"\"Cannot generate auto encoder for %s.\nThoth.Json.Net only support the folluwing enum types:\n- sbyte\n- byte\n- int16\n- uint16\n- int\n- uint32\nIf you can't use one of these types, please pass an extra encoder.\n                    \"\"\" t.FullName\n        elif t.IsGenericType then\n            if FSharpType.IsTuple(t) then\n                let encoders =\n                    FSharpType.GetTupleElements(t)\n                    |> Array.map (autoEncoder extra caseStrategy skipNullField)\n                fun (value: obj) ->\n                    FSharpValue.GetTupleFields(value)\n                    |> Seq.mapi (fun i x -> encoders.[i] x) |> seq\n            else\n                let fullname = t.GetGenericTypeDefinition().FullName\n                if fullname = typedefof<obj option>.FullName then\n                    // Evaluate lazily so we don't need to generate the encoder for null values\n                    let encoder = lazy\n                                    t.GenericTypeArguments.[0]\n                                    |> autoEncoder extra caseStrategy skipNullField\n                                    |> option\n                                    |> boxEncoder\n                    boxEncoder(fun (value: obj) ->\n                        if isNull value then nil\n                        else encoder.Value value)\n                elif fullname = typedefof<obj list>.FullName\n                    || fullname = typedefof<Set<string>>.FullName then\n                    // Disable seq support for now because I don't know how to implements to on Thoth.Json.Net\n                    // || fullname = typedefof<obj seq>.FullName then\n                    let encoder = t.GenericTypeArguments.[0] |> autoEncoder extra caseStrategy skipNullField\n                    fun (value: obj) ->\n                        value :?> obj seq |> Seq.map encoder |> seq\n                elif fullname = typedefof< Map<string, obj> >.FullName then\n                    let keyType = t.GenericTypeArguments.[0]\n                    let valueEncoder = t.GenericTypeArguments.[1] |> autoEncoder extra caseStrategy skipNullField\n                    if keyType.FullName = typeof<string>.FullName\n                        || keyType.FullName = typeof<System.Guid>.FullName then\n                        fun value ->\n                            // Fable compiles Guids as strings so this works, but maybe we should make the conversion explicit\n                            // (see dotnet version) in case Fable implementation of Guids change\n                            (JsonValue(), value :?> Map<string, obj>)\n                            ||> Seq.fold (fun target (KeyValue(k,v)) ->\n                                target.[k] <- valueEncoder v\n                                target)\n                    else\n                        let keyEncoder = keyType |> autoEncoder extra caseStrategy skipNullField\n                        fun value ->\n                            value :?> Map<string, obj> |> Seq.map (fun (KeyValue(k,v)) ->\n                                array [|keyEncoder k; valueEncoder v|]) |> seq\n                else\n                    autoEncodeRecordsAndUnions extra caseStrategy skipNullField t\n        else\n            if fullname = typeof<bool>.FullName then\n                boxEncoder bool\n            elif fullname = typeof<unit>.FullName then\n                boxEncoder unit\n            elif fullname = typeof<string>.FullName then\n                boxEncoder string\n            elif fullname = typeof<sbyte>.FullName then\n                boxEncoder sbyte\n            elif fullname = typeof<byte>.FullName then\n                boxEncoder byte\n            elif fullname = typeof<int16>.FullName then\n                boxEncoder int16\n            elif fullname = typeof<uint16>.FullName then\n                boxEncoder uint16\n            elif fullname = typeof<int>.FullName then\n                boxEncoder int\n            elif fullname = typeof<uint32>.FullName then\n                boxEncoder uint32\n            elif fullname = typeof<float>.FullName then\n                boxEncoder float\n            elif fullname = typeof<float32>.FullName then\n                boxEncoder float32\n            // These number types require extra libraries in Fable. To prevent penalizing\n            // all users, extra encoders (withInt64, etc) must be passed when they're needed.\n\n            // elif fullname = typeof<int64>.FullName then\n            //     boxEncoder int64\n            // elif fullname = typeof<uint64>.FullName then\n            //     boxEncoder uint64\n            // elif fullname = typeof<bigint>.FullName then\n            //     boxEncoder bigint\n            // elif fullname = typeof<decimal>.FullName then\n            //     boxEncoder decimal\n            elif fullname = typeof<System.DateTime>.FullName then\n                boxEncoder datetime\n            elif fullname = typeof<System.DateTimeOffset>.FullName then\n                boxEncoder datetimeOffset\n            elif fullname = typeof<System.TimeSpan>.FullName then\n                boxEncoder timespan\n            elif fullname = typeof<System.Guid>.FullName then\n                boxEncoder guid\n            elif fullname = typeof<obj>.FullName then\n                boxEncoder id\n            else\n                autoEncodeRecordsAndUnions extra caseStrategy skipNullField t\n\n    let private makeExtra (extra: ExtraCoders option) =\n        match extra with\n        | None -> Map.empty\n        | Some e -> Map.map (fun _ (enc,_) -> ref enc) e.Coders\n\n    type Auto =\n        static member generateEncoderCached<'T>(?caseStrategy : CaseStrategy, ?extra: ExtraCoders, ?skipNullField: bool, [<Inject>] ?resolver: ITypeResolver<'T>): Encoder<'T> =\n            let t = Util.resolveType resolver\n            let caseStrategy = defaultArg caseStrategy PascalCase\n            let skipNullField = defaultArg skipNullField true\n\n            let key =\n                t.FullName\n                |> (+) (Operators.string caseStrategy)\n                |> (+) (extra |> Option.map (fun e -> e.Hash) |> Option.defaultValue \"\")\n\n            Util.CachedEncoders.GetOrAdd(key , fun _ ->\n                autoEncoder (makeExtra extra) caseStrategy skipNullField t) |> unboxEncoder\n\n        static member generateEncoder<'T>(?caseStrategy : CaseStrategy, ?extra: ExtraCoders, ?skipNullField: bool, [<Inject>] ?resolver: ITypeResolver<'T>): Encoder<'T> =\n            let caseStrategy = defaultArg caseStrategy PascalCase\n            let skipNullField = defaultArg skipNullField true\n            Util.resolveType resolver\n            |> autoEncoder (makeExtra extra) caseStrategy skipNullField |> unboxEncoder\n\n        static member toString(space : int, value : 'T, ?caseStrategy : CaseStrategy, ?extra: ExtraCoders, ?skipNullField: bool, [<Inject>] ?resolver: ITypeResolver<'T>) : string =\n            let encoder = Auto.generateEncoder(?caseStrategy=caseStrategy, ?extra=extra, ?skipNullField=skipNullField, ?resolver=resolver)\n            encoder value |> toString space\n\n    ///**Description**\n    /// Convert a `Value` into a prettified string.\n    ///**Parameters**\n    ///  * `space` - parameter of type `int` - Amount of indentation\n    ///  * `value` - parameter of type `obj` - Value to convert\n    ///\n    ///**Output Type**\n    ///  * `string`\n    ///\n    ///**Exceptions**\n    ///\n    [<System.Obsolete(\"Please use toString instead\")>]\n    let encode (space: int) (value: JsonValue) : string = toString space value\n","[<AutoOpen>]\nmodule PromiseImpl\n\nlet promise = Promise.PromiseBuilder()","module Thoth.Fetch\n\nopen Fetch\nopen Fable.Core\nopen Fable.Core.JsInterop\nopen Thoth.Json\n\ntype FetchError =\n    | PreparingRequestFailed of exn\n    | DecodingFailed of string\n    | FetchFailed of Response\n    | NetworkError of exn\n\nmodule Helper =\n\n    [<Erase>]\n    type GlobalFetch =\n        [<Global>]\n        static member fetch (req: RequestInfo, ?init: RequestInit): JS.Promise<Response> = jsNative\n\n    let fetch (url: string) (init: RequestProperties list): JS.Promise<Response> =\n        GlobalFetch.fetch (RequestInfo.Url url, requestProps init)\n\n    let withContentTypeJson data headers =\n        match data with\n        | Some _ -> ContentType \"application/json\" :: headers\n        | _ -> headers\n\n    let encode data caseStrategy extra dataResolver =\n        let encoder =\n            Encode.Auto.generateEncoderCached (?caseStrategy = caseStrategy, ?extra = extra, ?resolver = dataResolver)\n\n        data\n        |> encoder\n        |> Encode.toString 0\n\n    let withBody data caseStrategy extra dataResolver properties =\n        data\n        |> Option.map (fun data ->\n            encode data caseStrategy extra dataResolver\n            |> (!^)\n            |> Body\n            |> fun body -> body :: properties)\n        |> Option.defaultValue properties\n\n    let withProperties custom properties =\n        custom\n        |> Option.map ((@) properties)\n        |> Option.defaultValue properties\n\n    let eitherUnit (responseResolver: ITypeResolver<'Response>) cont =\n        if responseResolver.ResolveType().FullName = typedefof<unit>.FullName then Ok(unbox())\n        else cont()\n\n    let resolve (response: Response) caseStrategy extra (decoder: Decoder<'Response> option)\n        (responseResolver: ITypeResolver<'Response> option) =\n\n        let decoder =\n            decoder\n            |> Option.defaultValue\n                (Decode.Auto.generateDecoderCached\n                    (?caseStrategy = caseStrategy, ?extra = extra, ?resolver = responseResolver))\n\n        let decode body = Decode.fromString decoder body\n\n        let eitherUnitOr = eitherUnit responseResolver.Value\n\n        promise {\n            let! result =\n                if response.Ok then\n                    promise {\n                        let! body = response.text()\n                        return eitherUnitOr <| fun () ->\n                            match decode body with\n                            | Ok value -> Ok value\n                            | Error msg -> DecodingFailed msg |> Error\n                    }\n                else\n                    FetchFailed response |> Error\n                    |> Promise.lift\n            return result\n        }\n\n    let message error =\n        match error with\n        | PreparingRequestFailed exn ->\n            \"[Thoth.Fetch] Request preparation failed:\\n\\n\" + exn.Message\n        | DecodingFailed msg ->\n            \"[Thoth.Fetch] Error while decoding the response:\\n\\n\" + msg\n        | FetchFailed response ->\n            \"[Thoth.Fetch] Request failed:\\n\\n\" + string response.Status + \" \" + response.StatusText + \" for URL \" + response.Url\n        | NetworkError exn ->\n            \"[Thoth.Fetch] A network error occured:\\n\\n\" + exn.Message\n\nopen Helper\n\ntype Fetch =\n\n    /// **Description**\n    ///\n    /// Send a request to the specified resource and decodes the response.\n    ///\n    /// If fetch and decoding succeed, we return `Ok 'Response`.\n    ///\n    /// If we fail, we return `Error (FetchError)` containing an better explanation.\n    ///\n    /// **Parameters**\n    ///   * `url` - parameter of type `string` - URL to request\n    ///   * `decoder` - parameter of type `Decoder<'Response>` - Decoder applied to the server response\n    ///   * `httpMethod` - optional parameter of type `HttpMethod` - HttpMethod used for Request, defaults to **GET**\n    ///   * `data` - optional parameter of type `'Data` - Data sent via the body, it will be converted to JSON before\n    ///   * `properties` - optional parameter of type `RequestProperties list` - Parameters passed to fetch\n    ///   * `headers` - optional parameter of type `HttpRequestHeaders list` - Parameters passed to fetch's properties\n    ///   * `caseStrategy` - optional parameter of type `CaseStrategy` - Options passed to Thoth.Json to control JSON keys representation\n    ///   * `extra` - optional parameter of type `ExtraCoders` - Options passed to Thoth.Json to extends the known coders\n    ///   * `responseResolver` - optional parameter of type `ITypeResolver<'Response>` - Used by Fable to provide generic type info\n    ///   * `dataResolver` - parameter of type `ITypeResolver<'Data> option` - Used by Fable to provide generic type info\n    ///\n    /// **Output Type**\n    ///   * `JS.Promise<Result<'Response,FetchError>>`\n    ///\n    /// **Exceptions**\n    ///\n    static member tryFetchAs<'Data, 'Response> (url: string, ?decoder: Decoder<'Response>, ?data: 'Data,\n                                                ?httpMethod: HttpMethod, ?properties: RequestProperties list,\n                                                ?headers: HttpRequestHeaders list, ?caseStrategy: CaseStrategy,\n                                                ?extra: ExtraCoders,\n                                                [<Inject>] ?responseResolver: ITypeResolver<'Response>,\n                                                [<Inject>] ?dataResolver: ITypeResolver<'Data>) =\n        try\n            let properties =\n                [ Method <| defaultArg httpMethod HttpMethod.GET\n                  requestHeaders (defaultArg headers [] |> withContentTypeJson data) ]\n                |> withBody data caseStrategy extra dataResolver\n                |> withProperties properties\n\n            promise {\n                let! response = fetch url properties\n                return! resolve response caseStrategy extra decoder responseResolver\n            }\n            |> Promise.catch (NetworkError >> Error)\n\n        with exn -> promise { return PreparingRequestFailed exn |> Error }\n\n    /// **Description**\n    ///\n    /// Send a request to the specified resource and decodes the response.\n    ///\n    /// This method set the `ContentType` header to `\"application/json\"` if data is provided.\n    ///\n    //// An exception will be thrown if fetch fails.\n    ///\n    /// **Parameters**\n    ///   * `url` - parameter of type `string` - URL to request\n    ///   * `decoder` - parameter of type `Decoder<'Response>` - Decoder applied to the server response\n    ///   * `httpMethod` - optional parameter of type `HttpMethod` - HttpMethod used, defaults to **GET**\n    ///   * `data` - optional parameter of type `'Data` - Data sent via the body, it will be converted to JSON before\n    ///   * `properties` - optional parameter of type `RequestProperties list` - Parameters passed to fetch\n    ///   * `headers` - optional parameter of type `HttpRequestHeaders list` - Parameters passed to fetch's properties\n    ///   * `caseStrategy` - optional parameter of type `CaseStrategy` - Options passed to Thoth.Json to control JSON keys representation\n    ///   * `extra` - optional parameter of type `ExtraCoders` - Options passed to Thoth.Json to extends the known coders\n    ///   * `responseResolver` - optional parameter of type `ITypeResolver<'Response>` - Used by Fable to provide generic type info\n    ///   * `dataResolver` - parameter of type `ITypeResolver<'Data> option` - Used by Fable to provide generic type info\n    ///\n    /// **Output Type**\n    ///   * `JS.Promise<'Response>`\n    ///\n    /// **Exceptions**\n    ///   * `System.Exception` - Contains information explaining why the request failed\n    ///\n    static member fetchAs<'Data, 'Response> (url: string, ?decoder: Decoder<'Response>, ?data: 'Data,\n                                             ?httpMethod: HttpMethod, ?properties: RequestProperties list,\n                                             ?headers: HttpRequestHeaders list, ?caseStrategy: CaseStrategy, ?extra: ExtraCoders,\n                                             [<Inject>] ?responseResolver: ITypeResolver<'Response>,\n                                             [<Inject>] ?dataResolver: ITypeResolver<'Data>) =\n        promise {\n            let! result = Fetch.tryFetchAs<'Data, 'Response>\n                              (url, ?decoder = decoder, ?httpMethod = httpMethod, ?data = data, ?properties = properties,\n                               ?headers = headers, ?caseStrategy = caseStrategy, ?extra = extra,\n                               ?responseResolver = responseResolver, ?dataResolver = dataResolver)\n            let response =\n                match result with\n                | Ok response -> response\n                | Error error -> failwith (message error)\n            return response\n        }\n\n    /// **Description**\n    ///\n    /// Send a **GET** request to the specified resource and decodes the response.\n    ///\n    /// This method set the `ContentType` header to `\"application/json\"` if data is provided.\n    ///\n    //// An exception will be thrown if the request fails.\n    ///\n    /// **Parameters**\n    ///   * `url` - parameter of type `string` - URL to request\n    ///   * `data` - optional parameter of type `'Data` - Data sent via the body, it will be converted to JSON before\n    ///   * `properties` - optional parameter of type `RequestProperties list` - Parameters passed to fetch\n    ///   * `headers` - optional parameter of type `HttpRequestHeaders list` - Parameters passed to fetch's properties\n    ///   * `caseStrategy` - optional parameter of type `CaseStrategy` - Options passed to Thoth.Json to control JSON keys representation\n    ///   * `extra` - optional parameter of type `ExtraCoders` - Options passed to Thoth.Json to extends the known coders\n    ///   * `decoder` - parameter of type `Decoder<'Response>` - Decoder applied to the server response\n    ///   * `responseResolver` - optional parameter of type `ITypeResolver<'Response>` - Used by Fable to provide generic type info\n    ///   * `dataResolver` - parameter of type `ITypeResolver<'Data> option` - Used by Fable to provide generic type info\n    ///\n    /// **Output Type**\n    ///   * `JS.Promise<'Response>`\n    ///\n    /// **Exceptions**\n    ///   * `System.Exception` - Contains information explaining why the request failed\n    ///\n    static member get<'Data, 'Response> (url: string, ?data: 'Data, ?properties: RequestProperties list,\n                                         ?headers: HttpRequestHeaders list, ?caseStrategy: CaseStrategy,\n                                         ?extra: ExtraCoders, ?decoder: Decoder<'Response>,\n                                         [<Inject>] ?responseResolver: ITypeResolver<'Response>,\n                                         [<Inject>] ?dataResolver: ITypeResolver<'Data>) =\n        Fetch.fetchAs\n            (url, ?data = data, ?properties = properties, ?headers = headers, ?caseStrategy = caseStrategy, ?extra = extra,\n             ?decoder = decoder, ?responseResolver = responseResolver, ?dataResolver = dataResolver)\n\n    /// **Description**\n    ///\n    /// Send a **GET** request to the specified resource and decodes the response.\n    ///\n    /// This method set the `ContentType` header to `\"application/json\"`.\n    ///\n    //// If we fail, we return `Error (FetchError)` containing an better explanation.\n    ///\n    /// **Parameters**\n    ///   * `url` - parameter of type `string` - URL to request\n    ///   * `data` - optional parameter of type `'Data` - Data sent via the body, it will be converted to JSON before\n    ///   * `properties` - optional parameter of type `RequestProperties list` - Parameters passed to fetch\n    ///   * `headers` - optional parameter of type `HttpRequestHeaders list` - Parameters passed to fetch's properties\n    ///   * `caseStrategy` - optional parameter of type `CaseStrategy` - Options passed to Thoth.Json to control JSON keys representation\n    ///   * `extra` - optional parameter of type `ExtraCoders` - Options passed to Thoth.Json to extends the known coders\n    ///   * `decoder` - parameter of type `Decoder<'Response>` - Decoder applied to the server response\n    ///   * `responseResolver` - optional parameter of type `ITypeResolver<'Response>` - Used by Fable to provide generic type info\n    ///   * `dataResolver` - parameter of type `ITypeResolver<'Data> option` - Used by Fable to provide generic type info\n    ///\n    /// **Output Type**\n    ///   * `JS.Promise<Result<'Response,FetchError>>`\n    ///\n    /// **Exceptions**\n    ///\n    static member tryGet<'Data, 'Response> (url: string, ?data: 'Data, ?properties: RequestProperties list,\n                                            ?headers: HttpRequestHeaders list, ?caseStrategy: CaseStrategy, ?extra: ExtraCoders,\n                                            ?decoder: Decoder<'Response>,\n                                            [<Inject>] ?responseResolver: ITypeResolver<'Response>,\n                                            [<Inject>] ?dataResolver: ITypeResolver<'Data>) =\n        Fetch.tryFetchAs\n            (url, ?data = data, ?properties = properties, ?headers = headers, ?caseStrategy = caseStrategy, ?extra = extra,\n             ?decoder = decoder, ?responseResolver = responseResolver, ?dataResolver = dataResolver)\n\n    /// **Description**\n    ///\n    /// Send a **POST** request to the specified resource and decodes the response.\n    ///\n    /// This method set the `ContentType` header to `\"application/json\"` if data is provided.\n    ///\n    //// An exception will be thrown if the request fails.\n    ///\n    /// **Parameters**\n    ///   * `url` - parameter of type `string` - URL to request\n    ///   * `data` - optional parameter of type `'Data` - Data sent via the body, it will be converted to JSON before\n    ///   * `properties` - optional parameter of type `RequestProperties list` - Parameters passed to fetch\n    ///   * `headers` - optional parameter of type `HttpRequestHeaders list` - Parameters passed to fetch's properties\n    ///   * `caseStrategy` - optional parameter of type `CaseStrategy` - Options passed to Thoth.Json to control JSON keys representation\n    ///   * `extra` - optional parameter of type `ExtraCoders` - Options passed to Thoth.Json to extends the known coders\n    ///   * `decoder` - parameter of type `Decoder<'Response>` - Decoder applied to the server response\n    ///   * `responseResolver` - optional parameter of type `ITypeResolver<'Response>` - Used by Fable to provide generic type info\n    ///   * `dataResolver` - parameter of type `ITypeResolver<'Data> option` - Used by Fable to provide generic type info\n    ///\n    /// **Output Type**\n    ///   * `JS.Promise<'Response>`\n    ///\n    /// **Exceptions**\n    ///   * `System.Exception` - Contains information explaining why the request failed\n    ///\n    static member post<'Data, 'Response> (url: string, ?data: 'Data, ?properties: RequestProperties list,\n                                          ?headers: HttpRequestHeaders list, ?caseStrategy: CaseStrategy,\n                                          ?extra: ExtraCoders, ?decoder: Decoder<'Response>,\n                                          [<Inject>] ?responseResolver: ITypeResolver<'Response>,\n                                          [<Inject>] ?dataResolver: ITypeResolver<'Data>) =\n        Fetch.fetchAs\n            (url, httpMethod = HttpMethod.POST, ?data = data, ?properties = properties, ?headers = headers,\n             ?caseStrategy = caseStrategy, ?extra = extra, ?decoder = decoder, ?responseResolver = responseResolver,\n             ?dataResolver = dataResolver)\n\n    /// **Description**\n    ///\n    /// Send a **POST** request to the specified resource and decodes the response.\n    ///\n    /// This method set the `ContentType` header to `\"application/json\"`.\n    ///\n    //// If we failed, we return `Error (FetchError)` containing an better explanation.\n    ///\n    /// **Parameters**\n    ///   * `url` - parameter of type `string` - URL to request\n    ///   * `data` - optional parameter of type `'Data` - Data sent via the body, it will be converted to JSON before\n    ///   * `properties` - optional parameter of type `RequestProperties list` - Parameters passed to fetch\n    ///   * `headers` - optional parameter of type `HttpRequestHeaders list` - Parameters passed to fetch's properties\n    ///   * `caseStrategy` - optional parameter of type `CaseStrategy` - Options passed to Thoth.Json to control JSON keys representation\n    ///   * `extra` - optional parameter of type `ExtraCoders` - Options passed to Thoth.Json to extends the known coders\n    ///   * `decoder` - parameter of type `Decoder<'Response>` - Decoder applied to the server response\n    ///   * `responseResolver` - optional parameter of type `ITypeResolver<'Response>` - Used by Fable to provide generic type info\n    ///   * `dataResolver` - parameter of type `ITypeResolver<'Data> option` - Used by Fable to provide generic type info\n    ///\n    /// **Output Type**\n    ///   * `JS.Promise<Result<'Response,FetchError>>`\n    ///\n    /// **Exceptions**\n    ///\n    static member tryPost<'Data, 'Response> (url: string, ?data: 'Data, ?properties: RequestProperties list,\n                                             ?headers: HttpRequestHeaders list, ?caseStrategy: CaseStrategy, ?extra: ExtraCoders,\n                                             ?decoder: Decoder<'Response>,\n                                             [<Inject>] ?responseResolver: ITypeResolver<'Response>,\n                                             [<Inject>] ?dataResolver: ITypeResolver<'Data>) =\n        Fetch.tryFetchAs\n            (url, httpMethod = HttpMethod.POST, ?data = data, ?properties = properties, ?headers = headers,\n             ?caseStrategy = caseStrategy, ?extra = extra, ?decoder = decoder, ?responseResolver = responseResolver,\n             ?dataResolver = dataResolver)\n\n    /// **Description**\n    ///\n    /// Send a **PUT** request to the specified resource and decodes the response.\n    ///\n    /// This method set the `ContentType` header to `\"application/json\"` if data is provided.\n    ///\n    //// An exception will be thrown if the request fails.\n    ///\n    /// **Parameters**\n    ///   * `url` - parameter of type `string` - URL to request\n    ///   * `data` - optional parameter of type `'Data` - Data sent via the body, it will be converted to JSON before\n    ///   * `properties` - optional parameter of type `RequestProperties list` - Parameters passed to fetch\n    ///   * `headers` - optional parameter of type `HttpRequestHeaders list` - Parameters passed to fetch's properties\n    ///   * `caseStrategy` - optional parameter of type `CaseStrategy` - Options passed to Thoth.Json to control JSON keys representation\n    ///   * `extra` - optional parameter of type `ExtraCoders` - Options passed to Thoth.Json to extends the known coders\n    ///   * `decoder` - parameter of type `Decoder<'Response>` - Decoder applied to the server response\n    ///   * `responseResolver` - optional parameter of type `ITypeResolver<'Response>` - Used by Fable to provide generic type info\n    ///   * `dataResolver` - parameter of type `ITypeResolver<'Data> option` - Used by Fable to provide generic type info\n    ///\n    /// **Output Type**\n    ///   * `JS.Promise<'Response>`\n    ///\n    /// **Exceptions**\n    ///   * `System.Exception` - Contains information explaining why the request failed\n    ///\n    static member put<'Data, 'Response> (url: string, ?data: 'Data, ?properties: RequestProperties list,\n                                         ?headers: HttpRequestHeaders list, ?caseStrategy: CaseStrategy,\n                                         ?extra: ExtraCoders, ?decoder: Decoder<'Response>,\n                                         [<Inject>] ?responseResolver: ITypeResolver<'Response>,\n                                         [<Inject>] ?dataResolver: ITypeResolver<'Data>) =\n        Fetch.fetchAs\n            (url, httpMethod = HttpMethod.PUT, ?data = data, ?properties = properties, ?headers = headers,\n             ?caseStrategy = caseStrategy, ?extra = extra, ?decoder = decoder, ?responseResolver = responseResolver,\n             ?dataResolver = dataResolver)\n\n    /// **Description**\n    ///\n    /// Send a **PUT** request to the specified resource and decodes the response.\n    ///\n    /// This method set the `ContentType` header to `\"application/json\"`.\n    ///\n    //// If we failed, we return `Error (FetchError)` containing an better explanation.\n    ///\n    /// **Parameters**\n    ///   * `url` - parameter of type `string` - URL to request\n    ///   * `data` - optional parameter of type `'Data` - Data sent via the body, it will be converted to JSON before\n    ///   * `properties` - optional parameter of type `RequestProperties list` - Parameters passed to fetch\n    ///   * `headers` - optional parameter of type `HttpRequestHeaders list` - Parameters passed to fetch's properties\n    ///   * `caseStrategy` - optional parameter of type `CaseStrategy` - Options passed to Thoth.Json to control JSON keys representation\n    ///   * `extra` - optional parameter of type `ExtraCoders` - Options passed to Thoth.Json to extends the known coders\n    ///   * `decoder` - parameter of type `Decoder<'Response>` - Decoder applied to the server response\n    ///   * `responseResolver` - optional parameter of type `ITypeResolver<'Response>` - Used by Fable to provide generic type info\n    ///   * `dataResolver` - parameter of type `ITypeResolver<'Data> option` - Used by Fable to provide generic type info\n    ///\n    /// **Output Type**\n    ///   * `JS.Promise<Result<'Response,FetchError>>`\n    ///\n    /// **Exceptions**\n    ///\n    static member tryPut<'Data, 'Response> (url: string, ?data: 'Data, ?properties: RequestProperties list,\n                                            ?headers: HttpRequestHeaders list, ?caseStrategy: CaseStrategy, ?extra: ExtraCoders,\n                                            ?decoder: Decoder<'Response>,\n                                            [<Inject>] ?responseResolver: ITypeResolver<'Response>,\n                                            [<Inject>] ?dataResolver: ITypeResolver<'Data>) =\n        Fetch.tryFetchAs\n            (url, httpMethod = HttpMethod.PUT, ?data = data, ?properties = properties, ?headers = headers,\n             ?caseStrategy = caseStrategy, ?extra = extra, ?decoder = decoder, ?responseResolver = responseResolver,\n             ?dataResolver = dataResolver)\n\n    /// **Description**\n    ///\n    /// Send a **PATCH** request to the specified resource and decodes the response.\n    ///\n    /// This method set the `ContentType` header to `\"application/json\"` if data is provided.\n    ///\n    //// An exception will be thrown if the request fails.\n    ///\n    /// **Parameters**\n    ///   * `url` - parameter of type `string` - URL to request\n    ///   * `data` - optional parameter of type `'Data` - Data sent via the body, it will be converted to JSON before\n    ///   * `properties` - optional parameter of type `RequestProperties list` - Parameters passed to fetch\n    ///   * `headers` - optional parameter of type `HttpRequestHeaders list` - Parameters passed to fetch's properties\n    ///   * `caseStrategy` - optional parameter of type `CaseStrategy` - Options passed to Thoth.Json to control JSON keys representation\n    ///   * `extra` - optional parameter of type `ExtraCoders` - Options passed to Thoth.Json to extends the known coders\n    ///   * `decoder` - parameter of type `Decoder<'Response>` - Decoder applied to the server response\n    ///   * `responseResolver` - optional parameter of type `ITypeResolver<'Response>` - Used by Fable to provide generic type info\n    ///   * `dataResolver` - parameter of type `ITypeResolver<'Data> option` - Used by Fable to provide generic type info\n    ///\n    /// **Output Type**\n    ///   * `JS.Promise<'Response>`\n    ///\n    /// **Exceptions**\n    ///   * `System.Exception` - Contains information explaining why the request failed\n    ///\n    static member patch<'Data, 'Response> (url: string, ?data: 'Data, ?properties: RequestProperties list,\n                                           ?headers: HttpRequestHeaders list, ?caseStrategy: CaseStrategy,\n                                           ?extra: ExtraCoders, ?decoder: Decoder<'Response>,\n                                           [<Inject>] ?responseResolver: ITypeResolver<'Response>,\n                                           [<Inject>] ?dataResolver: ITypeResolver<'Data>) =\n        Fetch.fetchAs\n            (url, httpMethod = HttpMethod.PATCH, ?data = data, ?properties = properties, ?headers = headers,\n             ?caseStrategy = caseStrategy, ?extra = extra, ?decoder = decoder, ?responseResolver = responseResolver,\n             ?dataResolver = dataResolver)\n\n    /// **Description**\n    ///\n    /// Send a **PATCH** request to the specified resource and decodes the response.\n    ///\n    /// This method set the `ContentType` header to `\"application/json\"`.\n    ///\n    //// If we failed, we return `Error (FetchError)` containing an better explanation.\n    ///\n    /// **Parameters**\n    ///   * `url` - parameter of type `string` - URL to request\n    ///   * `data` - optional parameter of type `'Data` - Data sent via the body, it will be converted to JSON before\n    ///   * `properties` - optional parameter of type `RequestProperties list` - Parameters passed to fetch\n    ///   * `headers` - optional parameter of type `HttpRequestHeaders list` - Parameters passed to fetch's properties\n    ///   * `caseStrategy` - optional parameter of type `CaseStrategy` - Options passed to Thoth.Json to control JSON keys representation\n    ///   * `extra` - optional parameter of type `ExtraCoders` - Options passed to Thoth.Json to extends the known coders\n    ///   * `decoder` - parameter of type `Decoder<'Response>` - Decoder applied to the server response\n    ///   * `responseResolver` - optional parameter of type `ITypeResolver<'Response>` - Used by Fable to provide generic type info\n    ///   * `dataResolver` - parameter of type `ITypeResolver<'Data> option` - Used by Fable to provide generic type info\n    ///\n    /// **Output Type**\n    ///   * `JS.Promise<Result<'Response,FetchError>>`\n    ///\n    /// **Exceptions**\n    ///\n    static member tryPatch<'Data, 'Response> (url: string, ?data: 'Data, ?properties: RequestProperties list,\n                                              ?headers: HttpRequestHeaders list, ?caseStrategy: CaseStrategy, ?extra: ExtraCoders,\n                                              ?decoder: Decoder<'Response>,\n                                              [<Inject>] ?responseResolver: ITypeResolver<'Response>,\n                                              [<Inject>] ?dataResolver: ITypeResolver<'Data>) =\n        Fetch.tryFetchAs\n            (url, httpMethod = HttpMethod.PATCH, ?data = data, ?properties = properties, ?headers = headers,\n             ?caseStrategy = caseStrategy, ?extra = extra, ?decoder = decoder, ?responseResolver = responseResolver,\n             ?dataResolver = dataResolver)\n\n    /// **Description**\n    ///\n    /// Send a **DELETE** request to the specified resource and decodes the response.\n    ///\n    /// This method set the `ContentType` header to `\"application/json\"` if data is provided.\n    ///\n    //// An exception will be thrown if the request fails.\n    ///\n    /// **Parameters**\n    ///   * `url` - parameter of type `string` - URL to request\n    ///   * `data` - optional parameter of type `'Data` - Data sent via the body, it will be converted to JSON before\n    ///   * `properties` - optional parameter of type `RequestProperties list` - Parameters passed to fetch\n    ///   * `headers` - optional parameter of type `HttpRequestHeaders list` - Parameters passed to fetch's properties\n    ///   * `caseStrategy` - optional parameter of type `CaseStrategy` - Options passed to Thoth.Json to control JSON keys representation\n    ///   * `extra` - optional parameter of type `ExtraCoders` - Options passed to Thoth.Json to extends the known coders\n    ///   * `decoder` - parameter of type `Decoder<'Response>` - Decoder applied to the server response\n    ///   * `responseResolver` - optional parameter of type `ITypeResolver<'Response>` - Used by Fable to provide generic type info\n    ///   * `dataResolver` - parameter of type `ITypeResolver<'Data> option` - Used by Fable to provide generic type info\n    ///\n    /// **Output Type**\n    ///   * `JS.Promise<'Response>`\n    ///\n    /// **Exceptions**\n    ///   * `System.Exception` - Contains information explaining why the request failed\n    ///\n    static member delete<'Data, 'Response> (url: string, ?data: 'Data, ?properties: RequestProperties list,\n                                            ?headers: HttpRequestHeaders list, ?caseStrategy: CaseStrategy, ?extra: ExtraCoders,\n                                            ?decoder: Decoder<'Response>,\n                                            [<Inject>] ?responseResolver: ITypeResolver<'Response>,\n                                            [<Inject>] ?dataResolver: ITypeResolver<'Data>) =\n        Fetch.fetchAs\n            (url, httpMethod = HttpMethod.DELETE, ?data = data, ?properties = properties, ?headers = headers,\n             ?caseStrategy = caseStrategy, ?extra = extra, ?decoder = decoder, ?responseResolver = responseResolver,\n             ?dataResolver = dataResolver)\n\n    /// **Description**\n    ///\n    /// Send a **DELETE** request to the specified resource and decodes the response.\n    ///\n    /// This method set the `ContentType` header to `\"application/json\"`.\n    ///\n    //// If we failed, we return `Error (FetchError)` containing an better explanation.\n    ///\n    /// **Parameters**\n    ///   * `url` - parameter of type `string` - URL to request\n    ///   * `data` - optional parameter of type `'Data` - Data sent via the body, it will be converted to JSON before\n    ///   * `properties` - optional parameter of type `RequestProperties list` - Parameters passed to fetch\n    ///   * `headers` - optional parameter of type `HttpRequestHeaders list` - Parameters passed to fetch's properties\n    ///   * `caseStrategy` - optional parameter of type `CaseStrategy` - Options passed to Thoth.Json to control JSON keys representation\n    ///   * `extra` - optional parameter of type `ExtraCoders` - Options passed to Thoth.Json to extends the known coders\n    ///   * `decoder` - parameter of type `Decoder<'Response>` - Decoder applied to the server response\n    ///   * `responseResolver` - optional parameter of type `ITypeResolver<'Response>` - Used by Fable to provide generic type info\n    ///   * `dataResolver` - parameter of type `ITypeResolver<'Data> option` - Used by Fable to provide generic type info\n    ///\n    /// **Output Type**\n    ///   * `JS.Promise<Result<'Response,FetchError>>`\n    ///\n    /// **Exceptions**\n    ///\n    static member tryDelete<'Data, 'Response> (url: string, ?data: 'Data, ?properties: RequestProperties list,\n                                               ?headers: HttpRequestHeaders list, ?caseStrategy: CaseStrategy,\n                                               ?extra: ExtraCoders, ?decoder: Decoder<'Response>,\n                                               [<Inject>] ?responseResolver: ITypeResolver<'Response>,\n                                               [<Inject>] ?dataResolver: ITypeResolver<'Data>) =\n        Fetch.tryFetchAs\n            (url, httpMethod = HttpMethod.DELETE, ?data = data, ?properties = properties, ?headers = headers,\n             ?caseStrategy = caseStrategy, ?extra = extra, ?decoder = decoder, ?responseResolver = responseResolver,\n             ?dataResolver = dataResolver)\n","﻿module ExpectedValues\n\nopen Thoth.Fetch\nopen Thoth.Json\nopen DecoderExtra\nopen BattleResult\n\ntype ExpectedValues =\n    { DamageDealtTarget: float\n      SpotsTarget: float\n      FragsTarget: float\n      DefencePointsTarget: float\n      WinRateTarget: float }\n\nlet internal decodeExpectedValuesMap =\n    decoder {\n        let! vehicleId = Decode.field \"IDNum\" Decode.int\n        let! avgDamageDealt = Decode.field \"expDamage\" Decode.float\n        let! avgSpots = Decode.field \"expSpot\" Decode.float\n        let! avgFrags = Decode.field \"expFrag\" Decode.float\n        let! avgDefencePoints = Decode.field \"expDef\" Decode.float\n        let! winRate = Decode.field \"expWinRate\" Decode.float\n\n        return VehicleId vehicleId,\n               { DamageDealtTarget = avgDamageDealt\n                 SpotsTarget = avgSpots\n                 FragsTarget = avgFrags\n                 DefencePointsTarget = avgDefencePoints\n                 WinRateTarget = winRate / 100. }\n    }\n    |> Decode.list\n    |> Decode.field \"data\"\n    |> Decode.map Map.ofList\n\nlet fetchExpectedValuesMap () =\n    Fetch.get\n        (\"https://static.modxvm.com/wn8-data-exp/json/wn8exp.json\", decoder = decodeExpectedValuesMap)\n\n","﻿module Protocol\n\nopen BattleResult\nopen Thoth.Json\nopen DecoderExtra\n\nmodule internal Helpers =\n    let encodeRequest method payload =\n        Encode.object\n            [ \"jsonrpc\", Encode.string \"2.0\"\n              \"method\", Encode.string method\n              \"params\", payload\n              \"id\", Encode.string method ]\n\n    let responseDecoder method payloadDecoder =\n        decoder {\n            do! Decode.field \"id\" <| Decode.stringLiteral method\n            return! Decode.field \"result\" payloadDecoder\n        }\n\n    let notificationDecoder method payloadDecoder =\n        decoder {\n            do! Decode.field \"method\" <| Decode.stringLiteral method\n            return! Decode.field \"params\" payloadDecoder\n        }\n\nlet internal SUBSCRIBE = \"subscribe\"\nlet internal GET_BATTLE_RESULTS = \"get_battle_results\"\n\ntype BattleResultsOffset = int\n\ntype InitRequest =\n    { BattleResultsOffset: BattleResultsOffset }\n\n    static member encode request =\n        Encode.list\n            [ Helpers.encodeRequest SUBSCRIBE Encode.nil\n              Helpers.encodeRequest GET_BATTLE_RESULTS\n              <| Encode.object [ \"after\", Encode.int request.BattleResultsOffset ] ]\n\n\ntype InitResponse =\n    { BattleResultsOffset: BattleResultsOffset\n      BattleResults: BattleResult List }\n\n    static member decoder: Decoder<InitResponse> =\n        let payloadDecoder =\n            decoder {\n                let! offset = Decode.field \"end\" Decode.int\n                let! battleResults =\n                    Decode.field \"battleResults\" <| Decode.list BattleResult.decoder\n                return { BattleResultsOffset = offset\n                         BattleResults = battleResults }\n            }\n\n        decoder {\n            do! Decode.index 0 <| Helpers.responseDecoder SUBSCRIBE (Decode.succeed ())\n            return! Decode.index 1 <| Helpers.responseDecoder GET_BATTLE_RESULTS payloadDecoder\n        }\n\ntype SubscriptionNotification =\n    { BattleResultsOffset: BattleResultsOffset\n      BattleResult: BattleResult }\n\n    static member decoder: Decoder<SubscriptionNotification> =\n        let payloadDecoder =\n            decoder {\n                let! offset = Decode.field \"timestamp\" Decode.int\n                let! battleResult = Decode.field \"battleResult\" BattleResult.decoder\n                return { BattleResultsOffset = offset\n                         BattleResult = battleResult }\n            }\n\n        Helpers.notificationDecoder \"subscription\" payloadDecoder\n","export class CancellationToken {\n    constructor(cancelled = false) {\n        this._id = 0;\n        this._cancelled = cancelled;\n        this._listeners = new Map();\n    }\n    get isCancelled() {\n        return this._cancelled;\n    }\n    cancel() {\n        if (!this._cancelled) {\n            this._cancelled = true;\n            for (const [, listener] of this._listeners) {\n                listener();\n            }\n        }\n    }\n    addListener(f) {\n        const id = this._id;\n        this._listeners.set(this._id++, f);\n        return id;\n    }\n    removeListener(id) {\n        return this._listeners.delete(id);\n    }\n    register(f, state) {\n        const $ = this;\n        const id = this.addListener(state == null ? f : () => f(state));\n        return { Dispose() { $.removeListener(id); } };\n    }\n}\nexport class OperationCanceledError extends Error {\n    constructor() {\n        super(\"The operation was canceled\");\n        Object.setPrototypeOf(this, OperationCanceledError.prototype);\n    }\n}\nexport class Trampoline {\n    constructor() {\n        this.callCount = 0;\n    }\n    static get maxTrampolineCallCount() {\n        return 2000;\n    }\n    incrementAndCheck() {\n        return this.callCount++ > Trampoline.maxTrampolineCallCount;\n    }\n    hijack(f) {\n        this.callCount = 0;\n        setTimeout(f, 0);\n    }\n}\nexport function protectedCont(f) {\n    return (ctx) => {\n        if (ctx.cancelToken.isCancelled) {\n            ctx.onCancel(new OperationCanceledError());\n        }\n        else if (ctx.trampoline.incrementAndCheck()) {\n            ctx.trampoline.hijack(() => {\n                try {\n                    f(ctx);\n                }\n                catch (err) {\n                    ctx.onError(err);\n                }\n            });\n        }\n        else {\n            try {\n                f(ctx);\n            }\n            catch (err) {\n                ctx.onError(err);\n            }\n        }\n    };\n}\nexport function protectedBind(computation, binder) {\n    return protectedCont((ctx) => {\n        computation({\n            onSuccess: (x) => {\n                try {\n                    binder(x)(ctx);\n                }\n                catch (ex) {\n                    ctx.onError(ex);\n                }\n            },\n            onError: ctx.onError,\n            onCancel: ctx.onCancel,\n            cancelToken: ctx.cancelToken,\n            trampoline: ctx.trampoline,\n        });\n    });\n}\nexport function protectedReturn(value) {\n    return protectedCont((ctx) => ctx.onSuccess(value));\n}\nexport class AsyncBuilder {\n    Bind(computation, binder) {\n        return protectedBind(computation, binder);\n    }\n    Combine(computation1, computation2) {\n        return this.Bind(computation1, () => computation2);\n    }\n    Delay(generator) {\n        return protectedCont((ctx) => generator()(ctx));\n    }\n    For(sequence, body) {\n        const iter = sequence[Symbol.iterator]();\n        let cur = iter.next();\n        return this.While(() => !cur.done, this.Delay(() => {\n            const res = body(cur.value);\n            cur = iter.next();\n            return res;\n        }));\n    }\n    Return(value) {\n        return protectedReturn(value);\n    }\n    ReturnFrom(computation) {\n        return computation;\n    }\n    TryFinally(computation, compensation) {\n        return protectedCont((ctx) => {\n            computation({\n                onSuccess: (x) => {\n                    compensation();\n                    ctx.onSuccess(x);\n                },\n                onError: (x) => {\n                    compensation();\n                    ctx.onError(x);\n                },\n                onCancel: (x) => {\n                    compensation();\n                    ctx.onCancel(x);\n                },\n                cancelToken: ctx.cancelToken,\n                trampoline: ctx.trampoline,\n            });\n        });\n    }\n    TryWith(computation, catchHandler) {\n        return protectedCont((ctx) => {\n            computation({\n                onSuccess: ctx.onSuccess,\n                onCancel: ctx.onCancel,\n                cancelToken: ctx.cancelToken,\n                trampoline: ctx.trampoline,\n                onError: (ex) => {\n                    try {\n                        catchHandler(ex)(ctx);\n                    }\n                    catch (ex2) {\n                        ctx.onError(ex2);\n                    }\n                },\n            });\n        });\n    }\n    Using(resource, binder) {\n        return this.TryFinally(binder(resource), () => resource.Dispose());\n    }\n    While(guard, computation) {\n        if (guard()) {\n            return this.Bind(computation, () => this.While(guard, computation));\n        }\n        else {\n            return this.Return(void 0);\n        }\n    }\n    Zero() {\n        return protectedCont((ctx) => ctx.onSuccess(void 0));\n    }\n}\nexport const singleton = new AsyncBuilder();\n//# sourceMappingURL=AsyncBuilder.js.map","import { OperationCanceledError, Trampoline } from \"./AsyncBuilder\";\nimport { CancellationToken } from \"./AsyncBuilder\";\nimport { protectedCont } from \"./AsyncBuilder\";\nimport { protectedBind } from \"./AsyncBuilder\";\nimport { protectedReturn } from \"./AsyncBuilder\";\nimport { choice1Of2, choice2Of2 } from \"./Option\";\nimport { map } from \"./Seq\";\n// Implemented just for type references\nexport default class Async {\n}\nfunction emptyContinuation(_x) {\n    // NOP\n}\n// MakeAsync: body:(AsyncActivation<'T> -> AsyncReturn) -> Async<'T>\nexport function makeAsync(body) {\n    return body;\n}\n// Invoke: computation: Async<'T> -> ctxt:AsyncActivation<'T> -> AsyncReturn\nexport function invoke(computation, ctx) {\n    return computation(ctx);\n}\n// CallThenInvoke: ctxt:AsyncActivation<'T> -> result1:'U -> part2:('U -> Async<'T>) -> AsyncReturn\nexport function callThenInvoke(ctx, result1, part2) {\n    return part2(result1)(ctx);\n}\n// Bind: ctxt:AsyncActivation<'T> -> part1:Async<'U> -> part2:('U -> Async<'T>) -> AsyncReturn\nexport function bind(ctx, part1, part2) {\n    return protectedBind(part1, part2)(ctx);\n}\nexport function createCancellationToken(arg) {\n    const token = new CancellationToken(typeof arg === \"boolean\" ? arg : false);\n    if (typeof arg === \"number\") {\n        setTimeout(() => { token.cancel(); }, arg);\n    }\n    return token;\n}\nexport function cancel(token) {\n    token.cancel();\n}\nexport function cancelAfter(token, ms) {\n    setTimeout(() => { token.cancel(); }, ms);\n}\nexport function isCancellationRequested(token) {\n    return token != null && token.isCancelled;\n}\nexport function startChild(computation) {\n    const promise = startAsPromise(computation);\n    // JS Promises are hot, computation has already started\n    // but we delay returning the result\n    return protectedCont((ctx) => protectedReturn(awaitPromise(promise))(ctx));\n}\nexport function awaitPromise(p) {\n    return fromContinuations((conts) => p.then(conts[0]).catch((err) => (err instanceof OperationCanceledError\n        ? conts[2] : conts[1])(err)));\n}\nexport function cancellationToken() {\n    return protectedCont((ctx) => ctx.onSuccess(ctx.cancelToken));\n}\nexport const defaultCancellationToken = new CancellationToken();\nexport function catchAsync(work) {\n    return protectedCont((ctx) => {\n        work({\n            onSuccess: (x) => ctx.onSuccess(choice1Of2(x)),\n            onError: (ex) => ctx.onSuccess(choice2Of2(ex)),\n            onCancel: ctx.onCancel,\n            cancelToken: ctx.cancelToken,\n            trampoline: ctx.trampoline,\n        });\n    });\n}\nexport function fromContinuations(f) {\n    return protectedCont((ctx) => f([ctx.onSuccess, ctx.onError, ctx.onCancel]));\n}\nexport function ignore(computation) {\n    return protectedBind(computation, (_x) => protectedReturn(void 0));\n}\nexport function parallel(computations) {\n    return awaitPromise(Promise.all(map((w) => startAsPromise(w), computations)));\n}\nexport function sleep(millisecondsDueTime) {\n    return protectedCont((ctx) => {\n        let tokenId;\n        const timeoutId = setTimeout(() => {\n            ctx.cancelToken.removeListener(tokenId);\n            ctx.onSuccess(void 0);\n        }, millisecondsDueTime);\n        tokenId = ctx.cancelToken.addListener(() => {\n            clearTimeout(timeoutId);\n            ctx.onCancel(new OperationCanceledError());\n        });\n    });\n}\nexport function start(computation, cancellationToken) {\n    return startWithContinuations(computation, cancellationToken);\n}\nexport function startImmediate(computation, cancellationToken) {\n    return start(computation, cancellationToken);\n}\nexport function startWithContinuations(computation, continuation, exceptionContinuation, cancellationContinuation, cancelToken) {\n    if (typeof continuation !== \"function\") {\n        cancelToken = continuation;\n        continuation = undefined;\n    }\n    const trampoline = new Trampoline();\n    computation({\n        onSuccess: continuation ? continuation : emptyContinuation,\n        onError: exceptionContinuation ? exceptionContinuation : emptyContinuation,\n        onCancel: cancellationContinuation ? cancellationContinuation : emptyContinuation,\n        cancelToken: cancelToken ? cancelToken : defaultCancellationToken,\n        trampoline,\n    });\n}\nexport function startAsPromise(computation, cancellationToken) {\n    return new Promise((resolve, reject) => startWithContinuations(computation, resolve, reject, reject, cancellationToken ? cancellationToken : defaultCancellationToken));\n}\n//# sourceMappingURL=Async.js.map","namespace Elmish\n\n(**\nLog\n---------\nBasic cross-platform logging API.\n\n*)\nmodule internal Log =\n\n#if FABLE_COMPILER\n    open Fable.Core.JS\n\n    let onError (text: string, ex: exn) = console.error (text,ex)\n    let toConsole(text: string, o: #obj) = console.log(text,o)\n\n#else\n#if NETSTANDARD2_0\n    let onError (text: string, ex: exn) = System.Diagnostics.Trace.TraceError(\"{0}: {1}\", text, ex)\n    let toConsole(text: string, o: #obj) = printfn \"%s: %A\" text o\n#else\n    let onError (text: string, ex: exn) = System.Console.Error.WriteLine(\"{0}: {1}\", text, ex)\n    let toConsole(text: string, o: #obj) = printfn \"%s: %A\" text o\n#endif\n#endif\n\n#if FABLE_COMPILER\nmodule internal Timer =\n    open System.Timers\n    let delay interval callback =\n        let t = new Timer(float interval, AutoReset = false)\n        t.Elapsed.Add callback\n        t.Enabled <- true\n        t.Start()\n#endif\n","(**\nCmd\n---------\nCore abstractions for dispatching messages in Elmish.\n\n*)\n\nnamespace Elmish\n\nopen System\n\n/// Dispatch - feed new message into the processing loop\ntype Dispatch<'msg> = 'msg -> unit\n\n/// Subscription - return immediately, but may schedule dispatch of a message at any time\ntype Sub<'msg> = Dispatch<'msg> -> unit\n\n/// Cmd - container for subscriptions that may produce messages\ntype Cmd<'msg> = Sub<'msg> list\n\n/// Cmd module for creating and manipulating commands\n[<RequireQualifiedAccess>]\nmodule Cmd =\n    /// Execute the commands using the supplied dispatcher\n    let internal exec (dispatch:Dispatch<'msg>) (cmd:Cmd<'msg>) =\n        cmd |> List.iter (fun sub -> sub dispatch)\n\n    /// None - no commands, also known as `[]`\n    let none : Cmd<'msg> =\n        []\n\n    /// When emitting the message, map to another type\n    let map (f: 'a -> 'msg) (cmd: Cmd<'a>) : Cmd<'msg> =\n        cmd |> List.map (fun g -> (fun dispatch -> f >> dispatch) >> g)\n\n    /// Aggregate multiple commands\n    let batch (cmds: #seq<Cmd<'msg>>) : Cmd<'msg> =\n        cmds |> List.concat\n\n    /// Command to call the subscriber\n    let ofSub (sub: Sub<'msg>) : Cmd<'msg> =\n        [sub]\n\n    module OfFunc =\n        /// Command to evaluate a simple function and map the result\n        /// into success or error (of exception)\n        let either (task: 'a -> _) (arg: 'a) (ofSuccess: _ -> 'msg) (ofError: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                try\n                    task arg\n                    |> (ofSuccess >> dispatch)\n                with x ->\n                    x |> (ofError >> dispatch)\n            [bind]\n\n        /// Command to evaluate a simple function and map the success to a message\n        /// discarding any possible error\n        let perform (task: 'a -> _) (arg: 'a) (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                try\n                    task arg\n                    |> (ofSuccess >> dispatch)\n                with x ->\n                    ()\n            [bind]\n\n        /// Command to evaluate a simple function and map the error (in case of exception)\n        let attempt (task: 'a -> unit) (arg: 'a) (ofError: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                try\n                    task arg\n                with x ->\n                    x |> (ofError >> dispatch)\n            [bind]\n\n        /// Command to issue a specific message\n        let result (msg:'msg) : Cmd<'msg> =\n            [fun dispatch -> dispatch msg]\n\n    module OfAsyncWith =\n        /// Command that will evaluate an async block and map the result\n        /// into success or error (of exception)\n        let either (start: Async<unit> -> unit) \n                   (task: 'a -> Async<_>)\n                   (arg: 'a)\n                   (ofSuccess: _ -> 'msg)\n                   (ofError: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                async {\n                    let! r = task arg |> Async.Catch\n                    dispatch (match r with\n                             | Choice1Of2 x -> ofSuccess x\n                             | Choice2Of2 x -> ofError x)\n                }\n            [bind >> start]\n\n        /// Command that will evaluate an async block and map the success\n        let perform (start: Async<unit> -> unit) \n                    (task: 'a -> Async<_>)\n                    (arg: 'a)\n                    (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                async {\n                    let! r = task arg |> Async.Catch\n                    match r with\n                    | Choice1Of2 x -> dispatch (ofSuccess x)\n                    | _ -> ()\n                }\n            [bind >> start]\n\n        /// Command that will evaluate an async block and map the error (of exception)\n        let attempt (start: Async<unit> -> unit) \n                    (task: 'a -> Async<_>)\n                    (arg: 'a)\n                    (ofError: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                async {\n                    let! r = task arg |> Async.Catch\n                    match r with\n                    | Choice2Of2 x -> dispatch (ofError x)\n                    | _ -> ()\n                }\n            [bind >> start]\n\n        /// Command that will evaluate an async block to the message\n        let result (start: Async<unit> -> unit) \n                   (task: Async<'msg>) : Cmd<'msg> =\n            let bind dispatch =\n                async {\n                    let! r = task |> Async.Catch\n                    match r with\n                    | Choice1Of2 x -> dispatch x\n                    | _ -> ()\n                }\n            [bind >> start]\n\n    module OfAsync =\n#if FABLE_COMPILER\n        let start x = Timer.delay 0 (fun _ -> Async.StartImmediate x)\n#else\n        let inline start x = Async.Start x\n#endif    \n        /// Command that will evaluate an async block and map the result\n        /// into success or error (of exception)\n        let inline either (task: 'a -> Async<_>)\n                          (arg: 'a)\n                          (ofSuccess: _ -> 'msg)\n                          (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.either start task arg ofSuccess ofError\n\n        /// Command that will evaluate an async block and map the success\n        let inline perform (task: 'a -> Async<_>)\n                           (arg: 'a)\n                           (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.perform start task arg ofSuccess\n\n        /// Command that will evaluate an async block and map the error (of exception)\n        let inline attempt (task: 'a -> Async<_>)\n                           (arg: 'a)\n                           (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.attempt start task arg ofError\n\n        /// Command that will evaluate an async block to the message\n        let inline result (task: Async<'msg>) : Cmd<'msg> =\n            OfAsyncWith.result start task\n\n    module OfAsyncImmediate =\n        /// Command that will evaluate an async block and map the result\n        /// into success or error (of exception)\n        let inline either (task: 'a -> Async<_>)\n                          (arg: 'a)\n                          (ofSuccess: _ -> 'msg)\n                          (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.either Async.StartImmediate task arg ofSuccess ofError\n\n        /// Command that will evaluate an async block and map the success\n        let inline perform (task: 'a -> Async<_>)\n                           (arg: 'a)\n                           (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.perform Async.StartImmediate task arg ofSuccess\n\n        /// Command that will evaluate an async block and map the error (of exception)\n        let inline attempt (task: 'a -> Async<_>)\n                           (arg: 'a)\n                           (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.attempt Async.StartImmediate task arg ofError\n\n        /// Command that will evaluate an async block to the message\n        let inline result (task: Async<'msg>) : Cmd<'msg> =\n            OfAsyncWith.result Async.StartImmediate task\n\n#if FABLE_COMPILER\n    module OfPromise =\n        /// Command to call `promise` block and map the results\n        let either (task: 'a -> Fable.Core.JS.Promise<_>)\n                   (arg:'a)\n                   (ofSuccess: _ -> 'msg)\n                   (ofError: #exn -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                (task arg)\n                    .``then``(ofSuccess >> dispatch)\n                    .catch(unbox >> ofError >> dispatch)\n                    |> ignore\n            [bind]\n\n        /// Command to call `promise` block and map the success\n        let perform (task: 'a -> Fable.Core.JS.Promise<_>)\n                   (arg:'a)\n                   (ofSuccess: _ -> 'msg) =\n            let bind dispatch =\n                (task arg)\n                    .``then``(ofSuccess >> dispatch)\n                    |> ignore\n            [bind]\n\n        /// Command to call `promise` block and map the error\n        let attempt (task: 'a -> Fable.Core.JS.Promise<_>)\n                    (arg:'a)\n                    (ofError: #exn -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                (task arg)\n                    .catch(unbox >> ofError >> dispatch)\n                    |> ignore\n            [bind]\n\n        /// Command to dispatch the `promise` result\n        let result (task: Fable.Core.JS.Promise<'msg>) =\n            let bind dispatch =\n                task.``then`` dispatch\n                |> ignore\n            [bind]\n\n    [<Obsolete(\"Use `OfPromise.either` instead\")>]\n    let inline ofPromise (task: 'a -> Fable.Core.JS.Promise<_>)\n                         (arg:'a)\n                         (ofSuccess: _ -> 'msg)\n                         (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfPromise.either task arg ofSuccess ofError                     \n#else\n    open System.Threading.Tasks\n    module OfTask =\n        /// Command to call a task and map the results\n        let inline either (task: 'a -> Task<_>)\n                          (arg:'a)\n                          (ofSuccess: _ -> 'msg)\n                          (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsync.either (task >> Async.AwaitTask) arg ofSuccess ofError\n\n        /// Command to call a task and map the success\n        let inline perform (task: 'a -> Task<_>)\n                           (arg:'a)\n                           (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            OfAsync.perform (task >> Async.AwaitTask) arg ofSuccess\n\n        /// Command to call a task and map the error\n        let inline attempt (task: 'a -> Task<_>)\n                           (arg:'a)\n                           (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsync.attempt (task >> Async.AwaitTask) arg ofError\n\n        /// Command and map the task success\n        let inline result (task: Task<'msg>) : Cmd<'msg> =\n            OfAsync.result (task |> Async.AwaitTask)\n\n    [<Obsolete(\"Use OfTask.either instead\")>]\n    let inline ofTask (task: 'a -> Task<_>)\n                      (arg:'a)\n                      (ofSuccess: _ -> 'msg)\n                      (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfTask.either task arg ofSuccess ofError\n#endif\n\n    // Synonymous with `OfFunc.result`, may be removed in the future\n    let inline ofMsg (msg:'msg) : Cmd<'msg> =\n        OfFunc.result msg\n\n    [<Obsolete(\"Use `Cmd.OfAsync.either` instead\")>]\n    let inline ofAsync (task: 'a -> Async<_>)\n                       (arg: 'a)\n                       (ofSuccess: _ -> 'msg)\n                       (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfAsync.either task arg ofSuccess ofError\n\n    [<Obsolete(\"Use `Cmd.OfFunc.either` instead\")>]\n    let inline ofFunc (task: 'a -> _) (arg: 'a) (ofSuccess: _ -> 'msg) (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfFunc.either task arg ofSuccess ofError\n\n    [<Obsolete(\"Use `Cmd.OfFunc.perform` instead\")>]\n    let inline performFunc (task: 'a -> _) (arg: 'a) (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n        OfFunc.perform task arg ofSuccess\n\n    [<Obsolete(\"Use `Cmd.OfFunc.attempt` instead\")>]\n    let attemptFunc (task: 'a -> unit) (arg: 'a) (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfFunc.attempt task arg ofError\n\n","﻿module Util\n\nopen Fable.React.Props\n\nlet ClassNames classes =\n    ClassName <| String.concat \" \" classes\n    \n    \ntype OptionBuilder() =\n    member __.Bind(option, f) =\n        Option.bind f option\n        \n    member __.Return(value) =\n        Some value\n    \nlet option = OptionBuilder()","﻿module Rating\n\nopen Styles\nopen ExpectedValues\nopen BattleResult\n\nlet (|Below|_|) threshold n =\n    if n < threshold then Some() else None\n\nlet winRateColorClasses winRate =\n    match winRate with\n    | Below 0.45 -> tw.``bg-r-very-bad``, tw.``text-r-very-bad-fg``\n    | Below 0.47 -> tw.``bg-r-bad``, tw.``text-r-bad-fg``\n    | Below 0.49 -> tw.``bg-r-below-average``, tw.``text-r-below-average-fg``\n    | Below 0.52 -> tw.``bg-r-average``, tw.``text-r-average-fg``\n    | Below 0.54 -> tw.``bg-r-good``, tw.``text-r-good-fg``\n    | Below 0.56 -> tw.``bg-r-very-good``, tw.``text-r-very-good-fg``\n    | Below 0.60 -> tw.``bg-r-great``, tw.``text-r-great-fg``\n    | Below 0.65 -> tw.``bg-r-unicum``, tw.``text-r-unicum-fg``\n    | _ -> tw.``bg-r-super-unicum``, tw.``text-r-super-unicum-fg``\n\nlet calculateWinRate battles =\n    match battles with\n    | [] -> None\n    | _ ->\n        let isVictory battle =\n            match battle.Outcome with\n            | Victory -> true\n            | DrawOrLoss -> false\n\n        let victories = List.filter isVictory battles\n        let winRate = float (List.length victories) / float (List.length battles)\n        Some winRate\n\nlet formatWinRate winRate =\n    sprintf \"%.0f%%\" (winRate * 100.)\n\nlet wn8ColorClasses winRate =\n    match winRate with\n    | Below 300. -> tw.``bg-r-very-bad``, tw.``text-r-very-bad-fg``\n    | Below 600. -> tw.``bg-r-bad``, tw.``text-r-bad-fg``\n    | Below 900. -> tw.``bg-r-below-average``, tw.``text-r-below-average-fg``\n    | Below 1250. -> tw.``bg-r-average``, tw.``text-r-average-fg``\n    | Below 1600. -> tw.``bg-r-good``, tw.``text-r-good-fg``\n    | Below 1900. -> tw.``bg-r-very-good``, tw.``text-r-very-good-fg``\n    | Below 2350. -> tw.``bg-r-great``, tw.``text-r-great-fg``\n    | Below 2900. -> tw.``bg-r-unicum``, tw.``text-r-unicum-fg``\n    | _ -> tw.``bg-r-super-unicum``, tw.``text-r-super-unicum-fg``\n\nlet calculateWn8 expectedValuesMap battles =\n    let mutable totalDmg = 0\n    let mutable totalSpot = 0\n    let mutable totalFrag = 0\n    let mutable totalDef = 0\n    let mutable totalWin = 0\n\n    let mutable expDmg = 0.\n    let mutable expSpot = 0.\n    let mutable expFrag = 0.\n    let mutable expDef = 0.\n    let mutable expWin = 0.\n\n    for battle in battles do\n        match battle.BonusType with\n        | RandomBattle rnd ->\n            match Map.tryFind rnd.VehicleId expectedValuesMap with\n            | Some expectedValues ->\n                totalDmg <- totalDmg + rnd.DamageDealt\n                totalSpot <- totalSpot + rnd.Spots\n                totalFrag <- totalFrag + rnd.Frags\n                totalDef <- totalDef + rnd.DefencePoints\n                totalWin <-\n                    match battle.Outcome with\n                    | Victory -> totalWin + 1\n                    | _ -> totalWin\n\n                expDmg <- expDmg + expectedValues.DamageDealtTarget\n                expSpot <- expSpot + expectedValues.SpotsTarget\n                expFrag <- expFrag + expectedValues.FragsTarget\n                expDef <- expDef + expectedValues.DefencePointsTarget\n                expWin <- expWin + expectedValues.WinRateTarget\n            | None -> ()\n        | _ -> ()\n\n    match expDmg, expSpot, expFrag, expDef, expWin with\n    | 0., 0., 0., 0., 0. -> None\n    | _ ->\n        let rDAMAGE = float totalDmg / expDmg\n        let rSPOT = float totalSpot / expSpot\n        let rFRAG = float totalFrag / expFrag\n        let rDEF = float totalDef / expDef\n        let rWIN = float totalWin / expWin\n\n        let normalizeValue rSTAT constant =\n            (rSTAT - constant) / (1. - constant)\n\n        let rWINc = max 0. (normalizeValue rWIN 0.71)\n        let rDAMAGEc = max 0. (normalizeValue rDAMAGE 0.22)\n        let rFRAGc = max 0. (min (rDAMAGEc + 0.2) (normalizeValue rFRAG 0.12))\n        let rSPOTc = max 0. (min (rDAMAGEc + 0.1) (normalizeValue rSPOT 0.38))\n        let rDEFc = max 0. (min (rDAMAGEc + 0.1) (normalizeValue rDEF 0.1))\n\n        let wn8 =\n            980. * rDAMAGEc + 210. * rDAMAGEc * rFRAGc + 155. * rFRAGc * rSPOTc\n            + 75. * rDEFc * rFRAGc + 14.5 * (min 1.8 rWINc)\n        Some wn8\n\nlet formatWn8 wn8 =\n    sprintf \"%.0f\" wn8\n","namespace Elmish\nopen System\n\n[<Struct>]\ntype internal RingState<'item> =\n    | Writable of wx:'item array * ix:int\n    | ReadWritable of rw:'item array * wix:int * rix:int\n\ntype internal RingBuffer<'item>(size) =\n    let doubleSize ix (items: 'item array) =\n        seq { yield! items |> Seq.skip ix\n              yield! items |> Seq.take ix\n              for _ in 0..items.Length do\n                yield Unchecked.defaultof<'item> }\n        |> Array.ofSeq\n\n    let mutable state : 'item RingState =\n        Writable (Array.zeroCreate (max size 10), 0)\n\n    member __.Pop() =\n        match state with\n        | ReadWritable (items, wix, rix) ->\n            let rix' = (rix + 1) % items.Length\n            match rix' = wix with\n            | true -> \n                state <- Writable(items, wix)\n            | _ ->\n                state <- ReadWritable(items, wix, rix')\n            Some items.[rix]\n        | _ ->\n            None\n\n    member __.Push (item:'item) =\n        match state with\n        | Writable (items, ix) ->\n            items.[ix] <- item\n            let wix = (ix + 1) % items.Length\n            state <- ReadWritable(items, wix, ix)\n        | ReadWritable (items, wix, rix) ->\n            items.[wix] <- item\n            let wix' = (wix + 1) % items.Length\n            match wix' = rix with\n            | true -> \n                state <- ReadWritable(items |> doubleSize rix, items.Length, 0)\n            | _ -> \n                state <- ReadWritable(items, wix', rix)","(**\nProgram\n---------\nCore abstractions for creating and running the dispatch loop.\n\n*)\n\nnamespace Elmish\n\n\n/// Program type captures various aspects of program behavior\ntype Program<'arg, 'model, 'msg, 'view> = private {\n    init : 'arg -> 'model * Cmd<'msg>\n    update : 'msg -> 'model -> 'model * Cmd<'msg>\n    subscribe : 'model -> Cmd<'msg>\n    view : 'model -> Dispatch<'msg> -> 'view\n    setState : 'model -> Dispatch<'msg> -> unit\n    onError : (string*exn) -> unit\n    syncDispatch: Dispatch<'msg> -> Dispatch<'msg>\n}\n\n/// Program module - functions to manipulate program instances\n[<RequireQualifiedAccess>]\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Program =\n    /// Typical program, new commands are produced by `init` and `update` along with the new state.\n    let mkProgram \n        (init : 'arg -> 'model * Cmd<'msg>) \n        (update : 'msg -> 'model -> 'model * Cmd<'msg>)\n        (view : 'model -> Dispatch<'msg> -> 'view) =\n        { init = init\n          update = update\n          view = view\n          setState = fun model -> view model >> ignore\n          subscribe = fun _ -> Cmd.none\n          onError = Log.onError\n          syncDispatch = id }\n\n    /// Simple program that produces only new state with `init` and `update`.\n    let mkSimple \n        (init : 'arg -> 'model) \n        (update : 'msg -> 'model -> 'model)\n        (view : 'model -> Dispatch<'msg> -> 'view) =\n        { init = init >> fun state -> state,Cmd.none\n          update = fun msg -> update msg >> fun state -> state,Cmd.none\n          view = view\n          setState = fun model -> view model >> ignore\n          subscribe = fun _ -> Cmd.none\n          onError = Log.onError\n          syncDispatch = id }\n\n    /// Subscribe to external source of events.\n    /// The subscription is called once - with the initial model, but can dispatch new messages at any time.\n    let withSubscription (subscribe : 'model -> Cmd<'msg>) (program: Program<'arg, 'model, 'msg, 'view>) =\n        let sub model =\n            Cmd.batch [ program.subscribe model\n                        subscribe model ]\n        { program with subscribe = sub }\n\n    /// Trace all the updates to the console\n    let withConsoleTrace (program: Program<'arg, 'model, 'msg, 'view>) =\n        let traceInit (arg:'arg) =\n            let initModel,cmd = program.init arg\n            Log.toConsole (\"Initial state:\", initModel)\n            initModel,cmd\n\n        let traceUpdate msg model =\n            Log.toConsole (\"New message:\", msg)\n            let newModel,cmd = program.update msg model\n            Log.toConsole (\"Updated state:\", newModel)\n            newModel,cmd\n\n        { program with\n            init = traceInit \n            update = traceUpdate }\n\n    /// Trace all the messages as they update the model\n    let withTrace trace (program: Program<'arg, 'model, 'msg, 'view>) =\n        let update msg model =\n            let state,cmd = program.update msg model\n            trace msg state\n            state,cmd\n        { program\n            with update = update }\n\n    /// Handle dispatch loop exceptions\n    let withErrorHandler onError (program: Program<'arg, 'model, 'msg, 'view>) =\n        { program\n            with onError = onError }\n\n    /// For library authors only: map existing error handler and return new `Program` \n    let mapErrorHandler map (program: Program<'arg, 'model, 'msg, 'view>) =\n        { program\n            with onError = map program.onError }\n\n    /// For library authors only: get the current error handler \n    let onError (program: Program<'arg, 'model, 'msg, 'view>) =\n        program.onError\n\n    /// For library authors only: function to render the view with the latest state \n    let withSetState (setState:'model -> Dispatch<'msg> -> unit)\n                     (program: Program<'arg, 'model, 'msg, 'view>) =        \n        { program\n            with setState = setState }\n\n    /// For library authors only: return the function to render the state \n    let setState (program: Program<'arg, 'model, 'msg, 'view>) =        \n        program.setState\n\n    /// For library authors only: return the view function \n    let view (program: Program<'arg, 'model, 'msg, 'view>) =        \n        program.view\n\n    /// For library authors only: function to synchronize the dispatch function\n    let withSyncDispatch (syncDispatch:Dispatch<'msg> -> Dispatch<'msg>)\n                         (program: Program<'arg, 'model, 'msg, 'view>) =        \n        { program\n            with syncDispatch = syncDispatch }\n\n    /// For library authors only: map the program type\n    let map mapInit mapUpdate mapView mapSetState mapSubscribe\n            (program: Program<'arg, 'model, 'msg, 'view>) =\n        { init = mapInit program.init\n          update = mapUpdate program.update\n          view = mapView program.view\n          setState = mapSetState program.setState\n          subscribe = mapSubscribe program.subscribe\n          onError = program.onError\n          syncDispatch = id }\n\n    /// Start the program loop.\n    /// arg: argument to pass to the init() function.\n    /// program: program created with 'mkSimple' or 'mkProgram'.\n    let runWith (arg: 'arg) (program: Program<'arg, 'model, 'msg, 'view>) =\n        let (model,cmd) = program.init arg\n        let rb = RingBuffer 10\n        let mutable reentered = false\n        let mutable state = model        \n        let rec dispatch msg = \n            if reentered then\n                rb.Push msg\n            else\n                reentered <- true\n                let mutable nextMsg = Some msg\n                while Option.isSome nextMsg do\n                    let msg = nextMsg.Value\n                    try\n                        let (model',cmd') = program.update msg state\n                        program.setState model' syncDispatch\n                        cmd' |> Cmd.exec syncDispatch\n                        state <- model'\n                    with ex ->\n                        program.onError (sprintf \"Unable to process the message: %A\" msg, ex)\n                    nextMsg <- rb.Pop()\n                reentered <- false\n        and syncDispatch = program.syncDispatch dispatch            \n\n        program.setState model syncDispatch\n        let sub = \n            try \n                program.subscribe model \n            with ex ->\n                program.onError (\"Unable to subscribe:\", ex)\n                Cmd.none\n        sub @ cmd |> Cmd.exec syncDispatch\n\n    /// Start the dispatch loop with `unit` for the init() function.\n    let run (program: Program<unit, 'model, 'msg, 'view>) = runWith () program\n","namespace Elmish.React\n\nopen Fable.React\nopen Elmish\n\ntype LazyProps<'model> = {\n    model:'model\n    render:unit->ReactElement\n    equal:'model->'model->bool\n}\n\nmodule Components =\n    type LazyView<'model>(props) =\n        inherit Component<LazyProps<'model>,obj>(props)\n\n        override this.shouldComponentUpdate(nextProps, _nextState) =\n            not <| this.props.equal this.props.model nextProps.model\n\n        override this.render () =\n            this.props.render ()\n\n[<AutoOpen>]\nmodule Common =\n    /// Avoid rendering the view unless the model has changed.\n    /// equal: function to compare the previous and the new states\n    /// view: function to render the model\n    /// state: new state to render\n    let lazyViewWith (equal:'model->'model->bool)\n                     (view:'model->ReactElement)\n                     (state:'model) =\n        ofType<Components.LazyView<_>,_,_>\n            { render = fun () -> view state\n              equal = equal\n              model = state }\n            []\n\n    /// Avoid rendering the view unless the model has changed.\n    /// equal: function to compare the previous and the new states\n    /// view: function to render the model using the dispatch\n    /// state: new state to render\n    /// dispatch: dispatch function\n    let lazyView2With (equal:'model->'model->bool)\n                      (view:'model->'msg Dispatch->ReactElement)\n                      (state:'model)\n                      (dispatch:'msg Dispatch) =\n        ofType<Components.LazyView<_>,_,_>\n            { render = fun () -> view state dispatch\n              equal = equal\n              model = state }\n            []\n\n    /// Avoid rendering the view unless the model has changed.\n    /// equal: function to compare the previous and the new model (a tuple of two states)\n    /// view: function to render the model using the dispatch\n    /// state1: new state to render\n    /// state2: new state to render\n    /// dispatch: dispatch function\n    let lazyView3With (equal:_->_->bool) (view:_->_->_->ReactElement) state1 state2 (dispatch:'msg Dispatch) =\n        ofType<Components.LazyView<_>,_,_>\n            { render = fun () -> view state1 state2 dispatch\n              equal = equal\n              model = (state1,state2) }\n            []\n\n    /// Avoid rendering the view unless the model has changed.\n    /// view: function of model to render the view\n    let lazyView (view:'model->ReactElement) =\n        lazyViewWith (=) view\n\n    /// Avoid rendering the view unless the model has changed.\n    /// view: function of two arguments to render the model using the dispatch\n    let lazyView2 (view:'model->'msg Dispatch->ReactElement) =\n        lazyView2With (=) view\n\n    /// Avoid rendering the view unless the model has changed.\n    /// view: function of three arguments to render the model using the dispatch\n    let lazyView3 (view:_->_->_->ReactElement) =\n        lazyView3With (=) view\n\n\n","namespace Elmish.React\n\n[<AutoOpen>]\nmodule Helpers =\n    open Fable.React.Props\n    open Fable.Core.JsInterop\n\n    /// `Ref` callback that sets the value of an input textbox after DOM element is created.\n    /// Can be used instead of `DefaultValue` and `Value` props to override input box value.\n    let inline valueOrDefault value =\n        Ref <| (fun e -> if e |> isNull |> not && !!e?value <> !!value then e?value <- !!value)\n\n[<RequireQualifiedAccess>]\nmodule Program =\n\n    module Internal =\n\n        open Fable.React\n        open Browser\n        open Elmish\n\n        let withReactBatchedUsing lazyView2With placeholderId (program:Program<_,_,_,_>) =\n            let mutable lastRequest = None\n            let setState model dispatch =\n                match lastRequest with\n                | Some r -> window.cancelAnimationFrame r\n                | _ -> ()\n\n                lastRequest <- Some (window.requestAnimationFrame (fun _ ->\n                    ReactDom.render(\n                        lazyView2With (fun x y -> obj.ReferenceEquals(x,y)) (Program.view program) model dispatch,\n                        document.getElementById placeholderId\n                    )))\n\n            program\n            |> Program.withSetState setState\n\n        let withReactSynchronousUsing lazyView2With placeholderId (program:Elmish.Program<_,_,_,_>) =\n            let setState model dispatch =\n                ReactDom.render(\n                    lazyView2With (fun x y -> obj.ReferenceEquals(x,y)) (Program.view program) model dispatch,\n                    document.getElementById placeholderId\n                )\n\n            program\n            |> Program.withSetState setState\n\n        let withReactHydrateUsing lazyView2With placeholderId (program:Elmish.Program<_,_,_,_>) =\n            let setState model dispatch =\n                ReactDom.hydrate(\n                    lazyView2With (fun x y -> obj.ReferenceEquals(x,y)) (Program.view program) model dispatch,\n                    document.getElementById placeholderId\n                )\n\n            program\n            |> Program.withSetState setState\n\n\n    /// Renders React root component inside html element identified by placeholderId.\n    /// Uses `requestAnimationFrame` to batch updates to prevent drops in frame rate.\n    /// NOTE: This may have unexpected effects in React controlled inputs, see https://github.com/elmish/react/issues/12\n    let withReactBatched placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactBatchedUsing lazyView2With placeholderId program\n\n    /// Renders React root component inside html element identified by placeholderId.\n    /// New renders are triggered immediately after an update.\n    let withReactSynchronous placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactSynchronousUsing lazyView2With placeholderId program\n\n    [<System.Obsolete(\"Use withReactBatched\")>]\n    let withReact placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactBatchedUsing lazyView2With placeholderId program\n\n    [<System.Obsolete(\"Use withReactSynchronous\")>]\n    let withReactUnoptimized placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactSynchronousUsing lazyView2With placeholderId program\n\n    /// Renders React root component inside html element identified by placeholderId using `React.hydrate`.\n    let withReactHydrate placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactHydrateUsing lazyView2With placeholderId program\n","﻿module App\r\n\r\nopen Browser\r\nopen Browser.Types\r\nopen Elmish\r\nopen Elmish.React\r\nopen Elmish.Debug\r\n\r\nopen ExpectedValues\r\nopen BattleResult\r\nopen Protocol\r\n\r\ntype ConnectionState =\r\n    | Connecting\r\n    | Subscribed\r\n    | Disconnected\r\n    | ProtocolError\r\n\r\ntype LoadingState<'a> =\r\n    | Loading\r\n    | Loaded of 'a\r\n    | Errored\r\n\r\ntype Model =\r\n    { ConnectionState: ConnectionState\r\n      ExpectedValues: Map<VehicleId, ExpectedValues> LoadingState\r\n      BattleResults: BattleResult list\r\n      BattleResultsOffset: BattleResultsOffset }\r\n\r\ntype Msg =\r\n    | Connect\r\n    | ConnectionStateChanged of ConnectionState\r\n    | GotInitResponse of InitResponse\r\n    | GotSubscriptionNotification of SubscriptionNotification\r\n    | FetchExpectedValues\r\n    | GotExpectedValues of Map<VehicleId, ExpectedValues>\r\n    | FetchingExpectedValuesErrored\r\n\r\nopen Thoth.Json\r\n\r\nlet connectToServer battleResultsOffset dispatch =\r\n    let ws = WebSocket.Create \"ws://localhost:15455\"\r\n\r\n    let onOpen () =\r\n        { BattleResultsOffset = battleResultsOffset }\r\n        |> InitRequest.encode\r\n        |> Encode.toString 0\r\n        |> ws.send\r\n\r\n    let onClose () =\r\n        dispatch (ConnectionStateChanged Disconnected)\r\n\r\n    let onProtocolError () =\r\n        // ignore close event to not dispatch another state change\r\n        ws.onclose <- ignore\r\n        ws.close ()\r\n        dispatch (ConnectionStateChanged ProtocolError)\r\n\r\n    let onSubscriptionMessage (e: MessageEvent) =\r\n        e.data\r\n        |> unbox\r\n        |> Decode.fromString SubscriptionNotification.decoder\r\n        |> Result.map (GotSubscriptionNotification >> dispatch)\r\n        |> Result.mapError (ignore >> onProtocolError)\r\n\r\n    let onInitialMessage (e: MessageEvent) =\r\n        e.data\r\n        |> unbox\r\n        |> Decode.fromString InitResponse.decoder\r\n        |> Result.map (fun value ->\r\n            // switch to handling subscription notifications\r\n            ws.onmessage <- onSubscriptionMessage\r\n            dispatch (ConnectionStateChanged Subscribed)\r\n            dispatch (GotInitResponse value))\r\n        |> Result.mapError (ignore >> onProtocolError)\r\n\r\n    ws.onopen <- (ignore >> onOpen)\r\n    ws.onclose <- (ignore >> onClose)\r\n    ws.onmessage <- onInitialMessage\r\n\r\n    dispatch (ConnectionStateChanged Connecting)\r\n\r\nlet init () =\r\n    let model =\r\n        { ConnectionState = Disconnected\r\n          ExpectedValues = Loading\r\n          BattleResults = []\r\n          BattleResultsOffset = 0 }\r\n\r\n    model,\r\n    Cmd.batch\r\n        [ Cmd.ofMsg Connect\r\n          Cmd.ofMsg FetchExpectedValues ]\r\n\r\nlet update msg model =\r\n    match msg with\r\n    | Connect ->\r\n        match model.ConnectionState with\r\n        | Disconnected ->\r\n            model, Cmd.ofSub (connectToServer model.BattleResultsOffset)\r\n        | _ -> model, Cmd.none\r\n\r\n    | ConnectionStateChanged newState ->\r\n        { model with ConnectionState = newState }, Cmd.none\r\n\r\n    | GotSubscriptionNotification notification ->\r\n        { model with\r\n              BattleResultsOffset = notification.BattleResultsOffset\r\n              BattleResults = model.BattleResults @ [ notification.BattleResult ] }, Cmd.none\r\n\r\n    | GotInitResponse response ->\r\n        { model with\r\n              BattleResultsOffset = response.BattleResultsOffset\r\n              BattleResults = model.BattleResults @ response.BattleResults }, Cmd.none\r\n\r\n    | FetchExpectedValues ->\r\n        { model with ExpectedValues = Loading },\r\n        Cmd.OfPromise.either fetchExpectedValuesMap () GotExpectedValues\r\n            (fun _ -> FetchingExpectedValuesErrored)\r\n\r\n    | GotExpectedValues values -> { model with ExpectedValues = Loaded values }, Cmd.none\r\n\r\n    | FetchingExpectedValuesErrored -> { model with ExpectedValues = Errored }, Cmd.none\r\n\r\nopen Fable.React\r\nopen Fable.React.Props\r\nopen Util\r\nopen Styles\r\nopen Rating\r\n\r\nlet viewStatusBar model dispatch =\r\n    let viewButton label action =\r\n        button\r\n            [ OnClick(fun _ -> dispatch action)\r\n              ClassNames\r\n                  [ tw.``bg-gray-100``\r\n                    tw.``hover:bg-gray-300``\r\n                    tw.``text-sm``\r\n                    tw.``py-1``\r\n                    tw.``px-4``\r\n                    tw.``border-solid``\r\n                    tw.``border-2``\r\n                    tw.``border-gray-300``\r\n                    tw.rounded ] ] [ str label ]\r\n\r\n    match model.ConnectionState, model.ExpectedValues with\r\n    | Connecting, _ ->\r\n        aside [ ClassNames [ tw.``bg-blue-400``; tw.``p-2`` ] ]\r\n            [ h3 []\r\n                  [ str \"Connecting to battle results server \"\r\n                    span [ ClassName tw.``font-bold`` ] [ str \"...\" ] ] ]\r\n\r\n    | Disconnected, _ ->\r\n        aside\r\n            [ ClassNames\r\n                [ tw.``bg-red-600``; tw.``p-2``; tw.``space-x-8``; tw.flex; tw.``items-center`` ] ]\r\n            [ div [ ClassName tw.``flex-grow`` ]\r\n                  [ h3 [ ClassName tw.``font-bold`` ] [ str \"Disconnected.\" ]\r\n                    p []\r\n                        [ str \"Could not connect to the battle results server. \\\r\n                                Please make sure that WoT is running and that the \"\r\n                          a\r\n                              [ Href \"https://wgmods.net/4662/\"\r\n                                ClassName tw.underline ] [ str \"Battle Results Server\" ]\r\n                          str \" mod is installed correctly.\" ] ]\r\n              viewButton \"Connect\" Connect ]\r\n\r\n    | ProtocolError, _ ->\r\n        aside [ ClassNames [ tw.``bg-red-600``; tw.``p-2`` ] ]\r\n            [ h3 [ ClassName tw.``font-bold`` ] [ str \"Oh no.\" ]\r\n              p []\r\n                  [ str \"Something went wrong. Please make sure that the the latest version of the \"\r\n                    a\r\n                        [ Href \"https://wgmods.net/4662/\"\r\n                          ClassName tw.underline ] [ str \"Battle Results Server\" ]\r\n                    str \" mod is installed.\" ] ]\r\n\r\n    | _, Errored ->\r\n        aside\r\n            [ ClassNames\r\n                [ tw.``bg-red-600``; tw.``p-2``; tw.``space-x-8``; tw.flex; tw.``items-center`` ] ]\r\n            [ h3 [ ClassName tw.``flex-grow`` ]\r\n                  [ str \"Could not fetch expected values for WN8 calculation.\" ]\r\n              viewButton \"Retry\" FetchExpectedValues ]\r\n\r\n    | _, _ -> nothing\r\n\r\nlet viewWinRateWidget model =\r\n    let randomBattles =\r\n        model.BattleResults |> List.filter BattleResult.isRandomBattle\r\n\r\n    let winRate = calculateWinRate randomBattles\r\n\r\n    let winRateBgColor, winRateTextColor =\r\n        winRate\r\n        |> Option.map winRateColorClasses\r\n        |> Option.defaultValue (tw.``bg-black``, tw.``text-white``)\r\n\r\n    let winRateText =\r\n        winRate\r\n        |> Option.map formatWinRate\r\n        |> Option.defaultValue \"N/A\"\r\n\r\n    section\r\n        [ ClassNames\r\n            [ tw.``col-span-1``\r\n              tw.``row-span-1``\r\n              winRateBgColor\r\n              tw.flex\r\n              tw.``items-center``\r\n              tw.``justify-center`` ] ]\r\n        [ div [ ClassNames [ tw.``text-center``; winRateTextColor; tw.``leading-tight`` ] ]\r\n              [ h2 [ ClassName tw.``text-xl`` ] [ str \"Win Rate\" ]\r\n                p [ ClassName tw.``text-6xl`` ] [ str winRateText ] ] ]\r\n\r\nlet viewWn8Widget model =\r\n    let wn8 =\r\n        match model.ExpectedValues with\r\n        | Loaded expectedValuesMap -> calculateWn8 expectedValuesMap model.BattleResults\r\n        | _ -> None\r\n\r\n    let wn8BgColor, wn8TextColor =\r\n        wn8\r\n        |> Option.map wn8ColorClasses\r\n        |> Option.defaultValue (tw.``bg-black``, tw.``text-white``)\r\n\r\n    let wn8Text =\r\n        wn8\r\n        |> Option.map formatWn8\r\n        |> Option.defaultValue \"N/A\"\r\n\r\n    section\r\n        [ ClassNames\r\n            [ tw.``col-span-1``\r\n              tw.``row-span-1``\r\n              wn8BgColor\r\n              tw.flex\r\n              tw.``items-center``\r\n              tw.``justify-center`` ] ]\r\n        [ div [ ClassNames [ tw.``text-center``; wn8TextColor; tw.``leading-tight`` ] ]\r\n              [ h2 [ ClassName tw.``text-xl`` ] [ str \"WN8\" ]\r\n                p [ ClassName tw.``text-6xl`` ] [ str wn8Text ] ] ]\r\n\r\nlet view model dispatch =\r\n    fragment []\r\n        [ viewStatusBar model dispatch\r\n          header [ ClassNames [ tw.``bg-gray-900``; tw.``text-white``; tw.``p-2`` ] ]\r\n              [ h1 [] [ str \"WoT Session Dashboard\" ] ]\r\n          main\r\n              [ ClassNames\r\n                  [ tw.grid; tw.``grid-flow-row-dense``; tw.``grid-rows-h-48``; tw.``grid-cols-fill-w-64`` ] ]\r\n              [ viewWinRateWidget model\r\n                viewWn8Widget model ] ]\r\n\r\nProgram.mkProgram init update view\r\n|> Program.withReactBatched \"elmish-app\"\r\n#if DEBUG\r\n|> Program.withDebugger\r\n#endif\r\n|> Program.run\r\n"],"sourceRoot":""}